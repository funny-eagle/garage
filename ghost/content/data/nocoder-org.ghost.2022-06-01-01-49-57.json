{"meta":{"exported_on":1654048197221,"version":"5.1.1"},"data":{"posts":[{"id":"6160769067f6c50001275527","uuid":"795bf84f-3b1a-436a-9dc3-d8a523b886f4","title":"关于日志的那些事儿","slug":"guan-yu-ri-zhi-de-na-xie-shi-er","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 这篇短文整理了关于日志的一些内容，皓哥要求的目标是一篇“引经据典“的，“全面系统“的对日志的介绍。结合以往的经验和一些参考链接，对软件开发过程中日志相关的知识进行梳理和学习。\\n\\n## 日志的定义\\n\\n先说说咱们日常生活中的日志，就是日记的另一种说法。\\n\\n> [日记](https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0)是以日期为排列顺序的笔记。人们用日记来记录天气、事件一直到个人的心理感受、思想深处。日记可以是记录将要做的事情的，也可以记录已经发生的事情和心情。\\n\\n在计算机领域，日志文件的定义如下：\\n\\n> [日志文件](https://zh.wikipedia.org/zh-hans/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6)(logfile)是一个记录了发生在运行中的操作系统或其他软件中的事件的文件，或者记录了在网络聊天软件的用户之间发送的消息。日志记录(Logging)是指保存日志的行为。\\n\\n\\n## 日志的意义\\n\\n记录日志是软件开发中很重要的一部分。编写良好的日志代码能为软件提供快速的诊断信息和良好的存储结构。我们可以通过对记录的日志进行分析来支撑一些其他的功能，例如解析mysql的binary log来同步数据，通过日志分析用户行为，系统某功能的访问频率，通过日志排查程序的BUG等等。\\n\\n- 开发人员调试程序\\n  - 开发阶段的debug日志，通过输出重要参数来调试跟踪程序的正确性\\n- 记录用户行为\\n  - 记录用户的操作，访问，一般用于数据分析，操作留痕 \\n- 记录程序的运行情况\\n  - 记录程序的运行情况，尤其是异常情况，是排查问题的重要线索\\n- 记录系统的状态\\n  - 记录网络请求、IO等，便于监控和排查问题\\n\\n## 日志的类型\\n\\n- 行为日志\\n  - 分析用户的行为日志内容来实现数据分析等功能 \\n- 访问日志\\n  - 访问来源、功能的访问频率 \\n- 错误日志\\n  - 记录程序运行错误的现场，解决问题的重要线索\\n- 数据库日志\\n  - 记录SQL记录，可以分析慢SQL，生成报告 \\n- ...\\n\\n## 日志的格式\\n\\n每条日志都要记录发生的时间、级别、日志内容、错误码、以及对应代码的位置，存储在文本文件或者数据库中。\\n\\t\\n\\n- JSON\\n\\n  ```\\n  {\\n  \\t\\t\\\"@timestamp\\\": \\\"2017-07025 17:02:12\\\",\\n  \\t\\t\\\"level\\\": \\\"error\\\",\\n  \\t\\t\\\"message\\\": \\\"connection refused\\\",\\n  \\t\\t\\\"service\\\": \\\"listener\\\",\\n  \\t\\t\\\"thread\\\": \\\"125\\\",\\n  \\t\\t\\\"customerid\\\": \\\"776622\\\",\\n  \\t\\t\\\"ip\\\": \\\"34.124.233.12\\\",\\n  \\t\\t\\\"queryid\\\": \\\"45\\\"\\n  \\t}\\n  ```\\n\\n- 键值对\\n\\n  ```\\n  \\t2017-07025 17:02:12 level=error message=\\\"connection refused\\\"\\n  service=\\\"listener\\\" thread=125 customerid=776622 ip=34.124.233.12\\n  queryid=45\\n  ```\\n\\n## 日志的级别\\n\\n不同的日志框架对日志的分类略有差异，通常来说，日志可以被分为以下六个级别，通过配置来输出对应级别的日志\\n\\n- FATAL\\n  - 导致程序提前结束的严重错误。\\n- ERROR\\n  - 运行时异常以及预期之外的错误。\\n- WARN\\n  - 预期之外的运行时状况，不一定是错误的情况。\\n- INFO\\n  - 运行时产生的事件。\\n- DEBUG\\n  - 与程序运行时的流程相关的详细信息。\\n- TRACE\\n  - 更加具体的详细信息。\\n\\n## 日志归档\\n\\n根据天数或者文件大小产生新的文件，对日志进行滚动归档，压缩保存。\\n\\n\\n## 日志的性能\\n\\n记录日志是软件开发必不可少的环节，必须考虑日志的性能带来的问题，举两个例子：\\n\\n- 使用占位符而不是字符串连接\\n\\n```\\nlogger.debug(\\\"Entry number: \\\" + i + \\\" is \\\" +  String.valueOf(entry[i])); \\nlogger.debug(\\\"Entry number: {} is {}\\\", i, entry[i]);\\n```\\n\\n上面两个语句输出的效果是一样的，但是性能却相差两个数量级，在关闭DEBUG日志时，它们的开销就不一样了，主要的影响在于字符串转换和字符串拼接上，无论是否生效，前者都会将变量转换为字符串并进行拼接，而后者则只会在需要时执行这些操作。\\n\\n- 避免无用的日志\\n  - 无用的日志占用磁盘空间，增加系统IO，影响系统性能 \\n\\n## 日志框架\\n\\n列举一些 Java 程序里常用的日志框架\\n\\n- Java Util Logger\\n  - Jdk 自带的 Logger， 从1.4版本开始就有了，使用起来非常方便，一般用于测试，不支持占位符\\n- Log4j\\n  - Log4j 应该是最常用的日志框架了，其高度可配置，在运行期使用外部的配置文件对其进行配置。它按照优先级别记录日志，并可将日志信息定向输出到各种介质，比如数据库、文件、控制台、Unix Syslog等。\\n  - loggers：负责采集日志信息。\\n  - appenders：负责将日志信息发布到不同地方。\\n  - layouts：负责以各种风格格式化日志信息。 \\t\\n- Slf4j\\n  - Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。\\n\\n- Logback\\n  - LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。 \\n  - LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。\\n  - logback-core提供了LogBack的核心功能，是另外两个组件的基础。\\n  - logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。\\n  - logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。\\n- ...\\n\\n## 最佳实践\\n\\n- 定义记录日志的目标\\n  - 记录日志的意义何在，用于数据分析，还是同步数据，或者其他 \\n- 记录什么内容\\n  - 记录有用的日志内容，考虑提高日志可读性，提高系统性能 \\n- 使用日志框架\\n  - 日志框架更专业，功能全面，标准化，易配置\\n- 标准化日志格式\\n  - 统一日志格式 \\n- 提供上下文\\n  - 尽可能的提供完整信息，提高可读性，如果记录不完整，对于数据分析、排查错误起不到作用，记日志的意义就不大了 \\n- 使用日志标识，异常码\\n  - 使用异常码，例如`30001`代表用户模块，`30002`代表XX模块，这样在看到日志的时候就可以清楚快速的定位到对应的功能。 \\n\\n## 参考文献\\n\\n- [日志文件wiki](https://zh.wikipedia.org/wiki/日志文件)\\n- [30 best practices for logging at scale](https://www.loggly.com/blog/30-best-practices-logging-scale/)\\n- [How to Log a Log: Application Logging Best Practices](https://logz.io/blog/logging-best-practices/)\\n- [Java Best Practices for Smarter Application Logging & Exception Handling](https://stackify.com/java-logging-best-practices/)\\n- [10 Best Practices for Log Management and Analytics](https://dzone.com/articles/10-best-practices-for-log-management-and-analytics-1)\\n- [程序那些事：日志记录的作用和方法](https://www.infoq.cn/article/why-and-how-log)\\n- [日志的五个级别](https://www.infoq.cn/article/five-levels-of-logging)\\n- [你的Java日志，有没有用这些改进办法？](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=207451012&idx=1&sn=de9fba4eda0f221363b6d5ae54243416&scene=27#wechat_redirect)\\n- [Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/index.html)\\n- [日志最佳实践](http://blog.jobbole.com/56574/)\\n- [Ultimate log4j Tutorial for Java Logging – Best Practices, Resources and Tips](https://stackify.com/log4j-guide-dotnet-logging/)\\n\\n\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>这篇短文整理了关于日志的一些内容，皓哥要求的目标是一篇“引经据典“的，“全面系统“的对日志的介绍。结合以往的经验和一些参考链接，对软件开发过程中日志相关的知识进行梳理和学习。</p>\n</blockquote>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9A%E4%B9%89\">日志的定义</h2>\n<p>先说说咱们日常生活中的日志，就是日记的另一种说法。</p>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0\">日记</a>是以日期为排列顺序的笔记。人们用日记来记录天气、事件一直到个人的心理感受、思想深处。日记可以是记录将要做的事情的，也可以记录已经发生的事情和心情。</p>\n</blockquote>\n<p>在计算机领域，日志文件的定义如下：</p>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6\">日志文件</a>(logfile)是一个记录了发生在运行中的操作系统或其他软件中的事件的文件，或者记录了在网络聊天软件的用户之间发送的消息。日志记录(Logging)是指保存日志的行为。</p>\n</blockquote>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E6%84%8F%E4%B9%89\">日志的意义</h2>\n<p>记录日志是软件开发中很重要的一部分。编写良好的日志代码能为软件提供快速的诊断信息和良好的存储结构。我们可以通过对记录的日志进行分析来支撑一些其他的功能，例如解析mysql的binary log来同步数据，通过日志分析用户行为，系统某功能的访问频率，通过日志排查程序的BUG等等。</p>\n<ul>\n<li>开发人员调试程序\n<ul>\n<li>开发阶段的debug日志，通过输出重要参数来调试跟踪程序的正确性</li>\n</ul>\n</li>\n<li>记录用户行为\n<ul>\n<li>记录用户的操作，访问，一般用于数据分析，操作留痕</li>\n</ul>\n</li>\n<li>记录程序的运行情况\n<ul>\n<li>记录程序的运行情况，尤其是异常情况，是排查问题的重要线索</li>\n</ul>\n</li>\n<li>记录系统的状态\n<ul>\n<li>记录网络请求、IO等，便于监控和排查问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E7%B1%BB%E5%9E%8B\">日志的类型</h2>\n<ul>\n<li>行为日志\n<ul>\n<li>分析用户的行为日志内容来实现数据分析等功能</li>\n</ul>\n</li>\n<li>访问日志\n<ul>\n<li>访问来源、功能的访问频率</li>\n</ul>\n</li>\n<li>错误日志\n<ul>\n<li>记录程序运行错误的现场，解决问题的重要线索</li>\n</ul>\n</li>\n<li>数据库日志\n<ul>\n<li>记录SQL记录，可以分析慢SQL，生成报告</li>\n</ul>\n</li>\n<li>...</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%BC%E5%BC%8F\">日志的格式</h2>\n<p>每条日志都要记录发生的时间、级别、日志内容、错误码、以及对应代码的位置，存储在文本文件或者数据库中。</p>\n<ul>\n<li>\n<p>JSON</p>\n<pre><code>{\n\t\t&quot;@timestamp&quot;: &quot;2017-07025 17:02:12&quot;,\n\t\t&quot;level&quot;: &quot;error&quot;,\n\t\t&quot;message&quot;: &quot;connection refused&quot;,\n\t\t&quot;service&quot;: &quot;listener&quot;,\n\t\t&quot;thread&quot;: &quot;125&quot;,\n\t\t&quot;customerid&quot;: &quot;776622&quot;,\n\t\t&quot;ip&quot;: &quot;34.124.233.12&quot;,\n\t\t&quot;queryid&quot;: &quot;45&quot;\n\t}\n</code></pre>\n</li>\n<li>\n<p>键值对</p>\n<pre><code>\t2017-07025 17:02:12 level=error message=&quot;connection refused&quot;\nservice=&quot;listener&quot; thread=125 customerid=776622 ip=34.124.233.12\nqueryid=45\n</code></pre>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E7%BA%A7%E5%88%AB\">日志的级别</h2>\n<p>不同的日志框架对日志的分类略有差异，通常来说，日志可以被分为以下六个级别，通过配置来输出对应级别的日志</p>\n<ul>\n<li>FATAL\n<ul>\n<li>导致程序提前结束的严重错误。</li>\n</ul>\n</li>\n<li>ERROR\n<ul>\n<li>运行时异常以及预期之外的错误。</li>\n</ul>\n</li>\n<li>WARN\n<ul>\n<li>预期之外的运行时状况，不一定是错误的情况。</li>\n</ul>\n</li>\n<li>INFO\n<ul>\n<li>运行时产生的事件。</li>\n</ul>\n</li>\n<li>DEBUG\n<ul>\n<li>与程序运行时的流程相关的详细信息。</li>\n</ul>\n</li>\n<li>TRACE\n<ul>\n<li>更加具体的详细信息。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3\">日志归档</h2>\n<p>根据天数或者文件大小产生新的文件，对日志进行滚动归档，压缩保存。</p>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E6%80%A7%E8%83%BD\">日志的性能</h2>\n<p>记录日志是软件开发必不可少的环节，必须考虑日志的性能带来的问题，举两个例子：</p>\n<ul>\n<li>使用占位符而不是字符串连接</li>\n</ul>\n<pre><code>logger.debug(&quot;Entry number: &quot; + i + &quot; is &quot; +  String.valueOf(entry[i])); \nlogger.debug(&quot;Entry number: {} is {}&quot;, i, entry[i]);\n</code></pre>\n<p>上面两个语句输出的效果是一样的，但是性能却相差两个数量级，在关闭DEBUG日志时，它们的开销就不一样了，主要的影响在于字符串转换和字符串拼接上，无论是否生效，前者都会将变量转换为字符串并进行拼接，而后者则只会在需要时执行这些操作。</p>\n<ul>\n<li>避免无用的日志\n<ul>\n<li>无用的日志占用磁盘空间，增加系统IO，影响系统性能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6\">日志框架</h2>\n<p>列举一些 Java 程序里常用的日志框架</p>\n<ul>\n<li>\n<p>Java Util Logger</p>\n<ul>\n<li>Jdk 自带的 Logger， 从1.4版本开始就有了，使用起来非常方便，一般用于测试，不支持占位符</li>\n</ul>\n</li>\n<li>\n<p>Log4j</p>\n<ul>\n<li>Log4j 应该是最常用的日志框架了，其高度可配置，在运行期使用外部的配置文件对其进行配置。它按照优先级别记录日志，并可将日志信息定向输出到各种介质，比如数据库、文件、控制台、Unix Syslog等。</li>\n<li>loggers：负责采集日志信息。</li>\n<li>appenders：负责将日志信息发布到不同地方。</li>\n<li>layouts：负责以各种风格格式化日志信息。</li>\n</ul>\n</li>\n<li>\n<p>Slf4j</p>\n<ul>\n<li>Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。</li>\n</ul>\n</li>\n<li>\n<p>Logback</p>\n<ul>\n<li>LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。</li>\n<li>LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。</li>\n<li>logback-core提供了LogBack的核心功能，是另外两个组件的基础。</li>\n<li>logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。</li>\n<li>logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。</li>\n</ul>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n<h2 id=\"%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</h2>\n<ul>\n<li>定义记录日志的目标\n<ul>\n<li>记录日志的意义何在，用于数据分析，还是同步数据，或者其他</li>\n</ul>\n</li>\n<li>记录什么内容\n<ul>\n<li>记录有用的日志内容，考虑提高日志可读性，提高系统性能</li>\n</ul>\n</li>\n<li>使用日志框架\n<ul>\n<li>日志框架更专业，功能全面，标准化，易配置</li>\n</ul>\n</li>\n<li>标准化日志格式\n<ul>\n<li>统一日志格式</li>\n</ul>\n</li>\n<li>提供上下文\n<ul>\n<li>尽可能的提供完整信息，提高可读性，如果记录不完整，对于数据分析、排查错误起不到作用，记日志的意义就不大了</li>\n</ul>\n</li>\n<li>使用日志标识，异常码\n<ul>\n<li>使用异常码，例如<code>30001</code>代表用户模块，<code>30002</code>代表XX模块，这样在看到日志的时候就可以清楚快速的定位到对应的功能。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6\">日志文件wiki</a></li>\n<li><a href=\"https://www.loggly.com/blog/30-best-practices-logging-scale/\">30 best practices for logging at scale</a></li>\n<li><a href=\"https://logz.io/blog/logging-best-practices/\">How to Log a Log: Application Logging Best Practices</a></li>\n<li><a href=\"https://stackify.com/java-logging-best-practices/\">Java Best Practices for Smarter Application Logging &amp; Exception Handling</a></li>\n<li><a href=\"https://dzone.com/articles/10-best-practices-for-log-management-and-analytics-1\">10 Best Practices for Log Management and Analytics</a></li>\n<li><a href=\"https://www.infoq.cn/article/why-and-how-log\">程序那些事：日志记录的作用和方法</a></li>\n<li><a href=\"https://www.infoq.cn/article/five-levels-of-logging\">日志的五个级别</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=207451012&amp;idx=1&amp;sn=de9fba4eda0f221363b6d5ae54243416&amp;scene=27#wechat_redirect\">你的Java日志，有没有用这些改进办法？</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/index.html\">Java 日志管理最佳实践</a></li>\n<li><a href=\"http://blog.jobbole.com/56574/\">日志最佳实践</a></li>\n<li><a href=\"https://stackify.com/log4j-guide-dotnet-logging/\">Ultimate log4j Tutorial for Java Logging – Best Practices, Resources and Tips</a></li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"6160769067f6c50001275527","plaintext":"> 这篇短文整理了关于日志的一些内容，皓哥要求的目标是一篇“引经据典“的，“全面系统“的对日志的介绍。结合以往的经验和一些参考链接，对软件开发过程中日志相关的知识进行梳理和学习。\n\n\n日志的定义\n先说说咱们日常生活中的日志，就是日记的另一种说法。\n\n> 日记 [https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0]\n是以日期为排列顺序的笔记。人们用日记来记录天气、事件一直到个人的心理感受、思想深处。日记可以是记录将要做的事情的，也可以记录已经发生的事情和心情。\n\n\n在计算机领域，日志文件的定义如下：\n\n> 日志文件 [https://zh.wikipedia.org/zh-hans/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6]\n(logfile)是一个记录了发生在运行中的操作系统或其他软件中的事件的文件，或者记录了在网络聊天软件的用户之间发送的消息。日志记录(Logging)是指保存日志的行为。\n\n\n日志的意义\n记录日志是软件开发中很重要的一部分。编写良好的日志代码能为软件提供快速的诊断信息和良好的存储结构。我们可以通过对记录的日志进行分析来支撑一些其他的功能，例如解析mysql的binary\nlog来同步数据，通过日志分析用户行为，系统某功能的访问频率，通过日志排查程序的BUG等等。\n\n * 开发人员调试程序 * 开发阶段的debug日志，通过输出重要参数来调试跟踪程序的正确性\n   \n   \n * 记录用户行为 * 记录用户的操作，访问，一般用于数据分析，操作留痕\n   \n   \n * 记录程序的运行情况 * 记录程序的运行情况，尤其是异常情况，是排查问题的重要线索\n   \n   \n * 记录系统的状态 * 记录网络请求、IO等，便于监控和排查问题\n   \n   \n\n日志的类型\n * 行为日志 * 分析用户的行为日志内容来实现数据分析等功能\n   \n   \n * 访问日志 * 访问来源、功能的访问频率\n   \n   \n * 错误日志 * 记录程序运行错误的现场，解决问题的重要线索\n   \n   \n * 数据库日志 * 记录SQL记录，可以分析慢SQL，生成报告\n   \n   \n * ...\n\n日志的格式\n每条日志都要记录发生的时间、级别、日志内容、错误码、以及对应代码的位置，存储在文本文件或者数据库中。\n\n * JSON\n   \n   {\n   \t\t\"@timestamp\": \"2017-07025 17:02:12\",\n   \t\t\"level\": \"error\",\n   \t\t\"message\": \"connection refused\",\n   \t\t\"service\": \"listener\",\n   \t\t\"thread\": \"125\",\n   \t\t\"customerid\": \"776622\",\n   \t\t\"ip\": \"34.124.233.12\",\n   \t\t\"queryid\": \"45\"\n   \t}\n   \n   \n   \n * 键值对\n   \n   \t2017-07025 17:02:12 level=error message=\"connection refused\"\n   service=\"listener\" thread=125 customerid=776622 ip=34.124.233.12\n   queryid=45\n   \n   \n   \n\n日志的级别\n不同的日志框架对日志的分类略有差异，通常来说，日志可以被分为以下六个级别，通过配置来输出对应级别的日志\n\n * FATAL * 导致程序提前结束的严重错误。\n   \n   \n * ERROR * 运行时异常以及预期之外的错误。\n   \n   \n * WARN * 预期之外的运行时状况，不一定是错误的情况。\n   \n   \n * INFO * 运行时产生的事件。\n   \n   \n * DEBUG * 与程序运行时的流程相关的详细信息。\n   \n   \n * TRACE * 更加具体的详细信息。\n   \n   \n\n日志归档\n根据天数或者文件大小产生新的文件，对日志进行滚动归档，压缩保存。\n\n日志的性能\n记录日志是软件开发必不可少的环节，必须考虑日志的性能带来的问题，举两个例子：\n\n * 使用占位符而不是字符串连接\n\nlogger.debug(\"Entry number: \" + i + \" is \" +  String.valueOf(entry[i])); \nlogger.debug(\"Entry number: {} is {}\", i, entry[i]);\n\n\n上面两个语句输出的效果是一样的，但是性能却相差两个数量级，在关闭DEBUG日志时，它们的开销就不一样了，主要的影响在于字符串转换和字符串拼接上，无论是否生效，前者都会将变量转换为字符串并进行拼接，而后者则只会在需要时执行这些操作。\n\n * 避免无用的日志 * 无用的日志占用磁盘空间，增加系统IO，影响系统性能\n   \n   \n\n日志框架\n列举一些 Java 程序里常用的日志框架\n\n * Java Util Logger\n   \n    * Jdk 自带的 Logger， 从1.4版本开始就有了，使用起来非常方便，一般用于测试，不支持占位符\n   \n   \n * Log4j\n   \n    * Log4j\n      应该是最常用的日志框架了，其高度可配置，在运行期使用外部的配置文件对其进行配置。它按照优先级别记录日志，并可将日志信息定向输出到各种介质，比如数据库、文件、控制台、Unix\n      Syslog等。\n    * loggers：负责采集日志信息。\n    * appenders：负责将日志信息发布到不同地方。\n    * layouts：负责以各种风格格式化日志信息。\n   \n   \n * Slf4j\n   \n    * Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade\n      API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。\n   \n   \n * Logback\n   \n    * LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。\n    * LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。\n    * logback-core提供了LogBack的核心功能，是另外两个组件的基础。\n    * logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。\n    * logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。\n   \n   \n * ...\n   \n   \n\n最佳实践\n * 定义记录日志的目标 * 记录日志的意义何在，用于数据分析，还是同步数据，或者其他\n   \n   \n * 记录什么内容 * 记录有用的日志内容，考虑提高日志可读性，提高系统性能\n   \n   \n * 使用日志框架 * 日志框架更专业，功能全面，标准化，易配置\n   \n   \n * 标准化日志格式 * 统一日志格式\n   \n   \n * 提供上下文 * 尽可能的提供完整信息，提高可读性，如果记录不完整，对于数据分析、排查错误起不到作用，记日志的意义就不大了\n   \n   \n * 使用日志标识，异常码 * 使用异常码，例如30001代表用户模块，30002代表XX模块，这样在看到日志的时候就可以清楚快速的定位到对应的功能。\n   \n   \n\n参考文献\n * 日志文件wiki [https://zh.wikipedia.org/wiki/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6]\n * 30 best practices for logging at scale\n   [https://www.loggly.com/blog/30-best-practices-logging-scale/]\n * How to Log a Log: Application Logging Best Practices\n   [https://logz.io/blog/logging-best-practices/]\n * Java Best Practices for Smarter Application Logging & Exception Handling\n   [https://stackify.com/java-logging-best-practices/]\n * 10 Best Practices for Log Management and Analytics\n   [https://dzone.com/articles/10-best-practices-for-log-management-and-analytics-1]\n * 程序那些事：日志记录的作用和方法 [https://www.infoq.cn/article/why-and-how-log]\n * 日志的五个级别 [https://www.infoq.cn/article/five-levels-of-logging]\n * 你的Java日志，有没有用这些改进办法？\n   [https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=207451012&idx=1&sn=de9fba4eda0f221363b6d5ae54243416&scene=27#wechat_redirect]\n * Java 日志管理最佳实践\n   [https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/index.html]\n * 日志最佳实践 [http://blog.jobbole.com/56574/]\n * Ultimate log4j Tutorial for Java Logging – Best Practices, Resources and Tips\n   [https://stackify.com/log4j-guide-dotnet-logging/]","feature_image":"__GHOST_URL__/content/images/2021/10/v2-0baa2161ee18982a3184ce4e9dea019c_r.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-08 16:49:20","created_by":"1","updated_at":"2021-11-19 06:49:23","updated_by":"1","published_at":"2018-11-12 16:50:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61607b040af28a00012bf0de","uuid":"d64adfc1-5244-443d-8532-0ae771abfce9","title":"常用的图算法","slug":"chang-yong-de-tu-suan-fa","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 最近做了一些涉及到图的算法题，特此归纳总结一下图的基础、广度优先搜索、深度优先搜索、迪克斯特拉算法以及贝尔曼福德算法。\\n\\n## 什么是图\\n\\n![basic-graph](./basic-graph.png)\\n\\n[图](https://zh.wikipedia.org/wiki/图_(数学))是由节点（node）和边（edge）组成的一种数据结构。上图中，A 和 B 是该图的节点，连接线是图的一条边。\\n\\n图模拟了一组连接，一个节点可能与很多节点直接相连，这些节点称为**邻居节点**，需要注意的是，在上面的图中，A指向B，说明B是A的邻居节点，但B没有指向A，说明A不是B的邻居节点。\\n\\n## 图的分类\\n\\n### 有向图\\n\\n如果给图的每条边都规定一个方向，那么该图就称为有向图，有向图所有的连接关系都是单向的。\\n\\n![directed-graph](./directed-graph.png)\\n\\n### 无向图\\n\\n边没有方向的图称为无向图，无向图其实意味着图的**两个节点彼此指向对方**，其实就是环。\\n\\n![undirected-graph](./undirected-graph.png)\\n\\n### 加权图\\n\\n图的每条边都有关联的数字，这些数字称为**权重**，带权重的图称为**加权图**。\\n\\n![directed-wieghted-graph](./directed-weighted-graph.png)\\n\\n### 非加权图\\n\\n不带权重的图称为非加权图。\\n\\n## 广度优先搜索(Breadth-First-Search)\\n\\n> **广度优先搜索算法**（英语：Breadth-First-Search，缩写为BFS），又译作**宽度优先搜索**，或**横向优先搜索**，是一种[图形搜索算法](https://zh.wikipedia.org/w/index.php?title=圖形搜索演算法&action=edit&redlink=1)。简单的说，BFS是从[根节点](https://zh.wikipedia.org/w/index.php?title=根節點&action=edit&redlink=1)开始，沿着树的宽度遍历树的[节点](https://zh.wikipedia.org/wiki/节点)。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表\\n\\n[广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)解决两类问题：\\n\\n1. 从节点A出发，有没有前往节点B的路径\\n2. 从节点A出发，前往节点B的那条路径最短，或者说哪条路径的段数最少？\\n\\n广度优先搜索中，起点的邻居称为一度关系，其邻居的邻居称为二度关系，搜索顺序是先一度关系，再二度关系，以此类推。在代码实现时，需要使用**双端队列**来保证搜索顺序。\\n\\n广度优先搜索的步骤：\\n\\n1. 创建一个队列，将起点的所有邻居节点压入到队列中；\\n2. 从队列弹出一个节点，检查这个节点是否终点，如果是，则完成搜索；\\n3. 如果该节点不是终点，则将该节点的所有邻居节点压入上述队列中；\\n4. 回到第2步，继续检查；\\n5. 如果队列为空，说明终点不可达，找不到该路径。\\n\\n## 狄克斯特拉算法(Dijkstra)\\n\\n> **戴克斯特拉算法**（英语：Dijkstra's algorithm，又译**迪杰斯特拉算法**）由荷兰计算机科学家[艾兹赫尔·戴克斯特拉](https://zh.wikipedia.org/wiki/艾兹赫尔·戴克斯特拉)在1956年提出。戴克斯特拉算法使用了[广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)解决赋权有向图的单源[最短路径问题](https://zh.wikipedia.org/wiki/最短路径问题)。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个[最短路径树](https://zh.wikipedia.org/wiki/最短路径树)。该算法常用于[路由](https://zh.wikipedia.org/wiki/路由)算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。\\n\\n广度优先搜索可以找到段数最少的路径，但是无法找到**开销**最小的路径，[狄克斯特拉算法](https://zh.wikipedia.org/wiki/戴克斯特拉算法)就是用来解决这类问题的。什么是**开销**，可以理解为总权重，假设从起点出发到节点B需要2小时，那么可以称起点到节点B的**开销**为2。当然，开销也可以是其他的计量单位，例如从起点出发到节点B距离3公里，可以计作起点到节点B的**开销**为3。\\n\\n狄克斯特拉算法的步骤：\\n\\n1. 找出开销最小的节点，即可以在最短的时间内到达的节点；\\n2. 更新该节点的邻居的开销；\\n3. 重复这个过程，直到图中所有的节点都处理完；\\n4. 计算开销最小的路径。\\n\\n注：狄克斯特拉算法仅适用于**有向无环图**\\n\\n## 深度优先搜索(Depth-First-Search)\\n\\n> **深度优先搜索算法**（英语：Depth-First-Search，DFS）是一种用于遍历或搜索[树](https://zh.wikipedia.org/wiki/树_(数据结构))或[图](https://zh.wikipedia.org/wiki/图_(数学))的[算法](https://zh.wikipedia.org/wiki/算法)。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\\n\\n从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。\\n\\n深度优先搜索的步骤：\\n\\n1. 首先将起点放入到队列中；\\n2. 从队列弹出一个节点，并检查它是否为终点，如果是，则完成搜索，返回结果；\\n3. 如果不是终点，则将它某一个没有检查过的邻居节点加入到队列中；\\n4. 回到第2步；\\n5. 如果不存在未检查过的邻居节点，则将其父节点加入队列中，回到第2步；\\n6. 重复第5步；\\n7. 如果队列为空，表示所有的节点都检查过了，完成搜索，返回找不到终点\\n\\n### 参考文献\\n\\n- 《算法图解》\\n- 《算法（第4版）》\\n- [维基百科-图](https://zh.wikipedia.org/wiki/图_(数学))\\n- [维基百科-广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)\\n- [维基百科-戴克斯特拉算法](https://zh.wikipedia.org/wiki/戴克斯特拉算法)\\n- [维基百科-深度优先搜索](https://zh.wikipedia.org/wiki/深度优先搜索)\\n- [wikipedia-Backtracking](https://en.wikipedia.org/wiki/Backtracking)\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>最近做了一些涉及到图的算法题，特此归纳总结一下图的基础、广度优先搜索、深度优先搜索、迪克斯特拉算法以及贝尔曼福德算法。</p>\n</blockquote>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE\">什么是图</h2>\n<p><img src=\"./basic-graph.png\" alt=\"basic-graph\" loading=\"lazy\"></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\">图</a>是由节点（node）和边（edge）组成的一种数据结构。上图中，A 和 B 是该图的节点，连接线是图的一条边。</p>\n<p>图模拟了一组连接，一个节点可能与很多节点直接相连，这些节点称为<strong>邻居节点</strong>，需要注意的是，在上面的图中，A指向B，说明B是A的邻居节点，但B没有指向A，说明A不是B的邻居节点。</p>\n<h2 id=\"%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB\">图的分类</h2>\n<h3 id=\"%E6%9C%89%E5%90%91%E5%9B%BE\">有向图</h3>\n<p>如果给图的每条边都规定一个方向，那么该图就称为有向图，有向图所有的连接关系都是单向的。</p>\n<p><img src=\"./directed-graph.png\" alt=\"directed-graph\" loading=\"lazy\"></p>\n<h3 id=\"%E6%97%A0%E5%90%91%E5%9B%BE\">无向图</h3>\n<p>边没有方向的图称为无向图，无向图其实意味着图的<strong>两个节点彼此指向对方</strong>，其实就是环。</p>\n<p><img src=\"./undirected-graph.png\" alt=\"undirected-graph\" loading=\"lazy\"></p>\n<h3 id=\"%E5%8A%A0%E6%9D%83%E5%9B%BE\">加权图</h3>\n<p>图的每条边都有关联的数字，这些数字称为<strong>权重</strong>，带权重的图称为<strong>加权图</strong>。</p>\n<p><img src=\"./directed-weighted-graph.png\" alt=\"directed-wieghted-graph\" loading=\"lazy\"></p>\n<h3 id=\"%E9%9D%9E%E5%8A%A0%E6%9D%83%E5%9B%BE\">非加权图</h3>\n<p>不带权重的图称为非加权图。</p>\n<h2 id=\"%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2breadth-first-search\">广度优先搜索(Breadth-First-Search)</h2>\n<blockquote>\n<p><strong>广度优先搜索算法</strong>（英语：Breadth-First-Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种<a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1\">图形搜索算法</a>。简单的说，BFS是从<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&amp;action=edit&amp;redlink=1\">根节点</a>开始，沿着树的宽度遍历树的<a href=\"https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9\">节点</a>。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表</p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">广度优先搜索</a>解决两类问题：</p>\n<ol>\n<li>从节点A出发，有没有前往节点B的路径</li>\n<li>从节点A出发，前往节点B的那条路径最短，或者说哪条路径的段数最少？</li>\n</ol>\n<p>广度优先搜索中，起点的邻居称为一度关系，其邻居的邻居称为二度关系，搜索顺序是先一度关系，再二度关系，以此类推。在代码实现时，需要使用<strong>双端队列</strong>来保证搜索顺序。</p>\n<p>广度优先搜索的步骤：</p>\n<ol>\n<li>创建一个队列，将起点的所有邻居节点压入到队列中；</li>\n<li>从队列弹出一个节点，检查这个节点是否终点，如果是，则完成搜索；</li>\n<li>如果该节点不是终点，则将该节点的所有邻居节点压入上述队列中；</li>\n<li>回到第2步，继续检查；</li>\n<li>如果队列为空，说明终点不可达，找不到该路径。</li>\n</ol>\n<h2 id=\"%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95dijkstra\">狄克斯特拉算法(Dijkstra)</h2>\n<blockquote>\n<p><strong>戴克斯特拉算法</strong>（英语：Dijkstra's algorithm，又译<strong>迪杰斯特拉算法</strong>）由荷兰计算机科学家<a href=\"https://zh.wikipedia.org/wiki/%E8%89%BE%E5%85%B9%E8%B5%AB%E5%B0%94%C2%B7%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89\">艾兹赫尔·戴克斯特拉</a>在1956年提出。戴克斯特拉算法使用了<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">广度优先搜索</a>解决赋权有向图的单源<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98\">最短路径问题</a>。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91\">最短路径树</a>。该算法常用于<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1\">路由</a>算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。</p>\n</blockquote>\n<p>广度优先搜索可以找到段数最少的路径，但是无法找到<strong>开销</strong>最小的路径，<a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\">狄克斯特拉算法</a>就是用来解决这类问题的。什么是<strong>开销</strong>，可以理解为总权重，假设从起点出发到节点B需要2小时，那么可以称起点到节点B的<strong>开销</strong>为2。当然，开销也可以是其他的计量单位，例如从起点出发到节点B距离3公里，可以计作起点到节点B的<strong>开销</strong>为3。</p>\n<p>狄克斯特拉算法的步骤：</p>\n<ol>\n<li>找出开销最小的节点，即可以在最短的时间内到达的节点；</li>\n<li>更新该节点的邻居的开销；</li>\n<li>重复这个过程，直到图中所有的节点都处理完；</li>\n<li>计算开销最小的路径。</li>\n</ol>\n<p>注：狄克斯特拉算法仅适用于<strong>有向无环图</strong></p>\n<h2 id=\"%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2depth-first-search\">深度优先搜索(Depth-First-Search)</h2>\n<blockquote>\n<p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\">树</a>或<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\">图</a>的<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95\">算法</a>。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>\n</blockquote>\n<p>从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。</p>\n<p>深度优先搜索的步骤：</p>\n<ol>\n<li>首先将起点放入到队列中；</li>\n<li>从队列弹出一个节点，并检查它是否为终点，如果是，则完成搜索，返回结果；</li>\n<li>如果不是终点，则将它某一个没有检查过的邻居节点加入到队列中；</li>\n<li>回到第2步；</li>\n<li>如果不存在未检查过的邻居节点，则将其父节点加入队列中，回到第2步；</li>\n<li>重复第5步；</li>\n<li>如果队列为空，表示所有的节点都检查过了，完成搜索，返回找不到终点</li>\n</ol>\n<h3 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h3>\n<ul>\n<li>《算法图解》</li>\n<li>《算法（第4版）》</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\">维基百科-图</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">维基百科-广度优先搜索</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\">维基百科-戴克斯特拉算法</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">维基百科-深度优先搜索</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Backtracking\">wikipedia-Backtracking</a></li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"61607b040af28a00012bf0de","plaintext":"> 最近做了一些涉及到图的算法题，特此归纳总结一下图的基础、广度优先搜索、深度优先搜索、迪克斯特拉算法以及贝尔曼福德算法。\n\n\n什么是图\n\n\n图 [https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]\n是由节点（node）和边（edge）组成的一种数据结构。上图中，A 和 B 是该图的节点，连接线是图的一条边。\n\n图模拟了一组连接，一个节点可能与很多节点直接相连，这些节点称为邻居节点\n，需要注意的是，在上面的图中，A指向B，说明B是A的邻居节点，但B没有指向A，说明A不是B的邻居节点。\n\n图的分类\n有向图\n如果给图的每条边都规定一个方向，那么该图就称为有向图，有向图所有的连接关系都是单向的。\n\n\n\n无向图\n边没有方向的图称为无向图，无向图其实意味着图的两个节点彼此指向对方，其实就是环。\n\n\n\n加权图\n图的每条边都有关联的数字，这些数字称为权重，带权重的图称为加权图。\n\n\n\n非加权图\n不带权重的图称为非加权图。\n\n广度优先搜索(Breadth-First-Search)\n> 广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法\n[https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&action=edit&redlink=1]\n。简单的说，BFS是从根节点\n[https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&action=edit&redlink=1]\n开始，沿着树的宽度遍历树的节点 [https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9]\n。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表\n\n\n广度优先搜索\n[https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n解决两类问题：\n\n 1. 从节点A出发，有没有前往节点B的路径\n 2. 从节点A出发，前往节点B的那条路径最短，或者说哪条路径的段数最少？\n\n广度优先搜索中，起点的邻居称为一度关系，其邻居的邻居称为二度关系，搜索顺序是先一度关系，再二度关系，以此类推。在代码实现时，需要使用双端队列来保证搜索顺序。\n\n广度优先搜索的步骤：\n\n 1. 创建一个队列，将起点的所有邻居节点压入到队列中；\n 2. 从队列弹出一个节点，检查这个节点是否终点，如果是，则完成搜索；\n 3. 如果该节点不是终点，则将该节点的所有邻居节点压入上述队列中；\n 4. 回到第2步，继续检查；\n 5. 如果队列为空，说明终点不可达，找不到该路径。\n\n狄克斯特拉算法(Dijkstra)\n> 戴克斯特拉算法（英语：Dijkstra's algorithm，又译迪杰斯特拉算法）由荷兰计算机科学家艾兹赫尔·戴克斯特拉\n[https://zh.wikipedia.org/wiki/%E8%89%BE%E5%85%B9%E8%B5%AB%E5%B0%94%C2%B7%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89]\n在1956年提出。戴克斯特拉算法使用了广度优先搜索\n[https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n解决赋权有向图的单源最短路径问题\n[https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98]\n。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个\n最短路径树\n[https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91]\n。该算法常用于路由 [https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1]\n算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。\n\n\n广度优先搜索可以找到段数最少的路径，但是无法找到开销最小的路径，狄克斯特拉算法\n[https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95]\n就是用来解决这类问题的。什么是开销，可以理解为总权重，假设从起点出发到节点B需要2小时，那么可以称起点到节点B的开销\n为2。当然，开销也可以是其他的计量单位，例如从起点出发到节点B距离3公里，可以计作起点到节点B的开销为3。\n\n狄克斯特拉算法的步骤：\n\n 1. 找出开销最小的节点，即可以在最短的时间内到达的节点；\n 2. 更新该节点的邻居的开销；\n 3. 重复这个过程，直到图中所有的节点都处理完；\n 4. 计算开销最小的路径。\n\n注：狄克斯特拉算法仅适用于有向无环图\n\n深度优先搜索(Depth-First-Search)\n> 深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树\n[https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)]\n或图 [https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]的算法\n[https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95]\n。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n\n从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。\n\n深度优先搜索的步骤：\n\n 1. 首先将起点放入到队列中；\n 2. 从队列弹出一个节点，并检查它是否为终点，如果是，则完成搜索，返回结果；\n 3. 如果不是终点，则将它某一个没有检查过的邻居节点加入到队列中；\n 4. 回到第2步；\n 5. 如果不存在未检查过的邻居节点，则将其父节点加入队列中，回到第2步；\n 6. 重复第5步；\n 7. 如果队列为空，表示所有的节点都检查过了，完成搜索，返回找不到终点\n\n参考文献\n * 《算法图解》\n * 《算法（第4版）》\n * 维基百科-图 [https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]\n * 维基百科-广度优先搜索\n   [https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n * 维基百科-戴克斯特拉算法\n   [https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95]\n * 维基百科-深度优先搜索\n   [https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n * wikipedia-Backtracking [https://en.wikipedia.org/wiki/Backtracking]","feature_image":"__GHOST_URL__/content/images/2021/10/v2-dc1e337068536c7b5b1f400852863b37_1440w.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-08 17:08:20","created_by":"1","updated_at":"2021-10-08 17:11:59","updated_by":"1","published_at":"2019-05-28 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61607f310af28a00012bf105","uuid":"ea33468c-b227-4722-97a0-a7d9ea18c0df","title":"面向切面编程","slug":"mian-xiang-qie-mian-bian-cheng","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> AOP 被认为是对 OOP 的一个强大的补充，有了 AOP，我们可以把之前分散在应用各处的行为放在可重用的模块中，可以有效减少冗余代码，并让我们的类只关注自身的主要功能。\\n\\n\\n## AOP 概述\\n\\n面向切面编程（aspect-oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，而不是分散在多处代码中。这样使我们的服务模块更加简洁，因为它们只包含了主要关注点的代码，而次要的功能或者说辅助的功能被转移到切面中了。\\n\\n![aop1](__GHOST_URL__/content/images/2021/11/aop1.png)\\n\\n上图表示划分为三个服务模块的应用，每个模块提供相应的服务，而且这些模块都需要类似的辅助功能，例如日志、安全、事务等等。我们并不想在各个模块中写重复的日志、安全、事务的代码，那么就可以使用选用切面这个方案，来解决这个问题。\\n\\n## AOP 术语\\n\\n![aop2](__GHOST_URL__/content/images/2021/11/aop2.png)\\n\\n- `advice` - 通知\\n\\n  - > 切面的具体行为，即要切入执行的代码\\n\\n- `pointcut` - 切点\\n\\n  - > 通知被应用的具体位置\\n\\n- `join point` - 连接点\\n\\n  - > 程序运行时，能够应用通知的所有点\\n\\n- `aspect` - 切面\\n\\n  - > 什么时候在什么地方做什么事情，是切点和通知的结合\\n\\n- `target` - 目标对象\\n\\n  - > 被切入功能的目标对象\\n\\n- `introduction` - 引入\\n\\n  - > 将新的方法或属性引入到现有的类中\\n\\n- `weaving` - 织入\\n\\n  - > 把切面应用到目标对象并创建新的代理对象的过程\\n\\n## 代理模式\\n\\n代理模式是使用代理对象完成用户请求，屏蔽用户对真实对象访问的一种设计模式。现实生活中，代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。\\n\\nAOP 就是使用代理模式实现的，其中的代理类就相当于AOP中的切面。\\n\\n![aop3](__GHOST_URL__/content/images/2021/11/aop3.png)\\n\\n### 静态代理\\n\\n之所以称为静态代理，是因为在程序运行前，代理类就已经存在了。\\n\\n**举个例子**\\n\\n一般艺人都需要助理，来帮他跑腿，演出前谈价格，演出后收钱，只有表演的时候艺人才亲自出马。\\n\\n1. 定义一个艺人接口\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * 艺人接口\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public interface Artist {\\n       /**\\n        * 表演\\n        */\\n       void perform();\\n   }\\n   ```\\n\\n2. 定义艺人实现类刘德华\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * 艺人刘德华\\n    *\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class LiuDehua implements Artist {\\n   \\n       private LiuDehua() {\\n       }\\n   \\n       public static LiuDehua getInstance() {\\n           return new LiuDehua();\\n       }\\n   \\n       public void perform() {\\n           System.out.println(\\\"刘德华出场演唱笨小孩...\\\");\\n       }\\n   }\\n   ```\\n\\n3. 编写代理类\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * 艺人助理（代理类）\\n    *\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class ArtistProxy implements Artist {\\n   \\n       private LiuDehua liuDehua;\\n   \\n       private ArtistProxy() {\\n       }\\n   \\n       public ArtistProxy(LiuDehua liuDehua) {\\n           this.liuDehua = liuDehua;\\n       }\\n   \\n   \\n       public void perform() {\\n           System.out.println(\\\"助理出面谈价格，签合同...\\\");\\n           liuDehua.perform();\\n           System.out.println(\\\"助理出面收钱...\\\");\\n       }\\n   }\\n   ```\\n\\n4. 运行`main`方法，将艺人实例传入代理类的构造方法，然后调用代理类的`perform()`\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class StaticProxyDemo {\\n   \\n       public static void main(String[] args) {\\n           LiuDehua liuDehua = LiuDehua.getInstance();\\n           ArtistProxy proxy = new ArtistProxy(liuDehua);\\n           proxy.perform();\\n       }\\n   }\\n   ```\\n\\n5. 运行结果\\n\\n   ```java\\n   助理出面谈价格，签合同...\\n   刘德华出场演唱笨小孩...\\n   助理出面收钱...\\n   \\n   Process finished with exit code 0\\n   ```\\n\\n**静态代理的缺点**\\n\\n假设主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；\\n\\n### 动态代理\\n\\n动态代理是在程序运行时，利用Java反射机制动态的生成代理类的代理模式。\\n\\n#### Jdk动态代理\\n\\n- JDK的动态代理依靠接口实现\\n- 如果类并没有实现接口，则不能使用Jdk的动态代理\\n\\n\\n\\n1. 定义图书服务接口\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   /**\\n    * 图书服务接口\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public interface BookService {\\n       /**\\n        * 新增图书接口\\n        */\\n       void addBook();\\n   }\\n   ```\\n\\n   \\n\\n2. 编写图书服务实现类\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   /**\\n    * 图书服务实现类\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookServiceImpl implements BookService {\\n       @Override\\n       public void addBook() {\\n           System.out.println(\\\"新增图书\\\");\\n       }\\n   }\\n   ```\\n\\n3. 编写InvocationHandler实现类\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   import java.lang.reflect.InvocationHandler;\\n   import java.lang.reflect.Method;\\n   \\n   /**\\n    * JDK 动态代理\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookServiceInvocationHandler implements InvocationHandler {\\n   \\n       private Object target;\\n   \\n   \\n       public BookServiceInvocationHandler(Object target){\\n           this.target = target;\\n       }\\n   \\n       @Override\\n       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\\n           System.out.println(\\\"事务开始\\\");\\n           Object result = method.invoke(target, args);\\n           System.out.println(\\\"事务结束\\\");\\n           return result;\\n       }\\n   }\\t\\n   ```\\n\\n4. 运行测试程序\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   import java.lang.reflect.Proxy;\\n   \\n   /**\\n    * JDK动态代理演示\\n    *\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class JdkProxyDemo {\\n       public static void main(String[] args) {\\n           BookServiceInvocationHandler invocationHandler = new BookServiceInvocationHandler(new BookServiceImpl());\\n   \\n           // JDK 动态代理只支持接口\\n           BookService bookServiceProxy = (BookService) Proxy.newProxyInstance(\\n                   BookServiceImpl.class.getClassLoader(),\\n                   BookServiceImpl.class.getInterfaces(),\\n                   invocationHandler);\\n   \\n           bookServiceProxy.addBook();\\n       }\\n   }\\n   ```\\n\\n5. 运行结果\\n\\n   ```java\\n   事务开始\\n   新增图书\\n   事务结束\\n   \\n   Process finished with exit code 0\\n   ```\\n\\n   \\n\\n#### CGLIB动态代理\\n\\nJDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这时就要使用cglib动态代理了。使用cglib需要依赖`cglib`的jar，使用maven为例\\n\\n```xml\\n<dependency>\\n  <groupId>cglib</groupId>\\n  <artifactId>cglib-nodep</artifactId>\\n  <version>3.2.4</version>\\n</dependency>\\n```\\n\\n1. 定义图书服务类\\n\\n   ```java\\n   package org.nocoder.proxy.cglibproxy;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookService {\\n       public void addBook() {\\n           System.out.println(\\\"新增图书\\\");\\n       }\\n   }\\n   ```\\n\\n   \\n\\n2. 编写MethodInterceptor实现类\\n\\n   ```java\\n   package org.nocoder.proxy.cglibproxy;\\n   \\n   import net.sf.cglib.proxy.MethodInterceptor;\\n   import net.sf.cglib.proxy.MethodProxy;\\n   import java.lang.reflect.Method;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookServiceMethodInterceptor implements MethodInterceptor {\\n   \\n       @Override\\n       public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\\n           System.out.println(\\\"事务开始\\\");\\n           methodProxy.invokeSuper(o, objects);\\n           System.out.println(\\\"事务结束\\\");\\n           return null;\\n       }\\n   }\\n   ```\\n\\n   \\n\\n3. 运行测试程序\\n\\n   ```java\\n   package org.nocoder.proxy.cglibproxy;\\n   \\n   import net.sf.cglib.proxy.Enhancer;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class CglibProxyDemo {\\n       public static void main(String[] args) {\\n           BookServiceMethodInterceptor cglibInterceptor = new BookServiceMethodInterceptor();\\n           //cglib 强化剂\\n           Enhancer enhancer = new Enhancer();\\n           enhancer.setSuperclass(BookService.class);\\n           // 创建代理对象\\n           enhancer.setCallback(cglibInterceptor);\\n           BookService bookServiceProxy = (BookService)enhancer.create();\\n           bookServiceProxy.addBook();\\n       }\\n   }\\n   ```\\n\\n   \\n\\n4. 运行结果\\n\\n   ```shell\\n   事务开始\\n   新增图书\\n   事务结束\\n   \\n   Process finished with exit code 0\\n   ```\\n\\n## Spring AOP\\n\\nSpring 提供了4中 aop 的支持，基于代理的经典SpringAOP，纯POJO切面，@Aspect注解驱动的切面，注入式AspectJ切面。前三种都是SpringAOP实现的变体，SpringAOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。第四种实际是使用AspectJ的解决方案。提供了SpringAOP所不能支持的许多类型的切点。我们可以借助Spring的依赖注入把bean装配进AspectJ切面中。Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP。\\n\\n#### 使用`@Aspect`创建切面类\\n\\nAudience类使用`@Aspect`注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。\\n\\n![aop4](__GHOST_URL__/content/images/2021/11/aop4.png)\\n\\n![aop5](__GHOST_URL__/content/images/2021/11/aop5.png)\\n\\n#### Advice的5种注解\\n\\n| **注解**        | **通知**                               |\\n| --------------- | :------------------------------------- |\\n| @After          | 通知方法会在目标方法返回或抛异常后调用 |\\n| @AfterReturning | 通知方法会在目标方法返回后调用         |\\n| @AfterThrowing  | 通知方法会在目标方法抛异常后调用       |\\n| @Around         | 通知方法会将目标方法封装起来           |\\n| @Before         | 通知方法会在目标方法调用之前执行       |\\n\\n#### 使用`@Pointcut`声明切点表达式\\n\\n@Pointcut 声明使用频繁的切点表达式后，在通知注解中引用即可\\n\\n![aop6](__GHOST_URL__/content/images/2021/11/aop6.png)\\n\\n## 总结\\n\\n- 面向切面编程是面向对象编程的一个强大的补充\\n- 通过切面可以把分散在应用各处的行为放入可重用的模块中\\n- 通过注解显示的声明在什么地方应用该行为\\n- 有效减少冗余代码，让我们的类关注自身的主要功能\\n- 动态代理模式和静态代理模式\\n- 通过使用@Aspect注解和简单的配置，可以很简单的在Spring中装配advice和pointcut\\n\\n## 参考文献\\n\\n- Spring 实战（第4版）\\n\\n  ![book1](__GHOST_URL__/content/images/2021/11/book1.png)\\n\\n- Head First 设计模式\\n\\n  ![book2](__GHOST_URL__/content/images/2021/11/book2.png)\\n\\n- https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E4%BE%A7%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\\n\\n- https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9\\n\\n- https://juejin.im/post/5b06bf2df265da0de2574ee1\\n\\n- http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821\\n\\n- http://blog.didispace.com/springbootaoplog/\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>AOP 被认为是对 OOP 的一个强大的补充，有了 AOP，我们可以把之前分散在应用各处的行为放在可重用的模块中，可以有效减少冗余代码，并让我们的类只关注自身的主要功能。</p>\n</blockquote>\n<h2 id=\"aop-%E6%A6%82%E8%BF%B0\">AOP 概述</h2>\n<p>面向切面编程（aspect-oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，而不是分散在多处代码中。这样使我们的服务模块更加简洁，因为它们只包含了主要关注点的代码，而次要的功能或者说辅助的功能被转移到切面中了。</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop1.png\" alt=\"aop1\" loading=\"lazy\"></p>\n<p>上图表示划分为三个服务模块的应用，每个模块提供相应的服务，而且这些模块都需要类似的辅助功能，例如日志、安全、事务等等。我们并不想在各个模块中写重复的日志、安全、事务的代码，那么就可以使用选用切面这个方案，来解决这个问题。</p>\n<h2 id=\"aop-%E6%9C%AF%E8%AF%AD\">AOP 术语</h2>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop2.png\" alt=\"aop2\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p><code>advice</code> - 通知</p>\n<ul>\n<li>\n<blockquote>\n<p>切面的具体行为，即要切入执行的代码</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pointcut</code> - 切点</p>\n<ul>\n<li>\n<blockquote>\n<p>通知被应用的具体位置</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>join point</code> - 连接点</p>\n<ul>\n<li>\n<blockquote>\n<p>程序运行时，能够应用通知的所有点</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>aspect</code> - 切面</p>\n<ul>\n<li>\n<blockquote>\n<p>什么时候在什么地方做什么事情，是切点和通知的结合</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>target</code> - 目标对象</p>\n<ul>\n<li>\n<blockquote>\n<p>被切入功能的目标对象</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>introduction</code> - 引入</p>\n<ul>\n<li>\n<blockquote>\n<p>将新的方法或属性引入到现有的类中</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>weaving</code> - 织入</p>\n<ul>\n<li>\n<blockquote>\n<p>把切面应用到目标对象并创建新的代理对象的过程</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\">代理模式</h2>\n<p>代理模式是使用代理对象完成用户请求，屏蔽用户对真实对象访问的一种设计模式。现实生活中，代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。</p>\n<p>AOP 就是使用代理模式实现的，其中的代理类就相当于AOP中的切面。</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop3.png\" alt=\"aop3\" loading=\"lazy\"></p>\n<h3 id=\"%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\">静态代理</h3>\n<p>之所以称为静态代理，是因为在程序运行前，代理类就已经存在了。</p>\n<p><strong>举个例子</strong></p>\n<p>一般艺人都需要助理，来帮他跑腿，演出前谈价格，演出后收钱，只有表演的时候艺人才亲自出马。</p>\n<ol>\n<li>\n<p>定义一个艺人接口</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * 艺人接口\n * @author jason\n * @date 2019/2/14.\n */\npublic interface Artist {\n    /**\n     * 表演\n     */\n    void perform();\n}\n</code></pre>\n</li>\n<li>\n<p>定义艺人实现类刘德华</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * 艺人刘德华\n *\n * @author jason\n * @date 2019/2/14.\n */\npublic class LiuDehua implements Artist {\n\n    private LiuDehua() {\n    }\n\n    public static LiuDehua getInstance() {\n        return new LiuDehua();\n    }\n\n    public void perform() {\n        System.out.println(&quot;刘德华出场演唱笨小孩...&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>编写代理类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * 艺人助理（代理类）\n *\n * @author jason\n * @date 2019/2/14.\n */\npublic class ArtistProxy implements Artist {\n\n    private LiuDehua liuDehua;\n\n    private ArtistProxy() {\n    }\n\n    public ArtistProxy(LiuDehua liuDehua) {\n        this.liuDehua = liuDehua;\n    }\n\n\n    public void perform() {\n        System.out.println(&quot;助理出面谈价格，签合同...&quot;);\n        liuDehua.perform();\n        System.out.println(&quot;助理出面收钱...&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行<code>main</code>方法，将艺人实例传入代理类的构造方法，然后调用代理类的<code>perform()</code></p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class StaticProxyDemo {\n\n    public static void main(String[] args) {\n        LiuDehua liuDehua = LiuDehua.getInstance();\n        ArtistProxy proxy = new ArtistProxy(liuDehua);\n        proxy.perform();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行结果</p>\n<pre><code class=\"language-java\">助理出面谈价格，签合同...\n刘德华出场演唱笨小孩...\n助理出面收钱...\n\nProcess finished with exit code 0\n</code></pre>\n</li>\n</ol>\n<p><strong>静态代理的缺点</strong></p>\n<p>假设主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；</p>\n<h3 id=\"%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">动态代理</h3>\n<p>动态代理是在程序运行时，利用Java反射机制动态的生成代理类的代理模式。</p>\n<h4 id=\"jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">Jdk动态代理</h4>\n<ul>\n<li>JDK的动态代理依靠接口实现</li>\n<li>如果类并没有实现接口，则不能使用Jdk的动态代理</li>\n</ul>\n<ol>\n<li>\n<p>定义图书服务接口</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\n/**\n * 图书服务接口\n * @author jason\n * @date 2019/2/14.\n */\npublic interface BookService {\n    /**\n     * 新增图书接口\n     */\n    void addBook();\n}\n</code></pre>\n</li>\n<li>\n<p>编写图书服务实现类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\n/**\n * 图书服务实现类\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookServiceImpl implements BookService {\n    @Override\n    public void addBook() {\n        System.out.println(&quot;新增图书&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>编写InvocationHandler实现类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n/**\n * JDK 动态代理\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookServiceInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n\n    public BookServiceInvocationHandler(Object target){\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(&quot;事务开始&quot;);\n        Object result = method.invoke(target, args);\n        System.out.println(&quot;事务结束&quot;);\n        return result;\n    }\n}\t\n</code></pre>\n</li>\n<li>\n<p>运行测试程序</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\nimport java.lang.reflect.Proxy;\n\n/**\n * JDK动态代理演示\n *\n * @author jason\n * @date 2019/2/14.\n */\npublic class JdkProxyDemo {\n    public static void main(String[] args) {\n        BookServiceInvocationHandler invocationHandler = new BookServiceInvocationHandler(new BookServiceImpl());\n\n        // JDK 动态代理只支持接口\n        BookService bookServiceProxy = (BookService) Proxy.newProxyInstance(\n                BookServiceImpl.class.getClassLoader(),\n                BookServiceImpl.class.getInterfaces(),\n                invocationHandler);\n\n        bookServiceProxy.addBook();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行结果</p>\n<pre><code class=\"language-java\">事务开始\n新增图书\n事务结束\n\nProcess finished with exit code 0\n</code></pre>\n</li>\n</ol>\n<h4 id=\"cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">CGLIB动态代理</h4>\n<p>JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这时就要使用cglib动态代理了。使用cglib需要依赖<code>cglib</code>的jar，使用maven为例</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;cglib&lt;/groupId&gt;\n  &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;\n  &lt;version&gt;3.2.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol>\n<li>\n<p>定义图书服务类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.cglibproxy;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookService {\n    public void addBook() {\n        System.out.println(&quot;新增图书&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>编写MethodInterceptor实现类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.cglibproxy;\n\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport java.lang.reflect.Method;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookServiceMethodInterceptor implements MethodInterceptor {\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(&quot;事务开始&quot;);\n        methodProxy.invokeSuper(o, objects);\n        System.out.println(&quot;事务结束&quot;);\n        return null;\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行测试程序</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.cglibproxy;\n\nimport net.sf.cglib.proxy.Enhancer;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class CglibProxyDemo {\n    public static void main(String[] args) {\n        BookServiceMethodInterceptor cglibInterceptor = new BookServiceMethodInterceptor();\n        //cglib 强化剂\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(BookService.class);\n        // 创建代理对象\n        enhancer.setCallback(cglibInterceptor);\n        BookService bookServiceProxy = (BookService)enhancer.create();\n        bookServiceProxy.addBook();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行结果</p>\n<pre><code class=\"language-shell\">事务开始\n新增图书\n事务结束\n\nProcess finished with exit code 0\n</code></pre>\n</li>\n</ol>\n<h2 id=\"spring-aop\">Spring AOP</h2>\n<p>Spring 提供了4中 aop 的支持，基于代理的经典SpringAOP，纯POJO切面，@Aspect注解驱动的切面，注入式AspectJ切面。前三种都是SpringAOP实现的变体，SpringAOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。第四种实际是使用AspectJ的解决方案。提供了SpringAOP所不能支持的许多类型的切点。我们可以借助Spring的依赖注入把bean装配进AspectJ切面中。Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP。</p>\n<h4 id=\"%E4%BD%BF%E7%94%A8aspect%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB\">使用<code>@Aspect</code>创建切面类</h4>\n<p>Audience类使用<code>@Aspect</code>注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop4.png\" alt=\"aop4\" loading=\"lazy\"></p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop5.png\" alt=\"aop5\" loading=\"lazy\"></p>\n<h4 id=\"advice%E7%9A%845%E7%A7%8D%E6%B3%A8%E8%A7%A3\">Advice的5种注解</h4>\n<table>\n<thead>\n<tr>\n<th><strong>注解</strong></th>\n<th style=\"text-align:left\"><strong>通知</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@After</td>\n<td style=\"text-align:left\">通知方法会在目标方法返回或抛异常后调用</td>\n</tr>\n<tr>\n<td>@AfterReturning</td>\n<td style=\"text-align:left\">通知方法会在目标方法返回后调用</td>\n</tr>\n<tr>\n<td>@AfterThrowing</td>\n<td style=\"text-align:left\">通知方法会在目标方法抛异常后调用</td>\n</tr>\n<tr>\n<td>@Around</td>\n<td style=\"text-align:left\">通知方法会将目标方法封装起来</td>\n</tr>\n<tr>\n<td>@Before</td>\n<td style=\"text-align:left\">通知方法会在目标方法调用之前执行</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"%E4%BD%BF%E7%94%A8pointcut%E5%A3%B0%E6%98%8E%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F\">使用<code>@Pointcut</code>声明切点表达式</h4>\n<p>@Pointcut 声明使用频繁的切点表达式后，在通知注解中引用即可</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop6.png\" alt=\"aop6\" loading=\"lazy\"></p>\n<h2 id=\"%E6%80%BB%E7%BB%93\">总结</h2>\n<ul>\n<li>面向切面编程是面向对象编程的一个强大的补充</li>\n<li>通过切面可以把分散在应用各处的行为放入可重用的模块中</li>\n<li>通过注解显示的声明在什么地方应用该行为</li>\n<li>有效减少冗余代码，让我们的类关注自身的主要功能</li>\n<li>动态代理模式和静态代理模式</li>\n<li>通过使用@Aspect注解和简单的配置，可以很简单的在Spring中装配advice和pointcut</li>\n</ul>\n<h2 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h2>\n<ul>\n<li>\n<p>Spring 实战（第4版）</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/book1.png\" alt=\"book1\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>Head First 设计模式</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/book2.png\" alt=\"book2\" loading=\"lazy\"></p>\n</li>\n<li>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E4%BE%A7%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\">https://zh.wikipedia.org/wiki/面向侧面的程序设计</a></p>\n</li>\n<li>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9\">https://zh.wikipedia.org/wiki/横切关注点</a></p>\n</li>\n<li>\n<p><a href=\"https://juejin.im/post/5b06bf2df265da0de2574ee1\">https://juejin.im/post/5b06bf2df265da0de2574ee1</a></p>\n</li>\n<li>\n<p><a href=\"http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821\">http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821</a></p>\n</li>\n<li>\n<p><a href=\"http://blog.didispace.com/springbootaoplog/\">http://blog.didispace.com/springbootaoplog/</a></p>\n</li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"61607f310af28a00012bf105","plaintext":"> AOP 被认为是对 OOP 的一个强大的补充，有了\nAOP，我们可以把之前分散在应用各处的行为放在可重用的模块中，可以有效减少冗余代码，并让我们的类只关注自身的主要功能。\n\n\nAOP 概述\n面向切面编程（aspect-oriented\nprogramming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，而不是分散在多处代码中。这样使我们的服务模块更加简洁，因为它们只包含了主要关注点的代码，而次要的功能或者说辅助的功能被转移到切面中了。\n\n\n\n上图表示划分为三个服务模块的应用，每个模块提供相应的服务，而且这些模块都需要类似的辅助功能，例如日志、安全、事务等等。我们并不想在各个模块中写重复的日志、安全、事务的代码，那么就可以使用选用切面这个方案，来解决这个问题。\n\nAOP 术语\n\n\n * advice - 通知\n   \n    * > 切面的具体行为，即要切入执行的代码\n      \n      \n      \n   \n   \n * pointcut - 切点\n   \n    * > 通知被应用的具体位置\n      \n      \n      \n   \n   \n * join point - 连接点\n   \n    * > 程序运行时，能够应用通知的所有点\n      \n      \n      \n   \n   \n * aspect - 切面\n   \n    * > 什么时候在什么地方做什么事情，是切点和通知的结合\n      \n      \n      \n   \n   \n * target - 目标对象\n   \n    * > 被切入功能的目标对象\n      \n      \n      \n   \n   \n * introduction - 引入\n   \n    * > 将新的方法或属性引入到现有的类中\n      \n      \n      \n   \n   \n * weaving - 织入\n   \n    * > 把切面应用到目标对象并创建新的代理对象的过程\n      \n      \n      \n   \n   \n\n代理模式\n代理模式是使用代理对象完成用户请求，屏蔽用户对真实对象访问的一种设计模式。现实生活中，代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。\n\nAOP 就是使用代理模式实现的，其中的代理类就相当于AOP中的切面。\n\n\n\n静态代理\n之所以称为静态代理，是因为在程序运行前，代理类就已经存在了。\n\n举个例子\n\n一般艺人都需要助理，来帮他跑腿，演出前谈价格，演出后收钱，只有表演的时候艺人才亲自出马。\n\n 1. 定义一个艺人接口\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * 艺人接口\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public interface Artist {\n        /**\n         * 表演\n         */\n        void perform();\n    }\n    \n    \n    \n 2. 定义艺人实现类刘德华\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * 艺人刘德华\n     *\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class LiuDehua implements Artist {\n    \n        private LiuDehua() {\n        }\n    \n        public static LiuDehua getInstance() {\n            return new LiuDehua();\n        }\n    \n        public void perform() {\n            System.out.println(\"刘德华出场演唱笨小孩...\");\n        }\n    }\n    \n    \n    \n 3. 编写代理类\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * 艺人助理（代理类）\n     *\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class ArtistProxy implements Artist {\n    \n        private LiuDehua liuDehua;\n    \n        private ArtistProxy() {\n        }\n    \n        public ArtistProxy(LiuDehua liuDehua) {\n            this.liuDehua = liuDehua;\n        }\n    \n    \n        public void perform() {\n            System.out.println(\"助理出面谈价格，签合同...\");\n            liuDehua.perform();\n            System.out.println(\"助理出面收钱...\");\n        }\n    }\n    \n    \n    \n 4. 运行main方法，将艺人实例传入代理类的构造方法，然后调用代理类的perform()\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class StaticProxyDemo {\n    \n        public static void main(String[] args) {\n            LiuDehua liuDehua = LiuDehua.getInstance();\n            ArtistProxy proxy = new ArtistProxy(liuDehua);\n            proxy.perform();\n        }\n    }\n    \n    \n    \n 5. 运行结果\n    \n    助理出面谈价格，签合同...\n    刘德华出场演唱笨小孩...\n    助理出面收钱...\n    \n    Process finished with exit code 0\n    \n    \n    \n\n静态代理的缺点\n\n假设主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；\n\n动态代理\n动态代理是在程序运行时，利用Java反射机制动态的生成代理类的代理模式。\n\nJdk动态代理\n * JDK的动态代理依靠接口实现\n * 如果类并没有实现接口，则不能使用Jdk的动态代理\n\n 1. 定义图书服务接口\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    /**\n     * 图书服务接口\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public interface BookService {\n        /**\n         * 新增图书接口\n         */\n        void addBook();\n    }\n    \n    \n    \n 2. 编写图书服务实现类\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    /**\n     * 图书服务实现类\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookServiceImpl implements BookService {\n        @Override\n        public void addBook() {\n            System.out.println(\"新增图书\");\n        }\n    }\n    \n    \n    \n 3. 编写InvocationHandler实现类\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    import java.lang.reflect.InvocationHandler;\n    import java.lang.reflect.Method;\n    \n    /**\n     * JDK 动态代理\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookServiceInvocationHandler implements InvocationHandler {\n    \n        private Object target;\n    \n    \n        public BookServiceInvocationHandler(Object target){\n            this.target = target;\n        }\n    \n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"事务开始\");\n            Object result = method.invoke(target, args);\n            System.out.println(\"事务结束\");\n            return result;\n        }\n    }\t\n    \n    \n    \n 4. 运行测试程序\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    import java.lang.reflect.Proxy;\n    \n    /**\n     * JDK动态代理演示\n     *\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class JdkProxyDemo {\n        public static void main(String[] args) {\n            BookServiceInvocationHandler invocationHandler = new BookServiceInvocationHandler(new BookServiceImpl());\n    \n            // JDK 动态代理只支持接口\n            BookService bookServiceProxy = (BookService) Proxy.newProxyInstance(\n                    BookServiceImpl.class.getClassLoader(),\n                    BookServiceImpl.class.getInterfaces(),\n                    invocationHandler);\n    \n            bookServiceProxy.addBook();\n        }\n    }\n    \n    \n    \n 5. 运行结果\n    \n    事务开始\n    新增图书\n    事务结束\n    \n    Process finished with exit code 0\n    \n    \n    \n\nCGLIB动态代理\nJDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这时就要使用cglib动态代理了。使用cglib需要依赖cglib\n的jar，使用maven为例\n\n<dependency>\n  <groupId>cglib</groupId>\n  <artifactId>cglib-nodep</artifactId>\n  <version>3.2.4</version>\n</dependency>\n\n\n 1. 定义图书服务类\n    \n    package org.nocoder.proxy.cglibproxy;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookService {\n        public void addBook() {\n            System.out.println(\"新增图书\");\n        }\n    }\n    \n    \n    \n 2. 编写MethodInterceptor实现类\n    \n    package org.nocoder.proxy.cglibproxy;\n    \n    import net.sf.cglib.proxy.MethodInterceptor;\n    import net.sf.cglib.proxy.MethodProxy;\n    import java.lang.reflect.Method;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookServiceMethodInterceptor implements MethodInterceptor {\n    \n        @Override\n        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n            System.out.println(\"事务开始\");\n            methodProxy.invokeSuper(o, objects);\n            System.out.println(\"事务结束\");\n            return null;\n        }\n    }\n    \n    \n    \n 3. 运行测试程序\n    \n    package org.nocoder.proxy.cglibproxy;\n    \n    import net.sf.cglib.proxy.Enhancer;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class CglibProxyDemo {\n        public static void main(String[] args) {\n            BookServiceMethodInterceptor cglibInterceptor = new BookServiceMethodInterceptor();\n            //cglib 强化剂\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(BookService.class);\n            // 创建代理对象\n            enhancer.setCallback(cglibInterceptor);\n            BookService bookServiceProxy = (BookService)enhancer.create();\n            bookServiceProxy.addBook();\n        }\n    }\n    \n    \n    \n 4. 运行结果\n    \n    事务开始\n    新增图书\n    事务结束\n    \n    Process finished with exit code 0\n    \n    \n    \n\nSpring AOP\nSpring 提供了4中 aop\n的支持，基于代理的经典SpringAOP，纯POJO切面，@Aspect注解驱动的切面，注入式AspectJ切面。前三种都是SpringAOP实现的变体，SpringAOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。第四种实际是使用AspectJ的解决方案。提供了SpringAOP所不能支持的许多类型的切点。我们可以借助Spring的依赖注入把bean装配进AspectJ切面中。Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP。\n\n使用@Aspect创建切面类\nAudience类使用@Aspect\n注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。\n\n\n\n\n\nAdvice的5种注解\n注解通知@After通知方法会在目标方法返回或抛异常后调用@AfterReturning通知方法会在目标方法返回后调用@AfterThrowing\n通知方法会在目标方法抛异常后调用@Around通知方法会将目标方法封装起来@Before通知方法会在目标方法调用之前执行使用@Pointcut声明切点表达式\n@Pointcut 声明使用频繁的切点表达式后，在通知注解中引用即可\n\n\n\n总结\n * 面向切面编程是面向对象编程的一个强大的补充\n * 通过切面可以把分散在应用各处的行为放入可重用的模块中\n * 通过注解显示的声明在什么地方应用该行为\n * 有效减少冗余代码，让我们的类关注自身的主要功能\n * 动态代理模式和静态代理模式\n * 通过使用@Aspect注解和简单的配置，可以很简单的在Spring中装配advice和pointcut\n\n参考文献\n * Spring 实战（第4版）\n   \n   \n   \n   \n * Head First 设计模式\n   \n   \n   \n   \n * https://zh.wikipedia.org/wiki/面向侧面的程序设计\n   [https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E4%BE%A7%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1]\n   \n   \n * https://zh.wikipedia.org/wiki/横切关注点\n   [https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9]\n   \n   \n * https://juejin.im/post/5b06bf2df265da0de2574ee1\n   \n   \n * http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821\n   \n   \n * http://blog.didispace.com/springbootaoplog/","feature_image":"__GHOST_URL__/content/images/2021/12/spring-aspect-oriented-programming-by-java.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-08 17:26:09","created_by":"1","updated_at":"2021-12-01 17:13:45","updated_by":"1","published_at":"2019-02-13 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6164fc580af28a00012bf12b","uuid":"e1ce459c-9198-4322-8cc7-b2c7fdd489a8","title":"装饰器模式之真假美猴王","slug":"zhuang-shi-qi-mo-shi-zhi-zhen-jia-mei-hou-wang","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 本文以西游记中的“真假美猴王”为例，一起温习一下装饰器模式的使用场景及具体实现过程。\\n\\n真假美猴王的故事就不讲了，我们的目的是要把一个猴子类包装成孙悟空和六耳猕猴，但是不能改变猴子类本身的结构。\\n\\n简单描述一下装饰过程：\\n\\n- 首先定义一个猴子接口类，猴子具有`introduce()`方法，用于让猴子嗞哩哇啦的说话介绍自己；\\n- 定义一个普通的猴子类，实现猴子接口类，重载`introduce()`方法，介绍一下自己，例如：“我是个会说话的猴子！”；\\n- 定义一个抽象类，实现猴子接口，作为抽象装饰器类，因为要装饰猴子，所以需要有一个接收猴子类的构造方法；\\n- 定义具体的装饰器类，继承抽象装饰器类，实现具体的装饰方法，这里我们需要定义两个具体的装饰器类，一个是孙悟空装饰器，一个是六耳猕猴装饰器，在各自的类里增加展示自己技能的描述方法，例如“我会七十二变”等；\\n\\n过程大概就上面这么几步，接着咱们就开始coding！\\n\\n1、首先是定义一个猴子接口，泛代表各种猴类。`IMonkey.java`\\n\\n```java\\npublic interface IMonkey{\\n    /**\\n     * 猴子自我介绍\\n    /*\\n    void introduce();\\n}\\n```\\n\\n2、定义猴子实现类，表示一个普通的猴子。`Monkey.java`\\n\\n```java\\npublic class Monkey implements IMonkey{\\n    @Override\\n    public void introduce(){\\n        System.out.print(\\\"我是一个会说话的猴子！\\\");\\n    }\\n}\\n```\\n\\n3、定义抽象装饰器类。`AbstractMonkeyDecorator.java`\\n\\n```java\\npublic abstract class AbstractMonkeyDecorator implements IMonkey{\\n    protected IMonkey monkey;\\n    public AbstractMonkeyDecorator(IMonkey monkey){\\n        this.monkey = monkey;\\n    }\\n\\n    @Override\\n    public void introduce(){\\n        monkey.introduce();\\n    }\\n}\\n```\\n\\n4、定义具体的装饰类，用于将普通的猴子包装成孙悟空或六耳猕猴。\\n\\n- 先来一个孙悟空的装饰类`SunWuKongDecorator.java`\\n\\n```java\\npublic class SunWuKongDecorator extends AbstractMonkeyDecorator{\\n    public SunWuKongDecorator(IMonkey monkey){\\n        super(monkey);\\n    }\\n\\n    @Override\\n    public void introduce(){\\n        // 调用monkey自身的方法\\n        monkey.introduce();\\n        // 调用装饰方法\\n        decorate(monkey);\\n    }\\n\\n    private void decorate(IMonkey monkey){\\n        System.out.print(\\\"我是美猴王，我会七十二变！\\\");\\n        System.out.print(\\\"我师傅是大唐高僧！\\\");\\n    }\\n}\\n```\\n\\n- 再来一个六耳猕猴的装饰类`SixEarsMonkeyDecorator.java`\\n\\n```java\\npublic class SixEarsMonkeyDecorator extends AbstractMonkeyDecorator{\\n    public SixEarsMonkeyDecorator(IMonkey monkey){\\n        super(monkey);\\n    }\\n\\n    @Override\\n    public void introduce(){\\n        // 调用monkey自身的方法\\n        monkey.introduce();\\n        // 调用装饰方法\\n        decorate(monkey);\\n    }\\n\\n    // 具体的装饰方法实现逻辑\\n    private void decorate(IMonkey monkey){\\n        System.out.print(\\\"我才是美猴王，我会七十二变！\\\");\\n        System.out.print(\\\"大唐高僧是我师傅！\\\");\\n    }\\n}\\n```\\n\\n5、测试程序\\n\\n```java\\npublic static void main(String[] args){\\n    // 首先看看一个普通的猴子的自我介绍\\n    System.out.print(\\\"使用装饰器前的猴子：\\\");\\n    Monkey monkey = new Monkey();\\n    monkey.introduce();\\n\\n    System.out.println();\\n\\n    // 使用孙悟空装饰器装饰猴子\\n    System.out.print(\\\"使用孙悟空装饰器装饰后的猴子：\\\");\\n    SunWuKongDecorator swkDecorator = new SunWuKongDecorator(new Monkey());\\n    swkDecorator.introduce();\\n\\n    System.out.println();\\n\\n    // 使用六耳猕猴装饰器装饰猴子\\n    System.out.print(\\\"使用六耳猕猴装饰器装饰后的猴子：\\\");\\n    SixEarsMonkeyDecorator semDecorator = new SixEarsMonkeyDecorator(new Monkey());\\n    semDecorator.introduce();\\n}\\n\\n```\\n\\n6、输出结果\\n\\n```java\\n使用装饰器前的猴子：我是一个会说话的猴子！\\n使用孙悟空装饰器装饰后的猴子：我是一个会说话的猴子！我是美猴王，我会七十二变！我师傅是大唐高僧！\\n使用六耳猕猴装饰器装饰后的猴子：我是一个会说话的猴子！我才是美猴王，我会七十二变！大唐高僧是我师傅！\\n```\\n\\n总结：上面的例子中，我们并没有对Monkey类本身进行改造，而是采用装饰器包装的方式为Monkey增加了新的功能，这种方式可以动态的为实体类增加功能，比继承更灵活，且装饰类和被装饰类互不影响，可以各自扩展。\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>本文以西游记中的“真假美猴王”为例，一起温习一下装饰器模式的使用场景及具体实现过程。</p>\n</blockquote>\n<p>真假美猴王的故事就不讲了，我们的目的是要把一个猴子类包装成孙悟空和六耳猕猴，但是不能改变猴子类本身的结构。</p>\n<p>简单描述一下装饰过程：</p>\n<ul>\n<li>首先定义一个猴子接口类，猴子具有<code>introduce()</code>方法，用于让猴子嗞哩哇啦的说话介绍自己；</li>\n<li>定义一个普通的猴子类，实现猴子接口类，重载<code>introduce()</code>方法，介绍一下自己，例如：“我是个会说话的猴子！”；</li>\n<li>定义一个抽象类，实现猴子接口，作为抽象装饰器类，因为要装饰猴子，所以需要有一个接收猴子类的构造方法；</li>\n<li>定义具体的装饰器类，继承抽象装饰器类，实现具体的装饰方法，这里我们需要定义两个具体的装饰器类，一个是孙悟空装饰器，一个是六耳猕猴装饰器，在各自的类里增加展示自己技能的描述方法，例如“我会七十二变”等；</li>\n</ul>\n<p>过程大概就上面这么几步，接着咱们就开始coding！</p>\n<p>1、首先是定义一个猴子接口，泛代表各种猴类。<code>IMonkey.java</code></p>\n<pre><code class=\"language-java\">public interface IMonkey{\n    /**\n     * 猴子自我介绍\n    /*\n    void introduce();\n}\n</code></pre>\n<p>2、定义猴子实现类，表示一个普通的猴子。<code>Monkey.java</code></p>\n<pre><code class=\"language-java\">public class Monkey implements IMonkey{\n    @Override\n    public void introduce(){\n        System.out.print(&quot;我是一个会说话的猴子！&quot;);\n    }\n}\n</code></pre>\n<p>3、定义抽象装饰器类。<code>AbstractMonkeyDecorator.java</code></p>\n<pre><code class=\"language-java\">public abstract class AbstractMonkeyDecorator implements IMonkey{\n    protected IMonkey monkey;\n    public AbstractMonkeyDecorator(IMonkey monkey){\n        this.monkey = monkey;\n    }\n\n    @Override\n    public void introduce(){\n        monkey.introduce();\n    }\n}\n</code></pre>\n<p>4、定义具体的装饰类，用于将普通的猴子包装成孙悟空或六耳猕猴。</p>\n<ul>\n<li>先来一个孙悟空的装饰类<code>SunWuKongDecorator.java</code></li>\n</ul>\n<pre><code class=\"language-java\">public class SunWuKongDecorator extends AbstractMonkeyDecorator{\n    public SunWuKongDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    private void decorate(IMonkey monkey){\n        System.out.print(&quot;我是美猴王，我会七十二变！&quot;);\n        System.out.print(&quot;我师傅是大唐高僧！&quot;);\n    }\n}\n</code></pre>\n<ul>\n<li>再来一个六耳猕猴的装饰类<code>SixEarsMonkeyDecorator.java</code></li>\n</ul>\n<pre><code class=\"language-java\">public class SixEarsMonkeyDecorator extends AbstractMonkeyDecorator{\n    public SixEarsMonkeyDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    // 具体的装饰方法实现逻辑\n    private void decorate(IMonkey monkey){\n        System.out.print(&quot;我才是美猴王，我会七十二变！&quot;);\n        System.out.print(&quot;大唐高僧是我师傅！&quot;);\n    }\n}\n</code></pre>\n<p>5、测试程序</p>\n<pre><code class=\"language-java\">public static void main(String[] args){\n    // 首先看看一个普通的猴子的自我介绍\n    System.out.print(&quot;使用装饰器前的猴子：&quot;);\n    Monkey monkey = new Monkey();\n    monkey.introduce();\n\n    System.out.println();\n\n    // 使用孙悟空装饰器装饰猴子\n    System.out.print(&quot;使用孙悟空装饰器装饰后的猴子：&quot;);\n    SunWuKongDecorator swkDecorator = new SunWuKongDecorator(new Monkey());\n    swkDecorator.introduce();\n\n    System.out.println();\n\n    // 使用六耳猕猴装饰器装饰猴子\n    System.out.print(&quot;使用六耳猕猴装饰器装饰后的猴子：&quot;);\n    SixEarsMonkeyDecorator semDecorator = new SixEarsMonkeyDecorator(new Monkey());\n    semDecorator.introduce();\n}\n\n</code></pre>\n<p>6、输出结果</p>\n<pre><code class=\"language-java\">使用装饰器前的猴子：我是一个会说话的猴子！\n使用孙悟空装饰器装饰后的猴子：我是一个会说话的猴子！我是美猴王，我会七十二变！我师傅是大唐高僧！\n使用六耳猕猴装饰器装饰后的猴子：我是一个会说话的猴子！我才是美猴王，我会七十二变！大唐高僧是我师傅！\n</code></pre>\n<p>总结：上面的例子中，我们并没有对Monkey类本身进行改造，而是采用装饰器包装的方式为Monkey增加了新的功能，这种方式可以动态的为实体类增加功能，比继承更灵活，且装饰类和被装饰类互不影响，可以各自扩展。</p>\n<!--kg-card-end: markdown-->","comment_id":"6164fc580af28a00012bf12b","plaintext":"> 本文以西游记中的“真假美猴王”为例，一起温习一下装饰器模式的使用场景及具体实现过程。\n\n\n真假美猴王的故事就不讲了，我们的目的是要把一个猴子类包装成孙悟空和六耳猕猴，但是不能改变猴子类本身的结构。\n\n简单描述一下装饰过程：\n\n * 首先定义一个猴子接口类，猴子具有introduce()方法，用于让猴子嗞哩哇啦的说话介绍自己；\n * 定义一个普通的猴子类，实现猴子接口类，重载introduce()方法，介绍一下自己，例如：“我是个会说话的猴子！”；\n * 定义一个抽象类，实现猴子接口，作为抽象装饰器类，因为要装饰猴子，所以需要有一个接收猴子类的构造方法；\n * 定义具体的装饰器类，继承抽象装饰器类，实现具体的装饰方法，这里我们需要定义两个具体的装饰器类，一个是孙悟空装饰器，一个是六耳猕猴装饰器，在各自的类里增加展示自己技能的描述方法，例如“我会七十二变”等；\n\n过程大概就上面这么几步，接着咱们就开始coding！\n\n1、首先是定义一个猴子接口，泛代表各种猴类。IMonkey.java\n\npublic interface IMonkey{\n    /**\n     * 猴子自我介绍\n    /*\n    void introduce();\n}\n\n\n2、定义猴子实现类，表示一个普通的猴子。Monkey.java\n\npublic class Monkey implements IMonkey{\n    @Override\n    public void introduce(){\n        System.out.print(\"我是一个会说话的猴子！\");\n    }\n}\n\n\n3、定义抽象装饰器类。AbstractMonkeyDecorator.java\n\npublic abstract class AbstractMonkeyDecorator implements IMonkey{\n    protected IMonkey monkey;\n    public AbstractMonkeyDecorator(IMonkey monkey){\n        this.monkey = monkey;\n    }\n\n    @Override\n    public void introduce(){\n        monkey.introduce();\n    }\n}\n\n\n4、定义具体的装饰类，用于将普通的猴子包装成孙悟空或六耳猕猴。\n\n * 先来一个孙悟空的装饰类SunWuKongDecorator.java\n\npublic class SunWuKongDecorator extends AbstractMonkeyDecorator{\n    public SunWuKongDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    private void decorate(IMonkey monkey){\n        System.out.print(\"我是美猴王，我会七十二变！\");\n        System.out.print(\"我师傅是大唐高僧！\");\n    }\n}\n\n\n * 再来一个六耳猕猴的装饰类SixEarsMonkeyDecorator.java\n\npublic class SixEarsMonkeyDecorator extends AbstractMonkeyDecorator{\n    public SixEarsMonkeyDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    // 具体的装饰方法实现逻辑\n    private void decorate(IMonkey monkey){\n        System.out.print(\"我才是美猴王，我会七十二变！\");\n        System.out.print(\"大唐高僧是我师傅！\");\n    }\n}\n\n\n5、测试程序\n\npublic static void main(String[] args){\n    // 首先看看一个普通的猴子的自我介绍\n    System.out.print(\"使用装饰器前的猴子：\");\n    Monkey monkey = new Monkey();\n    monkey.introduce();\n\n    System.out.println();\n\n    // 使用孙悟空装饰器装饰猴子\n    System.out.print(\"使用孙悟空装饰器装饰后的猴子：\");\n    SunWuKongDecorator swkDecorator = new SunWuKongDecorator(new Monkey());\n    swkDecorator.introduce();\n\n    System.out.println();\n\n    // 使用六耳猕猴装饰器装饰猴子\n    System.out.print(\"使用六耳猕猴装饰器装饰后的猴子：\");\n    SixEarsMonkeyDecorator semDecorator = new SixEarsMonkeyDecorator(new Monkey());\n    semDecorator.introduce();\n}\n\n\n\n6、输出结果\n\n使用装饰器前的猴子：我是一个会说话的猴子！\n使用孙悟空装饰器装饰后的猴子：我是一个会说话的猴子！我是美猴王，我会七十二变！我师傅是大唐高僧！\n使用六耳猕猴装饰器装饰后的猴子：我是一个会说话的猴子！我才是美猴王，我会七十二变！大唐高僧是我师傅！\n\n\n总结：上面的例子中，我们并没有对Monkey类本身进行改造，而是采用装饰器包装的方式为Monkey增加了新的功能，这种方式可以动态的为实体类增加功能，比继承更灵活，且装饰类和被装饰类互不影响，可以各自扩展。","feature_image":"__GHOST_URL__/content/images/2021/12/wukong.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 03:09:12","created_by":"1","updated_at":"2021-12-01 17:19:05","updated_by":"1","published_at":"2018-05-18 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"616562600af28a00012bf137","uuid":"b757d74b-650d-41f8-af2b-377dc81c5183","title":"情绪控制","slug":"qing-xu-kong-zhi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n**引言**\\n这些关于情绪控制的文字，是我对自己冲动行为的一次反省。要做一个宽宏大度的职场人，自我修炼吧。\\n\\n**情绪失控**\\n    终于，今天又没有忍住，由于接受不了一个同事说话的语气，说了一句讽刺的狠话，然后黑着脸摔门离开。过了一会儿他主动过来谈和，我也对我的行为表示了抱歉。可是顿时我感觉自己真的很狭隘，很没有素质，没有控制好自己的情绪，非常可笑。事情已经发生了，只能自己反省不要再这么冲动，这种不成熟的行为很丢脸，一点小事情闹得同事关系不融洽，非常不值。\\n\\n**办公室里没有朋友和敌人，只有同事和合作伙伴**\\n    我个人很不喜欢把自己摆的高高在上、架子很大的人，不想去接近。事与愿违，偏偏会有和这类人一起合作工作的时候，不过，也算是在磨炼自己的冲动脾气吧。就工作来说，过于感性的处理事情是不恰当的，我吃了很多次这种亏。\\n    记得前几年有个关系还算不错的程序员同事跟我开了一个比较过的玩笑，被我恶狠狠的骂了一顿，后来关系近乎决裂，不相往来，当时感觉很解气，后来想想自己确实有点过分了。\\n    在公司，我做不到让所有人都喜欢我，也做不到喜欢所有人。我一个爱“管闲事”的人，属于路见不平一声吼，该出手时就出手的莽夫。看不惯的事情，就想去纠正，不符合规范的作风，我就想提出来。我也不知道这样好不好，因为我也不是打小报告，光明正大的做事情，只想让一切顺利的正常进行。\\n    当然，不可能一切都那么顺利，比如与人沟通，解决不了言语冲突的时候，在没有想到其它好的办法处理时，产生的负面情绪让沟通变得非常不顺畅，甚至气愤离席。\\n\\n**冷静下来**\\n    高中的时候，一位老师说我是勇于认错却屡教不改的人，当然我是不买账的，我自认为我知错就改。现在回想起来，老师说的没错，这是我很大的一个弱点。发生过后我会立即认识到错误，但是前一秒明明还在惹事生非。**冷静下来**，遇事情要三思而后行，稳妥处理。\\n    今天还学了个词叫“钝感”，我认为这也是可以做好情绪控制的一些方法。“钝感”dùn gǎn心理学名词，与“敏感”意思相对，词性相同，两者互为反义词。钝感是人的动作活动反应慢度的标尺，是用来描述人活动速率的。钝感系数越高则对外部反应越迟钝，同时其敏感度也会越低，人的思维只有钝感系数与敏感系数相平衡才更容易保持较为理性的思维，否则反之。\\n钝感虽然有时给人以迟钝，木讷的负面印象，但钝感力却是我们赢得美好生活的手段和智慧。——渡边淳一\\n钝感力的五项铁律：\\n\\n1. 迅速忘却不快之事。\\n2. 认定目标，即使失败仍要继续挑战。\\n3. 坦然面对流言蜚语。\\n4. 对嫉妒讽刺常怀感谢之心。\\n5. 面对表扬，不得寸进尺，不得意忘形。\\n\\n**总结**\\n冷静处事，三思后行，荣辱不惊。\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>引言</strong><br>\n这些关于情绪控制的文字，是我对自己冲动行为的一次反省。要做一个宽宏大度的职场人，自我修炼吧。</p>\n<p><strong>情绪失控</strong><br>\n终于，今天又没有忍住，由于接受不了一个同事说话的语气，说了一句讽刺的狠话，然后黑着脸摔门离开。过了一会儿他主动过来谈和，我也对我的行为表示了抱歉。可是顿时我感觉自己真的很狭隘，很没有素质，没有控制好自己的情绪，非常可笑。事情已经发生了，只能自己反省不要再这么冲动，这种不成熟的行为很丢脸，一点小事情闹得同事关系不融洽，非常不值。</p>\n<p><strong>办公室里没有朋友和敌人，只有同事和合作伙伴</strong><br>\n我个人很不喜欢把自己摆的高高在上、架子很大的人，不想去接近。事与愿违，偏偏会有和这类人一起合作工作的时候，不过，也算是在磨炼自己的冲动脾气吧。就工作来说，过于感性的处理事情是不恰当的，我吃了很多次这种亏。<br>\n记得前几年有个关系还算不错的程序员同事跟我开了一个比较过的玩笑，被我恶狠狠的骂了一顿，后来关系近乎决裂，不相往来，当时感觉很解气，后来想想自己确实有点过分了。<br>\n在公司，我做不到让所有人都喜欢我，也做不到喜欢所有人。我一个爱“管闲事”的人，属于路见不平一声吼，该出手时就出手的莽夫。看不惯的事情，就想去纠正，不符合规范的作风，我就想提出来。我也不知道这样好不好，因为我也不是打小报告，光明正大的做事情，只想让一切顺利的正常进行。<br>\n当然，不可能一切都那么顺利，比如与人沟通，解决不了言语冲突的时候，在没有想到其它好的办法处理时，产生的负面情绪让沟通变得非常不顺畅，甚至气愤离席。</p>\n<p><strong>冷静下来</strong><br>\n高中的时候，一位老师说我是勇于认错却屡教不改的人，当然我是不买账的，我自认为我知错就改。现在回想起来，老师说的没错，这是我很大的一个弱点。发生过后我会立即认识到错误，但是前一秒明明还在惹事生非。<strong>冷静下来</strong>，遇事情要三思而后行，稳妥处理。<br>\n今天还学了个词叫“钝感”，我认为这也是可以做好情绪控制的一些方法。“钝感”dùn gǎn心理学名词，与“敏感”意思相对，词性相同，两者互为反义词。钝感是人的动作活动反应慢度的标尺，是用来描述人活动速率的。钝感系数越高则对外部反应越迟钝，同时其敏感度也会越低，人的思维只有钝感系数与敏感系数相平衡才更容易保持较为理性的思维，否则反之。<br>\n钝感虽然有时给人以迟钝，木讷的负面印象，但钝感力却是我们赢得美好生活的手段和智慧。——渡边淳一<br>\n钝感力的五项铁律：</p>\n<ol>\n<li>迅速忘却不快之事。</li>\n<li>认定目标，即使失败仍要继续挑战。</li>\n<li>坦然面对流言蜚语。</li>\n<li>对嫉妒讽刺常怀感谢之心。</li>\n<li>面对表扬，不得寸进尺，不得意忘形。</li>\n</ol>\n<p><strong>总结</strong><br>\n冷静处事，三思后行，荣辱不惊。</p>\n<!--kg-card-end: markdown-->","comment_id":"616562600af28a00012bf137","plaintext":"引言\n这些关于情绪控制的文字，是我对自己冲动行为的一次反省。要做一个宽宏大度的职场人，自我修炼吧。\n\n情绪失控\n终于，今天又没有忍住，由于接受不了一个同事说话的语气，说了一句讽刺的狠话，然后黑着脸摔门离开。过了一会儿他主动过来谈和，我也对我的行为表示了抱歉。可是顿时我感觉自己真的很狭隘，很没有素质，没有控制好自己的情绪，非常可笑。事情已经发生了，只能自己反省不要再这么冲动，这种不成熟的行为很丢脸，一点小事情闹得同事关系不融洽，非常不值。\n\n办公室里没有朋友和敌人，只有同事和合作伙伴\n我个人很不喜欢把自己摆的高高在上、架子很大的人，不想去接近。事与愿违，偏偏会有和这类人一起合作工作的时候，不过，也算是在磨炼自己的冲动脾气吧。就工作来说，过于感性的处理事情是不恰当的，我吃了很多次这种亏。\n记得前几年有个关系还算不错的程序员同事跟我开了一个比较过的玩笑，被我恶狠狠的骂了一顿，后来关系近乎决裂，不相往来，当时感觉很解气，后来想想自己确实有点过分了。\n在公司，我做不到让所有人都喜欢我，也做不到喜欢所有人。我一个爱“管闲事”的人，属于路见不平一声吼，该出手时就出手的莽夫。看不惯的事情，就想去纠正，不符合规范的作风，我就想提出来。我也不知道这样好不好，因为我也不是打小报告，光明正大的做事情，只想让一切顺利的正常进行。\n当然，不可能一切都那么顺利，比如与人沟通，解决不了言语冲突的时候，在没有想到其它好的办法处理时，产生的负面情绪让沟通变得非常不顺畅，甚至气愤离席。\n\n冷静下来\n高中的时候，一位老师说我是勇于认错却屡教不改的人，当然我是不买账的，我自认为我知错就改。现在回想起来，老师说的没错，这是我很大的一个弱点。发生过后我会立即认识到错误，但是前一秒明明还在惹事生非。\n冷静下来，遇事情要三思而后行，稳妥处理。\n今天还学了个词叫“钝感”，我认为这也是可以做好情绪控制的一些方法。“钝感”dùn\ngǎn心理学名词，与“敏感”意思相对，词性相同，两者互为反义词。钝感是人的动作活动反应慢度的标尺，是用来描述人活动速率的。钝感系数越高则对外部反应越迟钝，同时其敏感度也会越低，人的思维只有钝感系数与敏感系数相平衡才更容易保持较为理性的思维，否则反之。\n钝感虽然有时给人以迟钝，木讷的负面印象，但钝感力却是我们赢得美好生活的手段和智慧。——渡边淳一\n钝感力的五项铁律：\n\n 1. 迅速忘却不快之事。\n 2. 认定目标，即使失败仍要继续挑战。\n 3. 坦然面对流言蜚语。\n 4. 对嫉妒讽刺常怀感谢之心。\n 5. 面对表扬，不得寸进尺，不得意忘形。\n\n总结\n冷静处事，三思后行，荣辱不惊。","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.64f92ad78c2aeee31b47d459b2506988.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:24:32","created_by":"1","updated_at":"2021-10-12 10:29:59","updated_by":"1","published_at":"2018-02-07 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"616564710af28a00012bf14a","uuid":"f67a9d08-db7d-4750-ad0c-c77bc380d128","title":"Spring项目数据库密码加密","slug":"springxiang-mu-shu-ju-ku-mi-ma-jia-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 很多的软件项目都会把数据库的连接信息明文写在properties配置文件里，只要打开了配置文件，就能直接看到数据库的用户名密码等信息，一些项目会要求不能出现明文密码，接下来，简单三步，实现配置文件里的用户名和密码加密。\\n\\n### 一、加密解密工具类\\n\\n我以Base64为例，写个简单的加密和解密工具\\n\\n```java\\npackage org.nocoder.utils;\\n\\nimport org.apache.commons.codec.binary.Base64;\\nimport org.apache.commons.lang3.StringUtils;\\n\\n/**\\n * EncryptUtil\\n * Created by jason on 2017/7/18.\\n */\\npublic class EncryptUtil {\\n\\n    /**\\n     * 加密\\n     * @param value\\n     * @return encode string value\\n     */\\n    public static String encode(String value){\\n        if(StringUtils.isNotBlank(value)){\\n            Base64 base64 = new Base64();\\n            return new String(base64.encode(value.getBytes()));\\n        }\\n        return null;\\n    }\\n\\n    /**\\n     * 解密\\n     * @param value\\n     * @return decode string value\\n     */\\n    public static String decode(String value){\\n        if(StringUtils.isNotBlank(value)){\\n            Base64 base64 = new Base64();\\n            return new String(base64.decode(value.getBytes()));\\n        }\\n        return null;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(EncryptUtil.encode(\\\"test\\\"));\\n        System.out.println(EncryptUtil.decode(\\\"dGVzdA==\\\"));\\n    }\\n}\\n\\n```\\n\\n### 二、通过继承spring配置类并重写处理方法实现解密\\n\\n```java\\npackage org.nocoder.security;\\n\\nimport org.apache.commons.lang3.StringUtils;\\nimport org.nocoder.utils.EncryptUtil;\\nimport org.springframework.beans.BeansException;\\nimport org.springframework.beans.factory.BeanInitializationException;\\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\\n\\nimport java.util.Properties;\\n\\n/**\\n * 通过继承spring配置类并重写处理方法实现密文解密\\n * Created by jason on 2017/7/18.\\n */\\npublic class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer{\\n    @Override\\n    protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) throws BeansException {\\n        try {\\n            String username = props.getProperty(\\\"username\\\");\\n            if(StringUtils.isNotBlank(username)){\\n                props.setProperty(\\\"username\\\", EncryptUtil.decode(username));\\n            }\\n\\n            String password = props.getProperty(\\\"password\\\");\\n            if(StringUtils.isNotBlank(password)){\\n                props.setProperty(\\\"password\\\",EncryptUtil.decode(password));\\n            }\\n            super.processProperties(beanFactory, props);\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new BeanInitializationException(e.getMessage());\\n        }\\n    }\\n}\\n\\n```\\n\\n### 三、修改配置文件\\n\\n1、使用加密工具类对用户名和密码进行加密，修改properties配置文件`config.properties`\\n\\n```java\\ndriver=org.postgresql.Driver\\nurl=jdbc:postgresql://127.0.0.1:5432/freda_db\\nusername=加密后的用户名\\npassword=加密后的密码\\n#定义初始连接数\\ninitialSize=0\\n#定义最大连接数\\nmaxActive=50\\n#定义最大空闲\\nmaxIdle=50\\n#定义最小空闲\\nminIdle=1\\n#定义最长等待时间\\nmaxWait=60000\\n```\\n\\n2、修改`applicationContext.xml`，引入配置文件\\n\\n```java\\n<!-- 引入配置文件，这里的class就是之前写的那个Spring配置类的路径 -->\\n\\t<bean id=\\\"encryptPropertyConfigurer\\\" class=\\\"org.nocoder.security.EncryptPropertyPlaceholderConfigurer\\\">\\n\\t\\t<property name=\\\"locations\\\">\\n\\t\\t\\t<list>\\n\\t\\t\\t\\t<value>classpath:config.properties</value>\\n\\t\\t\\t</list>\\n\\t\\t</property>\\n\\t</bean>\\n```\\n\\nOK了，就这三步，重启服务试试看！\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>很多的软件项目都会把数据库的连接信息明文写在properties配置文件里，只要打开了配置文件，就能直接看到数据库的用户名密码等信息，一些项目会要求不能出现明文密码，接下来，简单三步，实现配置文件里的用户名和密码加密。</p>\n</blockquote>\n<h3 id=\"%E4%B8%80%E3%80%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB\">一、加密解密工具类</h3>\n<p>我以Base64为例，写个简单的加密和解密工具</p>\n<pre><code class=\"language-java\">package org.nocoder.utils;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * EncryptUtil\n * Created by jason on 2017/7/18.\n */\npublic class EncryptUtil {\n\n    /**\n     * 加密\n     * @param value\n     * @return encode string value\n     */\n    public static String encode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.encode(value.getBytes()));\n        }\n        return null;\n    }\n\n    /**\n     * 解密\n     * @param value\n     * @return decode string value\n     */\n    public static String decode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.decode(value.getBytes()));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(EncryptUtil.encode(&quot;test&quot;));\n        System.out.println(EncryptUtil.decode(&quot;dGVzdA==&quot;));\n    }\n}\n\n</code></pre>\n<h3 id=\"%E4%BA%8C%E3%80%81%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BFspring%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%B9%B6%E9%87%8D%E5%86%99%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%A3%E5%AF%86\">二、通过继承spring配置类并重写处理方法实现解密</h3>\n<pre><code class=\"language-java\">package org.nocoder.security;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.nocoder.utils.EncryptUtil;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanInitializationException;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\n\nimport java.util.Properties;\n\n/**\n * 通过继承spring配置类并重写处理方法实现密文解密\n * Created by jason on 2017/7/18.\n */\npublic class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer{\n    @Override\n    protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) throws BeansException {\n        try {\n            String username = props.getProperty(&quot;username&quot;);\n            if(StringUtils.isNotBlank(username)){\n                props.setProperty(&quot;username&quot;, EncryptUtil.decode(username));\n            }\n\n            String password = props.getProperty(&quot;password&quot;);\n            if(StringUtils.isNotBlank(password)){\n                props.setProperty(&quot;password&quot;,EncryptUtil.decode(password));\n            }\n            super.processProperties(beanFactory, props);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new BeanInitializationException(e.getMessage());\n        }\n    }\n}\n\n</code></pre>\n<h3 id=\"%E4%B8%89%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">三、修改配置文件</h3>\n<p>1、使用加密工具类对用户名和密码进行加密，修改properties配置文件<code>config.properties</code></p>\n<pre><code class=\"language-java\">driver=org.postgresql.Driver\nurl=jdbc:postgresql://127.0.0.1:5432/freda_db\nusername=加密后的用户名\npassword=加密后的密码\n#定义初始连接数\ninitialSize=0\n#定义最大连接数\nmaxActive=50\n#定义最大空闲\nmaxIdle=50\n#定义最小空闲\nminIdle=1\n#定义最长等待时间\nmaxWait=60000\n</code></pre>\n<p>2、修改<code>applicationContext.xml</code>，引入配置文件</p>\n<pre><code class=\"language-java\">&lt;!-- 引入配置文件，这里的class就是之前写的那个Spring配置类的路径 --&gt;\n\t&lt;bean id=&quot;encryptPropertyConfigurer&quot; class=&quot;org.nocoder.security.EncryptPropertyPlaceholderConfigurer&quot;&gt;\n\t\t&lt;property name=&quot;locations&quot;&gt;\n\t\t\t&lt;list&gt;\n\t\t\t\t&lt;value&gt;classpath:config.properties&lt;/value&gt;\n\t\t\t&lt;/list&gt;\n\t\t&lt;/property&gt;\n\t&lt;/bean&gt;\n</code></pre>\n<p>OK了，就这三步，重启服务试试看！</p>\n<!--kg-card-end: markdown-->","comment_id":"616564710af28a00012bf14a","plaintext":"> 很多的软件项目都会把数据库的连接信息明文写在properties配置文件里，只要打开了配置文件，就能直接看到数据库的用户名密码等信息，一些项目会要求不能出现明文密码，接下来，简单三步，实现配置文件里的用户名和密码加密。\n\n\n一、加密解密工具类\n我以Base64为例，写个简单的加密和解密工具\n\npackage org.nocoder.utils;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * EncryptUtil\n * Created by jason on 2017/7/18.\n */\npublic class EncryptUtil {\n\n    /**\n     * 加密\n     * @param value\n     * @return encode string value\n     */\n    public static String encode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.encode(value.getBytes()));\n        }\n        return null;\n    }\n\n    /**\n     * 解密\n     * @param value\n     * @return decode string value\n     */\n    public static String decode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.decode(value.getBytes()));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(EncryptUtil.encode(\"test\"));\n        System.out.println(EncryptUtil.decode(\"dGVzdA==\"));\n    }\n}\n\n\n\n二、通过继承spring配置类并重写处理方法实现解密\npackage org.nocoder.security;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.nocoder.utils.EncryptUtil;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanInitializationException;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\n\nimport java.util.Properties;\n\n/**\n * 通过继承spring配置类并重写处理方法实现密文解密\n * Created by jason on 2017/7/18.\n */\npublic class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer{\n    @Override\n    protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) throws BeansException {\n        try {\n            String username = props.getProperty(\"username\");\n            if(StringUtils.isNotBlank(username)){\n                props.setProperty(\"username\", EncryptUtil.decode(username));\n            }\n\n            String password = props.getProperty(\"password\");\n            if(StringUtils.isNotBlank(password)){\n                props.setProperty(\"password\",EncryptUtil.decode(password));\n            }\n            super.processProperties(beanFactory, props);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new BeanInitializationException(e.getMessage());\n        }\n    }\n}\n\n\n\n三、修改配置文件\n1、使用加密工具类对用户名和密码进行加密，修改properties配置文件config.properties\n\ndriver=org.postgresql.Driver\nurl=jdbc:postgresql://127.0.0.1:5432/freda_db\nusername=加密后的用户名\npassword=加密后的密码\n#定义初始连接数\ninitialSize=0\n#定义最大连接数\nmaxActive=50\n#定义最大空闲\nmaxIdle=50\n#定义最小空闲\nminIdle=1\n#定义最长等待时间\nmaxWait=60000\n\n\n2、修改applicationContext.xml，引入配置文件\n\n<!-- 引入配置文件，这里的class就是之前写的那个Spring配置类的路径 -->\n\t<bean id=\"encryptPropertyConfigurer\" class=\"org.nocoder.security.EncryptPropertyPlaceholderConfigurer\">\n\t\t<property name=\"locations\">\n\t\t\t<list>\n\t\t\t\t<value>classpath:config.properties</value>\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\n\nOK了，就这三步，重启服务试试看！","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.8a0485263f149cf31c40f5bfa567ce18.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:33:21","created_by":"1","updated_at":"2021-10-12 10:35:34","updated_by":"1","published_at":"2017-07-17 16:03:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6165652f0af28a00012bf157","uuid":"4221d037-4eb3-49ed-ad44-62c196adfbd2","title":"使用枚举替换常量类","slug":"shi-yong-mei-ju-ti-huan-chang-liang-lei","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 项目中必然会用到常量，我接触过的一些老旧项目，基本都是用常量类或接口类来定义常量。Java1.5以后，JDK中引入了枚举类，清晰又简单。\\n\\n先说说为啥要替换吧。\\n首先，枚举常量更简单\\n第二，枚举有内置方法\\n第三，枚举可以自定义方法\\n\\n看看代码，感受一下。\\n\\n```java\\nClass Season{\\n\\tpublic final static int Spring = 0;\\n\\tpublic final static int Summer = 1;\\n\\tpublic final static int Autumn = 2;\\n\\tpublic final static int Winter = 3;\\n\\t\\n\\tpublic static int getComfortableSeason(){\\n\\t\\tpublic static int getComfortableSeason(){\\n\\t\\t\\treturn Spring;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n下面这个是用枚举来定义常量：\\n\\n```java\\nenum Season{\\n\\tSpring, Summer, Autumn, Winter;\\n\\t\\n\\tpublic static Season getComfortableSeason() {\\n\\t\\treturn Spring;\\n\\t}\\n}\\n```\\n\\n> `Java语言规范` 提倡枚举项全部大写，字母之间用下划线分隔。\\n\\n```java\\npackage org.nocoder.enumeration;\\n\\n/**\\n * 文档状态\\n * Created by jason on 2017/7/14.\\n */\\npublic enum ArchiveStatus {\\n    ALL(0), DRAFT(1), PUBLISHED(2);\\n\\n    private int value;\\n\\n    public int getValue() {\\n        return value;\\n    }\\n\\n    public void setValue(int value) {\\n        this.value = value;\\n    }\\n\\n    ArchiveStatus(int value){\\n        this.value = value;\\n    }\\n}\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>项目中必然会用到常量，我接触过的一些老旧项目，基本都是用常量类或接口类来定义常量。Java1.5以后，JDK中引入了枚举类，清晰又简单。</p>\n</blockquote>\n<p>先说说为啥要替换吧。<br>\n首先，枚举常量更简单<br>\n第二，枚举有内置方法<br>\n第三，枚举可以自定义方法</p>\n<p>看看代码，感受一下。</p>\n<pre><code class=\"language-java\">Class Season{\n\tpublic final static int Spring = 0;\n\tpublic final static int Summer = 1;\n\tpublic final static int Autumn = 2;\n\tpublic final static int Winter = 3;\n\t\n\tpublic static int getComfortableSeason(){\n\t\tpublic static int getComfortableSeason(){\n\t\t\treturn Spring;\n\t\t}\n\t}\n}\n</code></pre>\n<p>下面这个是用枚举来定义常量：</p>\n<pre><code class=\"language-java\">enum Season{\n\tSpring, Summer, Autumn, Winter;\n\t\n\tpublic static Season getComfortableSeason() {\n\t\treturn Spring;\n\t}\n}\n</code></pre>\n<blockquote>\n<p><code>Java语言规范</code> 提倡枚举项全部大写，字母之间用下划线分隔。</p>\n</blockquote>\n<pre><code class=\"language-java\">package org.nocoder.enumeration;\n\n/**\n * 文档状态\n * Created by jason on 2017/7/14.\n */\npublic enum ArchiveStatus {\n    ALL(0), DRAFT(1), PUBLISHED(2);\n\n    private int value;\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    ArchiveStatus(int value){\n        this.value = value;\n    }\n}\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"6165652f0af28a00012bf157","plaintext":"> 项目中必然会用到常量，我接触过的一些老旧项目，基本都是用常量类或接口类来定义常量。Java1.5以后，JDK中引入了枚举类，清晰又简单。\n\n\n先说说为啥要替换吧。\n首先，枚举常量更简单\n第二，枚举有内置方法\n第三，枚举可以自定义方法\n\n看看代码，感受一下。\n\nClass Season{\n\tpublic final static int Spring = 0;\n\tpublic final static int Summer = 1;\n\tpublic final static int Autumn = 2;\n\tpublic final static int Winter = 3;\n\t\n\tpublic static int getComfortableSeason(){\n\t\tpublic static int getComfortableSeason(){\n\t\t\treturn Spring;\n\t\t}\n\t}\n}\n\n\n下面这个是用枚举来定义常量：\n\nenum Season{\n\tSpring, Summer, Autumn, Winter;\n\t\n\tpublic static Season getComfortableSeason() {\n\t\treturn Spring;\n\t}\n}\n\n\n> Java语言规范 提倡枚举项全部大写，字母之间用下划线分隔。\n\n\npackage org.nocoder.enumeration;\n\n/**\n * 文档状态\n * Created by jason on 2017/7/14.\n */\npublic enum ArchiveStatus {\n    ALL(0), DRAFT(1), PUBLISHED(2);\n\n    private int value;\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    ArchiveStatus(int value){\n        this.value = value;\n    }\n}","feature_image":"__GHOST_URL__/content/images/2021/10/5ee9bd921c28d940.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:36:31","created_by":"1","updated_at":"2021-10-12 10:39:12","updated_by":"1","published_at":"2017-07-14 10:36:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"616566140af28a00012bf164","uuid":"920a28e9-deee-4474-b8b5-cec4a8d0d535","title":"十进制和二进制计数法","slug":"decimal-and-binary-notation","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"**10进制计数法**\\n\\n- 平时我们使用的就是10进制计数法，使用的数字有10种，即 `0、1、2、3、4、5、6、7、8、9`\\n\\n- 数位有一定的意义，从右往左分别表示个位、十位、百位、千位...\\n\\n- 引用书中的例子，来分解\\n\\n  ```\\n  2503\\n  ```\\n\\n  这个数\\n\\n  - 2 表示的是 1000 的个数\\n  - 5 表示的是 100 的个数\\n  - 0 表示的是 10 的个数\\n  - 3 表示的是 1 的个数\\n  - 2503 这个数字就是2个1000、5个100、0个10、3个1 累加的结果\\n  - 1000 是 `10*10*10` 即10的3次方，100 是 `10*10` 即10 的2次方\\n  - 2503 又可以表示为 `2*10的3次方 + 5*10的2次方 + 0*10的1次方 + 3*10的0次方`\\n\\n**2进制计数法**\\n\\n- 计算机在处理数据时使用的是2进制计数法，使用的数字有2中，即 `0、1`\\n- 数位的意义是，从右往左分别表示1位、2位、4位、8位、16位....\\n\\n#### 10进制和2进制数的转换\\n\\n[![0到99的10进制和2进制计数](https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png)](https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99的10进制和2进制计数.png)\\n\\n#### 2 进制转换成 10 进制\\n\\n> 直接举例子，把2进制 `1010110` 转换成10进制\\n\\n由于2进制从右往左分别表示1位，2位，4位，8位，16位...\\n\\n| 1    | 0    | 1    | 0    | 1    | 1    | 0    |\\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\\n| 64   | 32   | 16   | 8    | 4    | 2    | 1    |\\n\\n然后把所有的`1`下面的对应的值加起来，即`64+16+4+2=86`\\n\\n#### 10 进制转换成 2 进制\\n\\n**余数短除法**\\n\\n> 活用这个方法可以将所有十进制数字转换成任何进制表达。除数为2是因为我们最终想得到的以2为基数的数（即二进制数值） 。如果最终想得到其他数系的数字，用目标数系的基数代替这个方法里二进制的基数2 就可以了。例如，要得到基数为9的数，就用9来代替2作为除数 。最终的结果就是目标数系的数字表达。\\n\\n**整个计算过程只需要将数字一直除以2**\\n\\n1. 进行除法运算，纪录余数0或1\\n2. 继续用商除以2，一直到商为0\\n3. 写出2进制数字，从最后一个余数开始顺序读，读到最开始的余数\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>10进制计数法</strong></p>\n<ul>\n<li>\n<p>平时我们使用的就是10进制计数法，使用的数字有10种，即 <code>0、1、2、3、4、5、6、7、8、9</code></p>\n</li>\n<li>\n<p>数位有一定的意义，从右往左分别表示个位、十位、百位、千位...</p>\n</li>\n<li>\n<p>引用书中的例子，来分解</p>\n<pre><code>2503\n</code></pre>\n<p>这个数</p>\n<ul>\n<li>2 表示的是 1000 的个数</li>\n<li>5 表示的是 100 的个数</li>\n<li>0 表示的是 10 的个数</li>\n<li>3 表示的是 1 的个数</li>\n<li>2503 这个数字就是2个1000、5个100、0个10、3个1 累加的结果</li>\n<li>1000 是 <code>10*10*10</code> 即10的3次方，100 是 <code>10*10</code> 即10 的2次方</li>\n<li>2503 又可以表示为 <code>2*10的3次方 + 5*10的2次方 + 0*10的1次方 + 3*10的0次方</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>2进制计数法</strong></p>\n<ul>\n<li>计算机在处理数据时使用的是2进制计数法，使用的数字有2中，即 <code>0、1</code></li>\n<li>数位的意义是，从右往左分别表示1位、2位、4位、8位、16位....</li>\n</ul>\n<h4 id=\"10%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2\">10进制和2进制数的转换</h4>\n<p><a href=\"https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png\"><img src=\"https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png\" alt=\"0到99的10进制和2进制计数\" loading=\"lazy\"></a></p>\n<h4 id=\"2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90-10-%E8%BF%9B%E5%88%B6\">2 进制转换成 10 进制</h4>\n<blockquote>\n<p>直接举例子，把2进制 <code>1010110</code> 转换成10进制</p>\n</blockquote>\n<p>由于2进制从右往左分别表示1位，2位，4位，8位，16位...</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>0</th>\n<th>1</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>64</td>\n<td>32</td>\n<td>16</td>\n<td>8</td>\n<td>4</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>然后把所有的<code>1</code>下面的对应的值加起来，即<code>64+16+4+2=86</code></p>\n<h4 id=\"10-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90-2-%E8%BF%9B%E5%88%B6\">10 进制转换成 2 进制</h4>\n<p><strong>余数短除法</strong></p>\n<blockquote>\n<p>活用这个方法可以将所有十进制数字转换成任何进制表达。除数为2是因为我们最终想得到的以2为基数的数（即二进制数值） 。如果最终想得到其他数系的数字，用目标数系的基数代替这个方法里二进制的基数2 就可以了。例如，要得到基数为9的数，就用9来代替2作为除数 。最终的结果就是目标数系的数字表达。</p>\n</blockquote>\n<p><strong>整个计算过程只需要将数字一直除以2</strong></p>\n<ol>\n<li>进行除法运算，纪录余数0或1</li>\n<li>继续用商除以2，一直到商为0</li>\n<li>写出2进制数字，从最后一个余数开始顺序读，读到最开始的余数</li>\n</ol>\n<!--kg-card-end: markdown-->","comment_id":"616566140af28a00012bf164","plaintext":"10进制计数法\n\n * 平时我们使用的就是10进制计数法，使用的数字有10种，即 0、1、2、3、4、5、6、7、8、9\n   \n   \n * 数位有一定的意义，从右往左分别表示个位、十位、百位、千位...\n   \n   \n * 引用书中的例子，来分解\n   \n   2503\n   \n   \n   这个数\n   \n    * 2 表示的是 1000 的个数\n    * 5 表示的是 100 的个数\n    * 0 表示的是 10 的个数\n    * 3 表示的是 1 的个数\n    * 2503 这个数字就是2个1000、5个100、0个10、3个1 累加的结果\n    * 1000 是 10*10*10 即10的3次方，100 是 10*10 即10 的2次方\n    * 2503 又可以表示为 2*10的3次方 + 5*10的2次方 + 0*10的1次方 + 3*10的0次方\n   \n   \n\n2进制计数法\n\n * 计算机在处理数据时使用的是2进制计数法，使用的数字有2中，即 0、1\n * 数位的意义是，从右往左分别表示1位、2位、4位、8位、16位....\n\n10进制和2进制数的转换\n \n[https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png]\n\n2 进制转换成 10 进制\n> 直接举例子，把2进制 1010110 转换成10进制\n\n\n由于2进制从右往左分别表示1位，2位，4位，8位，16位...\n\n10101106432168421然后把所有的1下面的对应的值加起来，即64+16+4+2=86\n\n10 进制转换成 2 进制\n余数短除法\n\n> 活用这个方法可以将所有十进制数字转换成任何进制表达。除数为2是因为我们最终想得到的以2为基数的数（即二进制数值）\n。如果最终想得到其他数系的数字，用目标数系的基数代替这个方法里二进制的基数2 就可以了。例如，要得到基数为9的数，就用9来代替2作为除数\n。最终的结果就是目标数系的数字表达。\n\n\n整个计算过程只需要将数字一直除以2\n\n 1. 进行除法运算，纪录余数0或1\n 2. 继续用商除以2，一直到商为0\n 3. 写出2进制数字，从最后一个余数开始顺序读，读到最开始的余数","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.951e9c79b0f4d6d2f2e1d002ceabbd51.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:40:20","created_by":"1","updated_at":"2021-11-19 16:16:02","updated_by":"1","published_at":"2019-12-21 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6165670a0af28a00012bf171","uuid":"113e1461-5115-432c-b3cb-42b72854fa16","title":"不能改变，那就接受","slug":"bu-neng-gai-bian-na-jiu-jie-shou","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 这篇文章是写给爱抱怨的人的。同时，也是写给自己的。\\n> 停止抱怨吧兄弟，如果可以，你就尝试去改变这个糟糕的现状。\\n\\n办公室里，大街上，火锅店里，电话里...\\n\\n任何地方你都能听到各种抱怨的声音，诸如此类：\\n\\n>“这个傻叉写的什么烂代码，格式化一下都不会嘛”\\n>“出尔反尔啊，本来你不是这么说的啊，这个傻叉，卧槽”\\n>“一会儿让我这么干，一会儿让我那么干，真是搞笑，哎”\\n>“这加班加的，还让不让人活了，真TMD不想干了”\\n>...\\n\\n当然，我也说过此类的话，而且不止一次。\\n\\n那，咱们来说道说道，“抱怨怎么了，有什么不对吗？”\\n\\n或许你认为抱怨是发泄愤怒情绪的一种方式，爆几句粗口，然后转过身，眼不见心不烦，不了了之，但是当你再次遇到相同的情况，可能情绪会更加糟糕，并且可能予以更激进的抱怨。\\n\\n结果呢，问题并没有解决。\\n\\n**什么是抱怨**\\n\\n> 抱怨：表达哀伤、痛苦或者不满。\\n\\n抱怨是人**说**出来的。“抱怨”和“陈述事实”有区别，它们表达的情绪不一样。抱怨的时候会散发负能量，唉声叹气，爆粗口等，如果你身边有这样的人，他可能也会影响到你的情绪或者处事的方式。\\n\\n>抱怨使我们关注问题本身，以至于我们不会去考虑解决问题、改善境遇的方法。\\n\\n不管是对自己、还是对别人抱怨，都产生不了积极的影响，只会让事情变得更糟糕。\\n\\n最近团队新来了2个初级程序员，工作年限都是2年，能力相仿，但是面对公司封装的框架，他们几乎可以说要从零开始学习。我把他们安排在不同的小组，a在A组，b在B组，由于工位紧张，暂时给他们安排的工位离团队比较远。\\na的负责人对他要求很高，认为a工作了两年应当具备一定的技术能力，在a遇到问题、耽误进度的时候，面对着巨大交付压力的A组长，对他发了脾气，“哎，还要我怎么说，不如让我直接做了算了”，“你连这个都不会，那你说怎么办”...a的工作效率越来越低。\\nb的负责人很有耐心的解答着新员工的问题，时而给予表扬，b逐渐能负责更多的模块，也经常跑过来沟通需求，融入团队的速度很快。\\n\\n我不否认他们有性格上的差异，但是仍然能反应一个事实，那就是，负能量会让人更加消极，正能量促使人进步的更快。如果A组长多一些耐心指导，换以表扬鼓励的方式对待a，那么a的表现肯定比现在要出色得多。\\n\\n如果你发现了让你不满的事情，就尝试改善它吧，如果你没有办法改变，那就接受现状。\\n\\n优化一下让你愤怒的烂代码，或者找author谈谈重构，或者提交一个BUG。\\n难吃的饭可以不吃，也可以请老板换一碗，或者我下次不光顾了。\\n赞美一下你的同事、你的家人，他们会更加努力，展现出更好的自己。\\n\\n最后，奉劝一下自己，要少说点脏话。\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>这篇文章是写给爱抱怨的人的。同时，也是写给自己的。<br>\n停止抱怨吧兄弟，如果可以，你就尝试去改变这个糟糕的现状。</p>\n</blockquote>\n<p>办公室里，大街上，火锅店里，电话里...</p>\n<p>任何地方你都能听到各种抱怨的声音，诸如此类：</p>\n<blockquote>\n<p>“这个傻叉写的什么烂代码，格式化一下都不会嘛”<br>\n“出尔反尔啊，本来你不是这么说的啊，这个傻叉，卧槽”<br>\n“一会儿让我这么干，一会儿让我那么干，真是搞笑，哎”<br>\n“这加班加的，还让不让人活了，真TMD不想干了”<br>\n...</p>\n</blockquote>\n<p>当然，我也说过此类的话，而且不止一次。</p>\n<p>那，咱们来说道说道，“抱怨怎么了，有什么不对吗？”</p>\n<p>或许你认为抱怨是发泄愤怒情绪的一种方式，爆几句粗口，然后转过身，眼不见心不烦，不了了之，但是当你再次遇到相同的情况，可能情绪会更加糟糕，并且可能予以更激进的抱怨。</p>\n<p>结果呢，问题并没有解决。</p>\n<p><strong>什么是抱怨</strong></p>\n<blockquote>\n<p>抱怨：表达哀伤、痛苦或者不满。</p>\n</blockquote>\n<p>抱怨是人<strong>说</strong>出来的。“抱怨”和“陈述事实”有区别，它们表达的情绪不一样。抱怨的时候会散发负能量，唉声叹气，爆粗口等，如果你身边有这样的人，他可能也会影响到你的情绪或者处事的方式。</p>\n<blockquote>\n<p>抱怨使我们关注问题本身，以至于我们不会去考虑解决问题、改善境遇的方法。</p>\n</blockquote>\n<p>不管是对自己、还是对别人抱怨，都产生不了积极的影响，只会让事情变得更糟糕。</p>\n<p>最近团队新来了2个初级程序员，工作年限都是2年，能力相仿，但是面对公司封装的框架，他们几乎可以说要从零开始学习。我把他们安排在不同的小组，a在A组，b在B组，由于工位紧张，暂时给他们安排的工位离团队比较远。<br>\na的负责人对他要求很高，认为a工作了两年应当具备一定的技术能力，在a遇到问题、耽误进度的时候，面对着巨大交付压力的A组长，对他发了脾气，“哎，还要我怎么说，不如让我直接做了算了”，“你连这个都不会，那你说怎么办”...a的工作效率越来越低。<br>\nb的负责人很有耐心的解答着新员工的问题，时而给予表扬，b逐渐能负责更多的模块，也经常跑过来沟通需求，融入团队的速度很快。</p>\n<p>我不否认他们有性格上的差异，但是仍然能反应一个事实，那就是，负能量会让人更加消极，正能量促使人进步的更快。如果A组长多一些耐心指导，换以表扬鼓励的方式对待a，那么a的表现肯定比现在要出色得多。</p>\n<p>如果你发现了让你不满的事情，就尝试改善它吧，如果你没有办法改变，那就接受现状。</p>\n<p>优化一下让你愤怒的烂代码，或者找author谈谈重构，或者提交一个BUG。<br>\n难吃的饭可以不吃，也可以请老板换一碗，或者我下次不光顾了。<br>\n赞美一下你的同事、你的家人，他们会更加努力，展现出更好的自己。</p>\n<p>最后，奉劝一下自己，要少说点脏话。</p>\n<!--kg-card-end: markdown-->","comment_id":"6165670a0af28a00012bf171","plaintext":"> 这篇文章是写给爱抱怨的人的。同时，也是写给自己的。\n停止抱怨吧兄弟，如果可以，你就尝试去改变这个糟糕的现状。\n\n\n办公室里，大街上，火锅店里，电话里...\n\n任何地方你都能听到各种抱怨的声音，诸如此类：\n\n> “这个傻叉写的什么烂代码，格式化一下都不会嘛”\n“出尔反尔啊，本来你不是这么说的啊，这个傻叉，卧槽”\n“一会儿让我这么干，一会儿让我那么干，真是搞笑，哎”\n“这加班加的，还让不让人活了，真TMD不想干了”\n...\n\n\n当然，我也说过此类的话，而且不止一次。\n\n那，咱们来说道说道，“抱怨怎么了，有什么不对吗？”\n\n或许你认为抱怨是发泄愤怒情绪的一种方式，爆几句粗口，然后转过身，眼不见心不烦，不了了之，但是当你再次遇到相同的情况，可能情绪会更加糟糕，并且可能予以更激进的抱怨。\n\n结果呢，问题并没有解决。\n\n什么是抱怨\n\n> 抱怨：表达哀伤、痛苦或者不满。\n\n\n抱怨是人说\n出来的。“抱怨”和“陈述事实”有区别，它们表达的情绪不一样。抱怨的时候会散发负能量，唉声叹气，爆粗口等，如果你身边有这样的人，他可能也会影响到你的情绪或者处事的方式。\n\n> 抱怨使我们关注问题本身，以至于我们不会去考虑解决问题、改善境遇的方法。\n\n\n不管是对自己、还是对别人抱怨，都产生不了积极的影响，只会让事情变得更糟糕。\n\n最近团队新来了2个初级程序员，工作年限都是2年，能力相仿，但是面对公司封装的框架，他们几乎可以说要从零开始学习。我把他们安排在不同的小组，a在A组，b在B组，由于工位紧张，暂时给他们安排的工位离团队比较远。\na的负责人对他要求很高，认为a工作了两年应当具备一定的技术能力，在a遇到问题、耽误进度的时候，面对着巨大交付压力的A组长，对他发了脾气，“哎，还要我怎么说，不如让我直接做了算了”，“你连这个都不会，那你说怎么办”...a的工作效率越来越低。\nb的负责人很有耐心的解答着新员工的问题，时而给予表扬，b逐渐能负责更多的模块，也经常跑过来沟通需求，融入团队的速度很快。\n\n我不否认他们有性格上的差异，但是仍然能反应一个事实，那就是，负能量会让人更加消极，正能量促使人进步的更快。如果A组长多一些耐心指导，换以表扬鼓励的方式对待a，那么a的表现肯定比现在要出色得多。\n\n如果你发现了让你不满的事情，就尝试改善它吧，如果你没有办法改变，那就接受现状。\n\n优化一下让你愤怒的烂代码，或者找author谈谈重构，或者提交一个BUG。\n难吃的饭可以不吃，也可以请老板换一碗，或者我下次不光顾了。\n赞美一下你的同事、你的家人，他们会更加努力，展现出更好的自己。\n\n最后，奉劝一下自己，要少说点脏话。","feature_image":"__GHOST_URL__/content/images/2021/10/AN6AliNTzfGfGZ_IIENQHaE8.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:44:26","created_by":"1","updated_at":"2021-10-12 10:45:46","updated_by":"1","published_at":"2017-12-06 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"618eba1c0af28a00012bf1bb","uuid":"ff9ef093-64ce-4ec8-9bdf-998962573c9b","title":"CRUD Application With React and Spring Boot","slug":"crud-application-with-react-and-spring-boot","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> You can clone the project from [github](https://github.com/nocdr/react-springboot-crud).\\n\\n1. generate springboot project from [start.spring.io](https://start.spring.io/).\\n    ![start-spring-io](__GHOST_URL__/content/images/2021/11/start-spring-io.png)\\n2. add dependencies to pom.xml file.\\n    ```xml\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter</artifactId>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n            <scope>test</scope>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>com.h2database</groupId>\\n            <artifactId>h2</artifactId>\\n            <version>1.4.200</version>\\n            <scope>runtime</scope>\\n        </dependency>\\n    </dependencies>\\n    ```\\n3. create the Model, Repository, Controller.\\n4. add some `clients` using postman.\\n    ![postman-create-client](__GHOST_URL__/content/images/2021/11/postman-create-client.png)\\n5. create `react` app in spring boot application base directory, named `frontend`\\n    \\n   ```shell\\n    npx create-react-app frontend\\n    ```\\n   \\n    install bootstrap, react router and reactstrap in the frontend directory.\\n\\n    ```shell\\n    npm install --save bootstrap@5.1 react-cookie@4.1.1 react-router-dom@5.3.0 reactstrap@8.10.0\\n    ```\\n6. run `ReactSpringbootCrudApplication.java` to start the springboot project.\\n7. run `npm start` to start the frontend app.\\n8. visit `http://localhost:3000`, then we can see the demo.\\n\\n   ![clients](__GHOST_URL__/content/images/2021/11/clients.png)\\n\\n   ![client-list-edit-delete](__GHOST_URL__/content/images/2021/11/client-list-edit-delete.png)\\n   \\n> You can clone the project from [github](https://github.com/nocdr/react-springboot-crud).\\n\\nThe end.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>You can clone the project from <a href=\"https://github.com/nocdr/react-springboot-crud\">github</a>.</p>\n</blockquote>\n<ol>\n<li>\n<p>generate springboot project from <a href=\"https://start.spring.io/\">start.spring.io</a>.<br>\n<img src=\"__GHOST_URL__/content/images/2021/11/start-spring-io.png\" alt=\"start-spring-io\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>add dependencies to pom.xml file.</p>\n<pre><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n        &lt;artifactId&gt;h2&lt;/artifactId&gt;\n        &lt;version&gt;1.4.200&lt;/version&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n</li>\n<li>\n<p>create the Model, Repository, Controller.</p>\n</li>\n<li>\n<p>add some <code>clients</code> using postman.<br>\n<img src=\"__GHOST_URL__/content/images/2021/11/postman-create-client.png\" alt=\"postman-create-client\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>create <code>react</code> app in spring boot application base directory, named <code>frontend</code></p>\n<pre><code class=\"language-shell\"> npx create-react-app frontend\n</code></pre>\n<p>install bootstrap, react router and reactstrap in the frontend directory.</p>\n<pre><code class=\"language-shell\">npm install --save bootstrap@5.1 react-cookie@4.1.1 react-router-dom@5.3.0 reactstrap@8.10.0\n</code></pre>\n</li>\n<li>\n<p>run <code>ReactSpringbootCrudApplication.java</code> to start the springboot project.</p>\n</li>\n<li>\n<p>run <code>npm start</code> to start the frontend app.</p>\n</li>\n<li>\n<p>visit <code>http://localhost:3000</code>, then we can see the demo.</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/clients.png\" alt=\"clients\" loading=\"lazy\"></p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/client-list-edit-delete.png\" alt=\"client-list-edit-delete\" loading=\"lazy\"></p>\n</li>\n</ol>\n<blockquote>\n<p>You can clone the project from <a href=\"https://github.com/nocdr/react-springboot-crud\">github</a>.</p>\n</blockquote>\n<p>The end.</p>\n<!--kg-card-end: markdown-->","comment_id":"618eba1c0af28a00012bf1bb","plaintext":"> You can clone the project from github\n[https://github.com/nocdr/react-springboot-crud].\n\n\n 1. generate springboot project from start.spring.io [https://start.spring.io/].\n    \n    \n    \n 2. add dependencies to pom.xml file.\n    \n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n    \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n    \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n    \n        <dependency>\n            <groupId>com.h2database</groupId>\n            <artifactId>h2</artifactId>\n            <version>1.4.200</version>\n            <scope>runtime</scope>\n        </dependency>\n    </dependencies>\n    \n    \n    \n 3. create the Model, Repository, Controller.\n    \n    \n 4. add some clients using postman.\n    \n    \n    \n 5. create react app in spring boot application base directory, named frontend\n    \n     npx create-react-app frontend\n    \n    \n    install bootstrap, react router and reactstrap in the frontend directory.\n    \n    npm install --save bootstrap@5.1 react-cookie@4.1.1 react-router-dom@5.3.0 reactstrap@8.10.0\n    \n    \n    \n 6. run ReactSpringbootCrudApplication.java to start the springboot project.\n    \n    \n 7. run npm start to start the frontend app.\n    \n    \n 8. visit http://localhost:3000, then we can see the demo.\n    \n    \n    \n    \n    \n    \n\n> You can clone the project from github\n[https://github.com/nocdr/react-springboot-crud].\n\n\nThe end.","feature_image":"__GHOST_URL__/content/images/2021/11/spring-react.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-12 19:01:48","created_by":"1","updated_at":"2021-11-19 02:26:09","updated_by":"1","published_at":"2021-11-12 19:09:47","published_by":"1","custom_excerpt":"Implement a CRUD application with react and spring-boot.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6196fc3a0af28a00012bf1fc","uuid":"f3d7f923-43d2-4e77-a9f0-ffde43c306ab","title":"十二要素（The Twelve Factors）","slug":"shi-er-yao-su-the-twelve-factors","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"strong\"],[\"a\",[\"href\",\"https://www.12factor.net/\"]]],\"sections\":[[1,\"blockquote\",[[0,[],0,\"十二要素（The Twelve Factors）是由 Heroku 团队提出的云应用设计理念，是构建 SaaS 应用的一套方法论，特别关注应用程序随时间的推移而有机增长的动态性，开发者之间的有效代码协作，以及避免软件腐蚀。\"]]],[1,\"p\",[[0,[],0,\"十二个要素分别为：\"]]],[3,\"ol\",[[[0,[0],1,\"基准代码\"],[0,[],0,\"：同一套基准代码可以重用到多次部署中，共享的是代码，不同的仅是配置；\"]],[[0,[0],1,\"依赖\"],[0,[],0,\"：显式声明第三方依赖；\"]],[[0,[0],1,\"配置\"],[0,[],0,\"：将配置存储到环境变量；\"]],[[0,[0],1,\"后端服务\"],[0,[],0,\"：将后端服务作为松耦合的资源；\"]],[[0,[0],1,\"构建、发布、运行\"],[0,[],0,\"：严格区分应用的非运行时状态和运行时状态；\"]],[[0,[0],1,\"进程\"],[0,[],0,\"：将应用作为无状态的进程运行；\"]],[[0,[0],1,\"端口绑定\"],[0,[],0,\"：通过端口绑定对外发布服务，使用内嵌式web服务器或Spring Boot；\"]],[[0,[0],1,\"并发\"],[0,[],0,\"：能够通过水平伸缩应用程序进程来实现并发；\"]],[[0,[0],1,\"快速启动和优雅关闭\"],[0,[],0,\"：快速启动是为了在需要的时候，快速提供服务；优雅关闭是为了保证应用逻辑的完整性，将该完成的任务处理完再释放资源；\"]],[[0,[0],1,\"开发与生产环境等价\"],[0,[],0,\"：尽可能保证开发于生产环境的相似性；\"]],[[0,[0],1,\"日志\"],[0,[],0,\"：使用事件流处理日志，使用Flume、Filebeat等日志收集工具，将日志发送至Elasticsearch，用于排错和分析；\"]],[[0,[0],1,\"管理进程\"],[0,[],0,\"：把后台管理任务作为一次性的进程运行；\"]]]],[1,\"p\",[[0,[],0,\"详细信息建议到官网学习：\"],[0,[1],1,\"https://www.12factor.net/\"]]]],\"ghostVersion\":\"4.0\"}","html":"<blockquote>十二要素（The Twelve Factors）是由 Heroku 团队提出的云应用设计理念，是构建 SaaS 应用的一套方法论，特别关注应用程序随时间的推移而有机增长的动态性，开发者之间的有效代码协作，以及避免软件腐蚀。</blockquote><p>十二个要素分别为：</p><ol><li><strong>基准代码</strong>：同一套基准代码可以重用到多次部署中，共享的是代码，不同的仅是配置；</li><li><strong>依赖</strong>：显式声明第三方依赖；</li><li><strong>配置</strong>：将配置存储到环境变量；</li><li><strong>后端服务</strong>：将后端服务作为松耦合的资源；</li><li><strong>构建、发布、运行</strong>：严格区分应用的非运行时状态和运行时状态；</li><li><strong>进程</strong>：将应用作为无状态的进程运行；</li><li><strong>端口绑定</strong>：通过端口绑定对外发布服务，使用内嵌式web服务器或Spring Boot；</li><li><strong>并发</strong>：能够通过水平伸缩应用程序进程来实现并发；</li><li><strong>快速启动和优雅关闭</strong>：快速启动是为了在需要的时候，快速提供服务；优雅关闭是为了保证应用逻辑的完整性，将该完成的任务处理完再释放资源；</li><li><strong>开发与生产环境等价</strong>：尽可能保证开发于生产环境的相似性；</li><li><strong>日志</strong>：使用事件流处理日志，使用Flume、Filebeat等日志收集工具，将日志发送至Elasticsearch，用于排错和分析；</li><li><strong>管理进程</strong>：把后台管理任务作为一次性的进程运行；</li></ol><p>详细信息建议到官网学习：<a href=\"https://www.12factor.net/\">https://www.12factor.net/</a></p>","comment_id":"6196fc3a0af28a00012bf1fc","plaintext":"> 十二要素（The Twelve Factors）是由 Heroku 团队提出的云应用设计理念，是构建 SaaS\n应用的一套方法论，特别关注应用程序随时间的推移而有机增长的动态性，开发者之间的有效代码协作，以及避免软件腐蚀。\n十二个要素分别为：\n\n 1.  基准代码：同一套基准代码可以重用到多次部署中，共享的是代码，不同的仅是配置；\n 2.  依赖：显式声明第三方依赖；\n 3.  配置：将配置存储到环境变量；\n 4.  后端服务：将后端服务作为松耦合的资源；\n 5.  构建、发布、运行：严格区分应用的非运行时状态和运行时状态；\n 6.  进程：将应用作为无状态的进程运行；\n 7.  端口绑定：通过端口绑定对外发布服务，使用内嵌式web服务器或Spring Boot；\n 8.  并发：能够通过水平伸缩应用程序进程来实现并发；\n 9.  快速启动和优雅关闭：快速启动是为了在需要的时候，快速提供服务；优雅关闭是为了保证应用逻辑的完整性，将该完成的任务处理完再释放资源；\n 10. 开发与生产环境等价：尽可能保证开发于生产环境的相似性；\n 11. 日志：使用事件流处理日志，使用Flume、Filebeat等日志收集工具，将日志发送至Elasticsearch，用于排错和分析；\n 12. 管理进程：把后台管理任务作为一次性的进程运行；\n\n详细信息建议到官网学习：https://www.12factor.net/","feature_image":"__GHOST_URL__/content/images/2021/12/12-factor-app-principles.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-19 01:22:02","created_by":"1","updated_at":"2021-12-01 17:11:48","updated_by":"1","published_at":"2021-08-04 16:44:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6196ffd50af28a00012bf215","uuid":"0f8c0128-77ce-4e3c-9585-ed8a86ee52c6","title":"Python 另一个经典递归：二分法查找","slug":"python-ling-yi-ge-jing-dian-di-gui-er-fen-fa-cha-zhao","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"先来玩个数字游戏，我从1～100中选一个整数，你来猜中这个数字。\\n\\n如果你运气好的话可能十几次就猜中了，也可能是耐心的提问了我100次后。\\n\\n但其实你只需要提问7次就可以找到答案。\\n\\n举个例子，假设我选的数字是`86`。\\n- 问：这个数是否大于50？\\n答：是\\n- 问：大于75？\\n答：是\\n- 问：大于88？\\n答：否\\n- 问：大于82？\\n答：是\\n- 问：大于86？\\n答：否\\n- 问：大于84？\\n答：是\\n- 问：大于85？\\n答：是\\n\\n最终答案锁定，大于85并且不大于86，即`86`。\\n\\n>连续将满足条件的值等分，直到找到正确答案，这就是二分法。\\n>这个算法的本身就是递归的定义，也可以用递归来实现\\n\\n- 如果上下限相同，那么就是数字所在的位置，返回；\\n- 否则找到两者的中间点，也就是上下限的平均值，查找数字在中间点的左侧还是右侧，然后继续查找数字所在的那半部分\\n\\n下面实现一个二分法查找，返回查找目标数字所在序列的位置，下标。\\n```python\\n#!/usr/bin/python\\n'''\\n二分法查找\\nsequence 查找的序列，范围\\nnumber   查找目标\\nlower    下限\\nupper    上限    \\n'''\\ndef search(sequence, number, lower, upper):\\n\\tif lower == upper:\\n\\t\\tassert number == sequence[upper]\\n\\t\\treturn upper\\n\\telse:\\n\\t\\tmiddle = (lower + upper) // 2 #找到两者的中间点\\n\\t\\tif number > sequence[middle]: \\n\\t\\t\\t#如果在中间点的右侧，就在middle+1 ～ upper的范围内继续找\\n\\t\\t\\treturn search(sequence, number, middle+1, upper)\\n\\t\\telse:\\n\\t\\t\\t#如果在中间点的左侧，就在lower～middle的范围继续找\\n\\t\\t\\treturn search(sequence, number, lower, middle)\\t\\t\\t\\n#初始化一个1～100的列表\\nseq = []\\nfor x in xrange(1,101):\\n\\tseq.append(x)\\nprint search(seq, 86, 0, 100)\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>先来玩个数字游戏，我从1～100中选一个整数，你来猜中这个数字。</p>\n<p>如果你运气好的话可能十几次就猜中了，也可能是耐心的提问了我100次后。</p>\n<p>但其实你只需要提问7次就可以找到答案。</p>\n<p>举个例子，假设我选的数字是<code>86</code>。</p>\n<ul>\n<li>问：这个数是否大于50？<br>\n答：是</li>\n<li>问：大于75？<br>\n答：是</li>\n<li>问：大于88？<br>\n答：否</li>\n<li>问：大于82？<br>\n答：是</li>\n<li>问：大于86？<br>\n答：否</li>\n<li>问：大于84？<br>\n答：是</li>\n<li>问：大于85？<br>\n答：是</li>\n</ul>\n<p>最终答案锁定，大于85并且不大于86，即<code>86</code>。</p>\n<blockquote>\n<p>连续将满足条件的值等分，直到找到正确答案，这就是二分法。<br>\n这个算法的本身就是递归的定义，也可以用递归来实现</p>\n</blockquote>\n<ul>\n<li>如果上下限相同，那么就是数字所在的位置，返回；</li>\n<li>否则找到两者的中间点，也就是上下限的平均值，查找数字在中间点的左侧还是右侧，然后继续查找数字所在的那半部分</li>\n</ul>\n<p>下面实现一个二分法查找，返回查找目标数字所在序列的位置，下标。</p>\n<pre><code class=\"language-python\">#!/usr/bin/python\n'''\n二分法查找\nsequence 查找的序列，范围\nnumber   查找目标\nlower    下限\nupper    上限    \n'''\ndef search(sequence, number, lower, upper):\n\tif lower == upper:\n\t\tassert number == sequence[upper]\n\t\treturn upper\n\telse:\n\t\tmiddle = (lower + upper) // 2 #找到两者的中间点\n\t\tif number &gt; sequence[middle]: \n\t\t\t#如果在中间点的右侧，就在middle+1 ～ upper的范围内继续找\n\t\t\treturn search(sequence, number, middle+1, upper)\n\t\telse:\n\t\t\t#如果在中间点的左侧，就在lower～middle的范围继续找\n\t\t\treturn search(sequence, number, lower, middle)\t\t\t\n#初始化一个1～100的列表\nseq = []\nfor x in xrange(1,101):\n\tseq.append(x)\nprint search(seq, 86, 0, 100)\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"6196ffd50af28a00012bf215","plaintext":"先来玩个数字游戏，我从1～100中选一个整数，你来猜中这个数字。\n\n如果你运气好的话可能十几次就猜中了，也可能是耐心的提问了我100次后。\n\n但其实你只需要提问7次就可以找到答案。\n\n举个例子，假设我选的数字是86。\n\n * 问：这个数是否大于50？\n   答：是\n * 问：大于75？\n   答：是\n * 问：大于88？\n   答：否\n * 问：大于82？\n   答：是\n * 问：大于86？\n   答：否\n * 问：大于84？\n   答：是\n * 问：大于85？\n   答：是\n\n最终答案锁定，大于85并且不大于86，即86。\n\n> 连续将满足条件的值等分，直到找到正确答案，这就是二分法。\n这个算法的本身就是递归的定义，也可以用递归来实现\n\n\n * 如果上下限相同，那么就是数字所在的位置，返回；\n * 否则找到两者的中间点，也就是上下限的平均值，查找数字在中间点的左侧还是右侧，然后继续查找数字所在的那半部分\n\n下面实现一个二分法查找，返回查找目标数字所在序列的位置，下标。\n\n#!/usr/bin/python\n'''\n二分法查找\nsequence 查找的序列，范围\nnumber   查找目标\nlower    下限\nupper    上限    \n'''\ndef search(sequence, number, lower, upper):\n\tif lower == upper:\n\t\tassert number == sequence[upper]\n\t\treturn upper\n\telse:\n\t\tmiddle = (lower + upper) // 2 #找到两者的中间点\n\t\tif number > sequence[middle]: \n\t\t\t#如果在中间点的右侧，就在middle+1 ～ upper的范围内继续找\n\t\t\treturn search(sequence, number, middle+1, upper)\n\t\telse:\n\t\t\t#如果在中间点的左侧，就在lower～middle的范围继续找\n\t\t\treturn search(sequence, number, lower, middle)\t\t\t\n#初始化一个1～100的列表\nseq = []\nfor x in xrange(1,101):\n\tseq.append(x)\nprint search(seq, 86, 0, 100)","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-19 01:37:25","created_by":"1","updated_at":"2021-11-19 01:38:38","updated_by":"1","published_at":"2016-12-11 14:39:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619700590af28a00012bf222","uuid":"e4c43f3e-6976-4321-bbb8-adf0f6cd8f57","title":"Python 两个经典递归：阶乘和幂","slug":"python-liang-ge-jing-dian-di-gui-jie-cheng-he-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"**递归**简单说来就是调用自身的意思。\\n\\n来看一个幽默的定义：\\n\\n> **recursion** *\\\\ri-'k&r-zh&n\\\\\\\\* n : see recursion\\n（递归[名词]：见递归）\\n\\n## 一、计算n的阶乘\\n\\n>`n`的阶乘定义为 `n \\\\* (n-1) \\\\* (n-2) \\\\* ... \\\\* 1`。\\n\\n**使用循环实现**\\n\\n```python\\ndef factorial(n):\\n  result = n\\n  for i in range(1, n):\\n    result *= i #依次与1至n-1的数相乘\\n  return result\\n```\\n\\n> 首先，把数字`n`赋值给`result`，然后`result`依次与`1`～`n-1`的数相乘，最后返回结果。\\n\\n阶乘的数学定义：\\n- 1的阶乘是1；\\n- 大于1的数n的阶乘是n乘n-1的阶乘。\\n\\n**使用递归实现**\\n\\n```python\\ndef factorial(n):\\n  if n == 1:\\n    return 1\\n  else:\\n    return n * factorial(n-1)\\n```\\n## 二、计算幂\\n\\npython的内建函数 `pow(x, n)` 或者 `**` 运算符可以实现幂的计算。`pow(x, n)` 是 `x` 自乘 `n-1`次，例如`pow(2, 3)`是`2`乘以自身两次：`2 * 2 * 2 = 8`。\\n\\n**使用循环实现**\\n\\n```python\\ndef power(x, n):\\n  result = 1\\n  for i in range(n):\\n    result *= x\\n  return result\\n```\\n\\n**使用递归实现**\\n\\n- 对于任意数字`x`来说，`power(x, 0)`是`1`；\\n- 对于任何大于`0`的数来说，`power(x, n)`是`x`乘以`(x, n-1)`的结果。\\n\\n```python\\ndef power(x, n):\\n  if n == 0:\\n    return 1\\n  else:\\n    return x * power(x, n-1)\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>递归</strong>简单说来就是调用自身的意思。</p>\n<p>来看一个幽默的定义：</p>\n<blockquote>\n<p><strong>recursion</strong> <em>\\ri-'k&amp;r-zh&amp;n\\</em> n : see recursion<br>\n（递归[名词]：见递归）</p>\n</blockquote>\n<h2 id=\"%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97n%E7%9A%84%E9%98%B6%E4%B9%98\">一、计算n的阶乘</h2>\n<blockquote>\n<p><code>n</code>的阶乘定义为 <code>n \\* (n-1) \\* (n-2) \\* ... \\* 1</code>。</p>\n</blockquote>\n<p><strong>使用循环实现</strong></p>\n<pre><code class=\"language-python\">def factorial(n):\n  result = n\n  for i in range(1, n):\n    result *= i #依次与1至n-1的数相乘\n  return result\n</code></pre>\n<blockquote>\n<p>首先，把数字<code>n</code>赋值给<code>result</code>，然后<code>result</code>依次与<code>1</code>～<code>n-1</code>的数相乘，最后返回结果。</p>\n</blockquote>\n<p>阶乘的数学定义：</p>\n<ul>\n<li>1的阶乘是1；</li>\n<li>大于1的数n的阶乘是n乘n-1的阶乘。</li>\n</ul>\n<p><strong>使用递归实现</strong></p>\n<pre><code class=\"language-python\">def factorial(n):\n  if n == 1:\n    return 1\n  else:\n    return n * factorial(n-1)\n</code></pre>\n<h2 id=\"%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E5%B9%82\">二、计算幂</h2>\n<p>python的内建函数 <code>pow(x, n)</code> 或者 <code>**</code> 运算符可以实现幂的计算。<code>pow(x, n)</code> 是 <code>x</code> 自乘 <code>n-1</code>次，例如<code>pow(2, 3)</code>是<code>2</code>乘以自身两次：<code>2 * 2 * 2 = 8</code>。</p>\n<p><strong>使用循环实现</strong></p>\n<pre><code class=\"language-python\">def power(x, n):\n  result = 1\n  for i in range(n):\n    result *= x\n  return result\n</code></pre>\n<p><strong>使用递归实现</strong></p>\n<ul>\n<li>对于任意数字<code>x</code>来说，<code>power(x, 0)</code>是<code>1</code>；</li>\n<li>对于任何大于<code>0</code>的数来说，<code>power(x, n)</code>是<code>x</code>乘以<code>(x, n-1)</code>的结果。</li>\n</ul>\n<pre><code class=\"language-python\">def power(x, n):\n  if n == 0:\n    return 1\n  else:\n    return x * power(x, n-1)\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"619700590af28a00012bf222","plaintext":"递归简单说来就是调用自身的意思。\n\n来看一个幽默的定义：\n\n> recursion \\ri-'k&r-zh&n\\ n : see recursion\n（递归[名词]：见递归）\n\n\n一、计算n的阶乘\n> n的阶乘定义为 n \\* (n-1) \\* (n-2) \\* ... \\* 1。\n\n\n使用循环实现\n\ndef factorial(n):\n  result = n\n  for i in range(1, n):\n    result *= i #依次与1至n-1的数相乘\n  return result\n\n\n> 首先，把数字n赋值给result，然后result依次与1～n-1的数相乘，最后返回结果。\n\n\n阶乘的数学定义：\n\n * 1的阶乘是1；\n * 大于1的数n的阶乘是n乘n-1的阶乘。\n\n使用递归实现\n\ndef factorial(n):\n  if n == 1:\n    return 1\n  else:\n    return n * factorial(n-1)\n\n\n二、计算幂\npython的内建函数 pow(x, n) 或者 ** 运算符可以实现幂的计算。pow(x, n) 是 x 自乘 n-1次，例如pow(2, 3)是2\n乘以自身两次：2 * 2 * 2 = 8。\n\n使用循环实现\n\ndef power(x, n):\n  result = 1\n  for i in range(n):\n    result *= x\n  return result\n\n\n使用递归实现\n\n * 对于任意数字x来说，power(x, 0)是1；\n * 对于任何大于0的数来说，power(x, n)是x乘以(x, n-1)的结果。\n\ndef power(x, n):\n  if n == 0:\n    return 1\n  else:\n    return x * power(x, n-1)","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-19 01:39:37","created_by":"1","updated_at":"2021-11-19 01:41:15","updated_by":"1","published_at":"2016-11-06 10:06:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619a6a1ceff3f40001c5e92f","uuid":"67213f41-875e-457c-a00c-999921c4856e","title":"几道Java面试题","slug":"ji-dao-java-mian-shi-ti","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"code\",{\"code\":\"// 非静态成员变量j的属性值会重复利用，不会累加\\n// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\\\"prototype\\\")\\n@Controller\\n@RequestMapping(\\\"/test\\\")\\npublic class IndexController{\\n\\tprivate static int i = 0;\\n\\tprivate int j = 0;\\n\\tpublic String test(){\\n\\t\\tSystem.out.println((i++) + \\\"|\\\" + (j++));\\n\\t\\treturn \\\"test\\\";\\n\\t}\\n}\\n\\n\",\"language\":\"java\"}]],\"markups\":[[\"code\"],[\"a\",[\"href\",\"https://segmentfault.com/a/1190000010107964\"]],[\"a\",[\"href\",\"https://my.oschina.net/chuibilong/blog/638950\"]],[\"a\",[\"href\",\"https://blog.csdn.net/kakaxi_77/article/details/46007239\"]],[\"a\",[\"href\",\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\"]],[\"a\",[\"href\",\"https://blog.csdn.net/xlgen157387/article/details/40071651\"]],[\"strong\"]],\"sections\":[[1,\"h3\",[[0,[],0,\"数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？\"]]],[3,\"ul\",[[[0,[],0,\"检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。\"]]]],[1,\"h3\",[[0,[],0,\"Struts2和SpringMVC的区别？\"]]],[3,\"ul\",[[[0,[],0,\"Struts2入口是\"],[0,[0],1,\"Filter\"],[0,[],0,\"，SpringMVC是\"],[0,[0],1,\"Servlet\"]],[[0,[],0,\"Spring MVC是基于方法的设计，而Struts2是基于类\"]],[[0,[],0,\"Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的\"]],[[0,[],0,\"Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式\"]]]],[1,\"h3\",[[0,[],0,\"Spring MVC的Controller是单例的吗，有什么影响吗？\"]]],[3,\"ul\",[[[0,[],0,\"Spring MVC的controller是单例的\"]],[[0,[],0,\"如果在controller中定义了非静态成员变量，会导致属性重复使用\"]]]],[10,0],[1,\"h3\",[[0,[],0,\"MyBatis如何防止sql注入？\"]]],[1,\"p\",[[0,[],0,\"Mybatis中的\"],[0,[0],1,\"#{}\"],[0,[],0,\"和\"],[0,[0],1,\"${}\"],[0,[],0,\"的区别\"]]],[3,\"ul\",[[[0,[0],1,\"#{}\"],[0,[],0,\"使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by \\\"111\\\", 如果传入的值是id，则解析成的sql为order by \\\"id\\\"\"]],[[0,[0],1,\"${}\"],[0,[],0,\"将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id\"]],[[0,[0],1,\"#{}\"],[0,[],0,\"方式能够很大程度防止sql注入\"]],[[0,[0],1,\"${}\"],[0,[],0,\"方式无法防止Sql注入\"]],[[0,[0],1,\"${}\"],[0,[],0,\"方式一般用于传入数据库对象，例如传入表名\"]],[[0,[],0,\"尽量使用\"],[0,[0],1,\"#{}\"],[0,[],0,\"代替\"],[0,[0],1,\"${}\"]],[[0,[],0,\"参考文献\"]],[[0,[1],1,\"https://segmentfault.com/a/1190000010107964\"]],[[0,[2],1,\"https://my.oschina.net/chuibilong/blog/638950\"]],[[0,[3],1,\"https://blog.csdn.net/kakaxi_77/article/details/46007239\"]]]],[1,\"h3\",[[0,[],0,\"Hibernate一级缓存、二级缓存？\"]]],[1,\"p\",[[0,[],0,\"一级缓存\"]]],[3,\"ul\",[[[0,[],0,\"第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session 对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。\"]],[[0,[],0,\"如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭 session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。\"]]]],[1,\"p\",[[0,[],0,\"二级缓存\"]]],[3,\"ul\",[[[0,[],0,\"第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。\"]],[[0,[],0,\"第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。\"]],[[0,[],0,\"任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给 Hibernate 提供一个缓存实现的解决方法。\"]]]],[1,\"p\",[[0,[],0,\"参考文献\"]]],[3,\"ul\",[[[0,[4],1,\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\"]],[[0,[5],1,\"https://blog.csdn.net/xlgen157387/article/details/40071651\"]]]],[1,\"h3\",[[0,[],0,\"使用过哪些socket框架？\"]]],[1,\"h2\",[[0,[],0,\"延伸\"]]],[1,\"h3\",[[0,[],0,\"Spring MVC 请求-响应流程\"]]],[3,\"ul\",[[[0,[],0,\"1.浏览器发送请求的url以及其他信息\"]],[[0,[],0,\"2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。\"]],[[0,[],0,\"3.确定合适的控制器后，将请求发送给选中的控制器\"]],[[0,[],0,\"4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet\"]],[[0,[],0,\"5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）\"]],[[0,[],0,\"6.DispatcherServlet匹配到对应的视图实现\"]],[[0,[],0,\"7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端\"]]]],[1,\"h3\",[[0,[],0,\"struts2 工作流程\"]]],[1,\"h3\",[[0,[],0,\"http协议无状态\"]]],[1,\"p\",[[0,[],0,\"对\"],[0,[6],1,\"无状态\"],[0,[],0,\"的理解\"]]],[3,\"ul\",[[[0,[],0,\"协议对于事务处理没有记忆能力\"]],[[0,[],0,\"对同一个url请求没有上下文关系\"]],[[0,[],0,\"每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况\"]],[[0,[],0,\"服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器\"]],[[0,[],0,\"人生若只如初见\"]]]],[1,\"p\",[[0,[6],1,\"状态\"],[0,[],0,\"的含义：客户端和服务器在某次会话中产生的数据。\"]]],[1,\"p\",[[0,[6],1,\"无状态\"],[0,[],0,\"就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。\"]]],[1,\"p\",[[0,[],0,\"在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。\"]]],[1,\"p\",[[0,[],0,\"知乎上有个哥们儿举的一个例子：\"]]],[1,\"blockquote\",[[0,[6],1,\"有状态：\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的啥？\"]]],[1,\"blockquote\",[[0,[],0,\"B：吃的大盘鸡。\"]]],[1,\"blockquote\",[[0,[],0,\"A：味道怎么样呀？\"]]],[1,\"blockquote\",[[0,[],0,\"B：还不错，挺好吃的。\"]]],[1,\"blockquote\",[[0,[6],1,\"无状态：\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的啥？\"]]],[1,\"blockquote\",[[0,[],0,\"B：吃的大盘鸡。\"]]],[1,\"blockquote\",[[0,[],0,\"A：味道怎么样呀？\"]]],[1,\"blockquote\",[[0,[],0,\"B：？？？啊？啥？啥味道怎么样？\"]]],[1,\"blockquote\",[[0,[],0,\"所以需要cookie这种东西：\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的啥？\"]]],[1,\"blockquote\",[[0,[],0,\"B：吃的大盘鸡。\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的大盘鸡味道怎么样呀？\"]]],[1,\"blockquote\",[[0,[],0,\"B：还不错，挺好吃的。\"]]]],\"ghostVersion\":\"4.0\"}","html":"<h3 id=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A0%81%E4%B8%80%E8%87%B4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8Cget%E8%AF%B7%E6%B1%82%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F\">数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？</h3><ul><li>检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。</li></ul><h3 id=\"struts2%E5%92%8Cspringmvc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">Struts2和SpringMVC的区别？</h3><ul><li>Struts2入口是<code>Filter</code>，SpringMVC是<code>Servlet</code></li><li>Spring MVC是基于方法的设计，而Struts2是基于类</li><li>Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的</li><li>Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式</li></ul><h3 id=\"spring-mvc%E7%9A%84controller%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84%E5%90%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%E5%90%97%EF%BC%9F\">Spring MVC的Controller是单例的吗，有什么影响吗？</h3><ul><li>Spring MVC的controller是单例的</li><li>如果在controller中定义了非静态成员变量，会导致属性重复使用</li></ul><pre><code class=\"language-java\">// 非静态成员变量j的属性值会重复利用，不会累加\n// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\"prototype\")\n@Controller\n@RequestMapping(\"/test\")\npublic class IndexController{\n\tprivate static int i = 0;\n\tprivate int j = 0;\n\tpublic String test(){\n\t\tSystem.out.println((i++) + \"|\" + (j++));\n\t\treturn \"test\";\n\t}\n}\n\n</code></pre><h3 id=\"mybatis%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%EF%BC%9F\">MyBatis如何防止sql注入？</h3><p>Mybatis中的<code>#{}</code>和<code>${}</code>的区别</p><ul><li><code>#{}</code>使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by \"111\", 如果传入的值是id，则解析成的sql为order by \"id\"</li><li><code>${}</code>将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id</li><li><code>#{}</code>方式能够很大程度防止sql注入</li><li><code>${}</code>方式无法防止Sql注入</li><li><code>${}</code>方式一般用于传入数据库对象，例如传入表名</li><li>尽量使用<code>#{}</code>代替<code>${}</code></li><li>参考文献</li><li><a href=\"https://segmentfault.com/a/1190000010107964\">https://segmentfault.com/a/1190000010107964</a></li><li><a href=\"https://my.oschina.net/chuibilong/blog/638950\">https://my.oschina.net/chuibilong/blog/638950</a></li><li><a href=\"https://blog.csdn.net/kakaxi_77/article/details/46007239\">https://blog.csdn.net/kakaxi_77/article/details/46007239</a></li></ul><h3 id=\"hibernate%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F\">Hibernate一级缓存、二级缓存？</h3><p>一级缓存</p><ul><li>第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session 对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。</li><li>如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭 session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。</li></ul><p>二级缓存</p><ul><li>第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。</li><li>第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。</li><li>任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给 Hibernate 提供一个缓存实现的解决方法。</li></ul><p>参考文献</p><ul><li><a href=\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\">http://wiki.jikexueyuan.com/project/hibernate/caching.html</a></li><li><a href=\"https://blog.csdn.net/xlgen157387/article/details/40071651\">https://blog.csdn.net/xlgen157387/article/details/40071651</a></li></ul><h3 id=\"%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9Bsocket%E6%A1%86%E6%9E%B6%EF%BC%9F\">使用过哪些socket框架？</h3><h2 id=\"%E5%BB%B6%E4%BC%B8\">延伸</h2><h3 id=\"spring-mvc-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B\">Spring MVC 请求-响应流程</h3><ul><li>1.浏览器发送请求的url以及其他信息</li><li>2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。</li><li>3.确定合适的控制器后，将请求发送给选中的控制器</li><li>4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet</li><li>5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）</li><li>6.DispatcherServlet匹配到对应的视图实现</li><li>7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端</li></ul><h3 id=\"struts2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\">struts2 工作流程</h3><h3 id=\"http%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81\">http协议无状态</h3><p>对<strong>无状态</strong>的理解</p><ul><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见</li></ul><p><strong>状态</strong>的含义：客户端和服务器在某次会话中产生的数据。</p><p><strong>无状态</strong>就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。</p><p>在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。</p><p>知乎上有个哥们儿举的一个例子：</p><blockquote><strong>有状态：</strong></blockquote><blockquote>A：你今天中午吃的啥？</blockquote><blockquote>B：吃的大盘鸡。</blockquote><blockquote>A：味道怎么样呀？</blockquote><blockquote>B：还不错，挺好吃的。</blockquote><blockquote><strong>无状态：</strong></blockquote><blockquote>A：你今天中午吃的啥？</blockquote><blockquote>B：吃的大盘鸡。</blockquote><blockquote>A：味道怎么样呀？</blockquote><blockquote>B：？？？啊？啥？啥味道怎么样？</blockquote><blockquote>所以需要cookie这种东西：</blockquote><blockquote>A：你今天中午吃的啥？</blockquote><blockquote>B：吃的大盘鸡。</blockquote><blockquote>A：你今天中午吃的大盘鸡味道怎么样呀？</blockquote><blockquote>B：还不错，挺好吃的。</blockquote>","comment_id":"619a6a1ceff3f40001c5e92f","plaintext":"数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？\n * 检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。\n\nStruts2和SpringMVC的区别？\n * Struts2入口是Filter，SpringMVC是Servlet\n * Spring MVC是基于方法的设计，而Struts2是基于类\n * Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的\n * Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式\n\nSpring MVC的Controller是单例的吗，有什么影响吗？\n * Spring MVC的controller是单例的\n * 如果在controller中定义了非静态成员变量，会导致属性重复使用\n\n// 非静态成员变量j的属性值会重复利用，不会累加\n// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\"prototype\")\n@Controller\n@RequestMapping(\"/test\")\npublic class IndexController{\n\tprivate static int i = 0;\n\tprivate int j = 0;\n\tpublic String test(){\n\t\tSystem.out.println((i++) + \"|\" + (j++));\n\t\treturn \"test\";\n\t}\n}\n\n\n\nMyBatis如何防止sql注入？\nMybatis中的#{}和${}的区别\n\n * #{}使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by\n   #user_id#，如果传入的值是111,那么解析成sql时的值为order by \"111\", 如果传入的值是id，则解析成的sql为order by\n   \"id\"\n * ${}将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by\n   user_id,  如果传入的值是id，则解析成的sql为order by id\n * #{}方式能够很大程度防止sql注入\n * ${}方式无法防止Sql注入\n * ${}方式一般用于传入数据库对象，例如传入表名\n * 尽量使用#{}代替${}\n * 参考文献\n * https://segmentfault.com/a/1190000010107964\n * https://my.oschina.net/chuibilong/blog/638950\n * https://blog.csdn.net/kakaxi_77/article/details/46007239\n\nHibernate一级缓存、二级缓存？\n一级缓存\n\n * 第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session\n   对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。\n * 如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭\n   session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。\n\n二级缓存\n\n * 第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。\n * 第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。\n * 任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给\n   Hibernate 提供一个缓存实现的解决方法。\n\n参考文献\n\n * http://wiki.jikexueyuan.com/project/hibernate/caching.html\n * https://blog.csdn.net/xlgen157387/article/details/40071651\n\n使用过哪些socket框架？\n延伸\nSpring MVC 请求-响应流程\n * 1.浏览器发送请求的url以及其他信息\n * 2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。\n * 3.确定合适的控制器后，将请求发送给选中的控制器\n * 4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet\n * 5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）\n * 6.DispatcherServlet匹配到对应的视图实现\n * 7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端\n\nstruts2 工作流程\nhttp协议无状态\n对无状态的理解\n\n * 协议对于事务处理没有记忆能力\n * 对同一个url请求没有上下文关系\n * 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况\n * 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器\n * 人生若只如初见\n\n状态的含义：客户端和服务器在某次会话中产生的数据。\n\n无状态就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。\n\n在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。\n\n知乎上有个哥们儿举的一个例子：\n\n> 有状态：\n> A：你今天中午吃的啥？\n> B：吃的大盘鸡。\n> A：味道怎么样呀？\n> B：还不错，挺好吃的。\n> 无状态：\n> A：你今天中午吃的啥？\n> B：吃的大盘鸡。\n> A：味道怎么样呀？\n> B：？？？啊？啥？啥味道怎么样？\n> 所以需要cookie这种东西：\n> A：你今天中午吃的啥？\n> B：吃的大盘鸡。\n> A：你今天中午吃的大盘鸡味道怎么样呀？\n> B：还不错，挺好吃的。","feature_image":"__GHOST_URL__/content/images/2021/12/java.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-21 15:47:40","created_by":"1","updated_at":"2021-12-14 15:50:38","updated_by":"1","published_at":"2018-04-10 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619a6ad5eff3f40001c5e945","uuid":"70570abd-b892-418b-aec2-0361ab07d29b","title":"Java 多线程","slug":"java-duo-xian-cheng","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[[\"soft-return\",\"\",{}]],\"cards\":[[\"code\",{\"code\":\"// 通过实现Runnable接口定义一个任务类\\npublic class TaskClass implements Runnable{\\n\\tpublic TaskClass(){\\n\\t\\n\\t}\\n\\t\\n\\tpublic void run(){\\n\\t\\t// do something...\\n\\t}\\n}\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"// 创建一个任务、一个线程以及启动线程的步骤\\npublic class Client{\\n\\tpublic void someMethod(){\\n\\t\\t//  创建一个TaskClass实例\\n\\t\\tTaskClass task = new TaskClass();\\n\\t\\t// 创建一个线程\\n\\t\\tThread thread = new Thread(task);\\n\\t\\t// 启动线程\\n\\t\\tthread.start();\\n\\t}\\n}\\n\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"package org.nocoder.thread;\\n\\n/**\\n * 创建三个任务以及三个运行这些任务的线程:\\n * 第一个任务打印字母a100次\\n * 第二个任务打印字母b100次\\n * 第三个任务打印1到100的整数\\n *\\n * @author jason\\n * @date 18/4/3.\\n */\\npublic class TaskThreadDemo {\\n    public static void main(String[] args){\\n        // 创建任务类\\n        Runnable printA = new PrintChar('a', 100);\\n        Runnable printB = new PrintChar('b', 100);\\n        Runnable print100 = new PrintNumber(100);\\n        // 创建线程\\n        Thread threadPrintA = new Thread(printA);\\n        Thread threadPrintB = new Thread(printB);\\n        Thread threadPrint100 = new Thread(print100);\\n        // 启动线程\\n        threadPrintA.start();\\n        threadPrintB.start();\\n        threadPrint100.start();\\n    }\\n\\n}\\n\\n/**\\n * 打印字符任务类\\n */\\nclass PrintChar implements Runnable {\\n    /**\\n     * 需要打印的字符\\n     */\\n    private char charToPrint;\\n\\n    /**\\n     * 需要打印的次数\\n     */\\n    private int times;\\n\\n    public PrintChar(char c, int t) {\\n        charToPrint = c;\\n        times = t;\\n    }\\n\\n    public void run() {\\n        for (int i = 0; i < times; i++) {\\n            System.out.print(charToPrint);\\n        }\\n    }\\n}\\n\\n/**\\n * 打印数字任务类\\n */\\nclass PrintNumber implements Runnable {\\n    /**\\n     * 需要打印的最大值\\n     */\\n    private int lastNum;\\n\\n    public PrintNumber(int n) {\\n        lastNum = n;\\n    }\\n\\n    public void run() {\\n        for (int i = 1; i <= lastNum; i++) {\\n            System.out.print(\\\" \\\" + i);\\n        }\\n    }\\n\\n\\n}\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"package org.nocoder.thread;\\n\\n/**\\n * @author jason\\n * @date 18/4/3.\\n */\\npublic class CustomeThread extends Thread {\\n    public CustomeThread(){\\n\\n    }\\n\\n    public void run(){\\n        System.out.println(Thread.currentThread().getName() + \\\": do something...\\\");\\n    }\\n}\\n\\nclass Client{\\n    public static void main(String[] args){\\n        Thread thread1 = new CustomeThread();\\n        thread1.setName(\\\"线程1\\\");\\n        thread1.start();\\n\\n        Thread thread2 = new CustomeThread();\\n        thread2.setName(\\\"线程2\\\");\\n        thread2.start();\\n    }\\n\\n}\\n\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"Thread.yield();\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"// 休眠 1ms\\ntry{\\n\\t...\\n\\tThread.sleep(1);\\n}catch(InterruptedException ex){\\n\\t// do someting...\\n}\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"package org.nocoder.thread;\\n\\n/**\\n * @author jason\\n * @date 18/4/6.\\n */\\npublic class YieldTest {\\n    public static void main(String[] args) {\\n        Thread t = new Thread(new Runnable() {\\n            public void run() {\\n                for (int i = 1; i <= 10; i++) {\\n                    System.out.print(i + \\\" \\\");\\n                }\\n                System.out.println();\\n            }\\n        });\\n        t.start();\\n        try {\\n        \\t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\\n            t.join();\\n        } catch (InterruptedException e) {\\n            e.printStackTrace();\\n        }\\n        for (int j = 11; j <= 20; j++) {\\n            System.out.print(j + \\\" \\\");\\n        }\\n        System.out.println();\\n    }\\n}\\n\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"1 2 3 4 5 6 7 8 9 10 \\n11 12 13 14 15 16 17 18 19 20 \\n\\n\"}],[\"code\",{\"code\":\"11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \\n18 19 20 \\n\"}]],\"markups\":[[\"strong\"],[\"code\"]],\"sections\":[[1,\"blockquote\",[[0,[],0,\"Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。\"]]],[1,\"h2\",[[0,[],0,\"线程的概念\"]]],[1,\"blockquote\",[[0,[0],1,\"线程\"],[0,[],0,\"是指一个任务从头到尾的执行流程。\"]]],[1,\"p\",[[0,[],0,\"一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。\"]]],[1,\"p\",[[0,[],0,\"多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。\"]]],[1,\"p\",[[0,[],0,\"在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。\"]]],[1,\"p\",[[0,[],0,\"在Java中，每个任务都是\"],[0,[1],1,\"Runnable\"],[0,[],0,\"接口的一个实例，也成为\"],[0,[1],1,\"可运行对象（runnable object）\"],[0,[],0,\"。\"]]],[1,\"h2\",[[0,[],0,\"创建任务和线程\"]]],[1,\"p\",[[0,[],0,\"一个任务类必须实现Runnable接口。任务必须从线程运行。\"],[1,[],0,0],[0,[],0,\"任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。\"]]],[10,0],[10,1],[1,\"h4\",[[0,[],0,\"编程练习\"]]],[1,\"blockquote\",[[0,[],0,\"创建三个任务以及三个运行这些任务的线程:\"]]],[1,\"blockquote\",[[0,[],0,\"第一个任务打印字母a100次\"]]],[1,\"blockquote\",[[0,[],0,\"第二个任务打印字母b100次\"]]],[1,\"blockquote\",[[0,[],0,\"第三个任务打印1到100的整数\"]]],[10,2],[1,\"blockquote\",[[0,[],0,\"任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。\"]]],[1,\"h2\",[[0,[],0,\"Thread类\"]]],[1,\"p\",[[0,[],0,\"Thread类包含为任务而创建的线程的构造方法，以及控制线程的方法。\"]]],[1,\"p\",[[0,[],0,\"Thread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。\"]]],[10,3],[1,\"p\",[[0,[],0,\"使用\"],[0,[1],1,\"yield()\"],[0,[],0,\"方法为其他线程临时让出CPU时间。\"]]],[10,4],[1,\"p\",[[0,[],0,\"使用\"],[0,[1],1,\"sleep(long mills)\"],[0,[],0,\"可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。\"]]],[10,5],[1,\"p\",[[0,[],0,\"sleep方法可能抛出一个\"],[0,[1],1,\"InterruptedException\"],[0,[],0,\"，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。\"]]],[1,\"p\",[[0,[],0,\"使用\"],[0,[1],1,\"join()\"],[0,[],0,\"方法使用一个线程等待另一个线程的结束。\"]]],[10,6],[1,\"p\",[[0,[],0,\"输出结果：\"]]],[10,7],[1,\"p\",[[0,[],0,\"如果不加join()方法的输出结果顺序不固定\"]]],[10,8]],\"ghostVersion\":\"4.0\"}","html":"<blockquote>Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。</blockquote><h2 id=\"%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\">线程的概念</h2><blockquote><strong>线程</strong>是指一个任务从头到尾的执行流程。</blockquote><p>一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。</p><p>多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。</p><p>在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。</p><p>在Java中，每个任务都是<code>Runnable</code>接口的一个实例，也成为<code>可运行对象（runnable object）</code>。</p><h2 id=\"%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%BA%BF%E7%A8%8B\">创建任务和线程</h2><p>一个任务类必须实现Runnable接口。任务必须从线程运行。<br>任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。</p><pre><code class=\"language-java\">// 通过实现Runnable接口定义一个任务类\npublic class TaskClass implements Runnable{\n\tpublic TaskClass(){\n\t\n\t}\n\t\n\tpublic void run(){\n\t\t// do something...\n\t}\n}\n</code></pre><pre><code class=\"language-java\">// 创建一个任务、一个线程以及启动线程的步骤\npublic class Client{\n\tpublic void someMethod(){\n\t\t//  创建一个TaskClass实例\n\t\tTaskClass task = new TaskClass();\n\t\t// 创建一个线程\n\t\tThread thread = new Thread(task);\n\t\t// 启动线程\n\t\tthread.start();\n\t}\n}\n\n</code></pre><h4 id=\"%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0\">编程练习</h4><blockquote>创建三个任务以及三个运行这些任务的线程:</blockquote><blockquote>第一个任务打印字母a100次</blockquote><blockquote>第二个任务打印字母b100次</blockquote><blockquote>第三个任务打印1到100的整数</blockquote><pre><code class=\"language-java\">package org.nocoder.thread;\n\n/**\n * 创建三个任务以及三个运行这些任务的线程:\n * 第一个任务打印字母a100次\n * 第二个任务打印字母b100次\n * 第三个任务打印1到100的整数\n *\n * @author jason\n * @date 18/4/3.\n */\npublic class TaskThreadDemo {\n    public static void main(String[] args){\n        // 创建任务类\n        Runnable printA = new PrintChar('a', 100);\n        Runnable printB = new PrintChar('b', 100);\n        Runnable print100 = new PrintNumber(100);\n        // 创建线程\n        Thread threadPrintA = new Thread(printA);\n        Thread threadPrintB = new Thread(printB);\n        Thread threadPrint100 = new Thread(print100);\n        // 启动线程\n        threadPrintA.start();\n        threadPrintB.start();\n        threadPrint100.start();\n    }\n\n}\n\n/**\n * 打印字符任务类\n */\nclass PrintChar implements Runnable {\n    /**\n     * 需要打印的字符\n     */\n    private char charToPrint;\n\n    /**\n     * 需要打印的次数\n     */\n    private int times;\n\n    public PrintChar(char c, int t) {\n        charToPrint = c;\n        times = t;\n    }\n\n    public void run() {\n        for (int i = 0; i &lt; times; i++) {\n            System.out.print(charToPrint);\n        }\n    }\n}\n\n/**\n * 打印数字任务类\n */\nclass PrintNumber implements Runnable {\n    /**\n     * 需要打印的最大值\n     */\n    private int lastNum;\n\n    public PrintNumber(int n) {\n        lastNum = n;\n    }\n\n    public void run() {\n        for (int i = 1; i &lt;= lastNum; i++) {\n            System.out.print(\" \" + i);\n        }\n    }\n\n\n}\n</code></pre><blockquote>任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。</blockquote><h2 id=\"thread%E7%B1%BB\">Thread类</h2><p>Thread类包含为任务而创建的线程的构造方法，以及控制线程的方法。</p><p>Thread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。</p><pre><code class=\"language-java\">package org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/3.\n */\npublic class CustomeThread extends Thread {\n    public CustomeThread(){\n\n    }\n\n    public void run(){\n        System.out.println(Thread.currentThread().getName() + \": do something...\");\n    }\n}\n\nclass Client{\n    public static void main(String[] args){\n        Thread thread1 = new CustomeThread();\n        thread1.setName(\"线程1\");\n        thread1.start();\n\n        Thread thread2 = new CustomeThread();\n        thread2.setName(\"线程2\");\n        thread2.start();\n    }\n\n}\n\n</code></pre><p>使用<code>yield()</code>方法为其他线程临时让出CPU时间。</p><pre><code class=\"language-java\">Thread.yield();\n</code></pre><p>使用<code>sleep(long mills)</code>可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。</p><pre><code class=\"language-java\">// 休眠 1ms\ntry{\n\t...\n\tThread.sleep(1);\n}catch(InterruptedException ex){\n\t// do someting...\n}\n</code></pre><p>sleep方法可能抛出一个<code>InterruptedException</code>，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。</p><p>使用<code>join()</code>方法使用一个线程等待另一个线程的结束。</p><pre><code class=\"language-java\">package org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/6.\n */\npublic class YieldTest {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 1; i &lt;= 10; i++) {\n                    System.out.print(i + \" \");\n                }\n                System.out.println();\n            }\n        });\n        t.start();\n        try {\n        \t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int j = 11; j &lt;= 20; j++) {\n            System.out.print(j + \" \");\n        }\n        System.out.println();\n    }\n}\n\n</code></pre><p>输出结果：</p><pre><code>1 2 3 4 5 6 7 8 9 10 \n11 12 13 14 15 16 17 18 19 20 \n\n</code></pre><p>如果不加join()方法的输出结果顺序不固定</p><pre><code>11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \n18 19 20 \n</code></pre>","comment_id":"619a6ad5eff3f40001c5e945","plaintext":"> Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。\n线程的概念\n> 线程是指一个任务从头到尾的执行流程。\n一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。\n\n多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。\n\n在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。\n\n在Java中，每个任务都是Runnable接口的一个实例，也成为可运行对象（runnable object）。\n\n创建任务和线程\n一个任务类必须实现Runnable接口。任务必须从线程运行。\n任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。\n\n// 通过实现Runnable接口定义一个任务类\npublic class TaskClass implements Runnable{\n\tpublic TaskClass(){\n\t\n\t}\n\t\n\tpublic void run(){\n\t\t// do something...\n\t}\n}\n\n\n// 创建一个任务、一个线程以及启动线程的步骤\npublic class Client{\n\tpublic void someMethod(){\n\t\t//  创建一个TaskClass实例\n\t\tTaskClass task = new TaskClass();\n\t\t// 创建一个线程\n\t\tThread thread = new Thread(task);\n\t\t// 启动线程\n\t\tthread.start();\n\t}\n}\n\n\n\n编程练习\n> 创建三个任务以及三个运行这些任务的线程:\n> 第一个任务打印字母a100次\n> 第二个任务打印字母b100次\n> 第三个任务打印1到100的整数\npackage org.nocoder.thread;\n\n/**\n * 创建三个任务以及三个运行这些任务的线程:\n * 第一个任务打印字母a100次\n * 第二个任务打印字母b100次\n * 第三个任务打印1到100的整数\n *\n * @author jason\n * @date 18/4/3.\n */\npublic class TaskThreadDemo {\n    public static void main(String[] args){\n        // 创建任务类\n        Runnable printA = new PrintChar('a', 100);\n        Runnable printB = new PrintChar('b', 100);\n        Runnable print100 = new PrintNumber(100);\n        // 创建线程\n        Thread threadPrintA = new Thread(printA);\n        Thread threadPrintB = new Thread(printB);\n        Thread threadPrint100 = new Thread(print100);\n        // 启动线程\n        threadPrintA.start();\n        threadPrintB.start();\n        threadPrint100.start();\n    }\n\n}\n\n/**\n * 打印字符任务类\n */\nclass PrintChar implements Runnable {\n    /**\n     * 需要打印的字符\n     */\n    private char charToPrint;\n\n    /**\n     * 需要打印的次数\n     */\n    private int times;\n\n    public PrintChar(char c, int t) {\n        charToPrint = c;\n        times = t;\n    }\n\n    public void run() {\n        for (int i = 0; i < times; i++) {\n            System.out.print(charToPrint);\n        }\n    }\n}\n\n/**\n * 打印数字任务类\n */\nclass PrintNumber implements Runnable {\n    /**\n     * 需要打印的最大值\n     */\n    private int lastNum;\n\n    public PrintNumber(int n) {\n        lastNum = n;\n    }\n\n    public void run() {\n        for (int i = 1; i <= lastNum; i++) {\n            System.out.print(\" \" + i);\n        }\n    }\n\n\n}\n\n\n> 任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。\nThread类\nThread类包含为任务而创建的线程的构造方法，以及控制线程的方法。\n\nThread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。\n\npackage org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/3.\n */\npublic class CustomeThread extends Thread {\n    public CustomeThread(){\n\n    }\n\n    public void run(){\n        System.out.println(Thread.currentThread().getName() + \": do something...\");\n    }\n}\n\nclass Client{\n    public static void main(String[] args){\n        Thread thread1 = new CustomeThread();\n        thread1.setName(\"线程1\");\n        thread1.start();\n\n        Thread thread2 = new CustomeThread();\n        thread2.setName(\"线程2\");\n        thread2.start();\n    }\n\n}\n\n\n\n使用yield()方法为其他线程临时让出CPU时间。\n\nThread.yield();\n\n\n使用sleep(long mills)可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。\n\n// 休眠 1ms\ntry{\n\t...\n\tThread.sleep(1);\n}catch(InterruptedException ex){\n\t// do someting...\n}\n\n\nsleep方法可能抛出一个InterruptedException\n，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。\n\n使用join()方法使用一个线程等待另一个线程的结束。\n\npackage org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/6.\n */\npublic class YieldTest {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 1; i <= 10; i++) {\n                    System.out.print(i + \" \");\n                }\n                System.out.println();\n            }\n        });\n        t.start();\n        try {\n        \t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int j = 11; j <= 20; j++) {\n            System.out.print(j + \" \");\n        }\n        System.out.println();\n    }\n}\n\n\n\n输出结果：\n\n1 2 3 4 5 6 7 8 9 10 \n11 12 13 14 15 16 17 18 19 20 \n\n\n\n如果不加join()方法的输出结果顺序不固定\n\n11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \n18 19 20","feature_image":"__GHOST_URL__/content/images/2021/12/What-is-multithreading-in-java.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-21 15:50:45","created_by":"1","updated_at":"2021-12-01 17:14:48","updated_by":"1","published_at":"2019-07-03 02:57:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619b491feff3f40001c5e961","uuid":"81c4dcb0-0acf-4b41-a8e6-787612ca9537","title":"Springboot 配置文件解密","slug":"springboot-pei-zhi-wen-jian-jie-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"写一个工具类 `EncryptUtil.java`，完成加密解密方法\\n\\n```java\\n// 加密\\npublic static String encode(String value){\\n    if(StringUtils.isNotBlank(value)){        \\n        Base64 base64 = new Base64();       \\n        return new String(base64.encode(value.getBytes()));   \\n    }    \\n    return null;\\n}\\n\\n// 解密\\npublic static String decode(String value){    \\n    if(StringUtils.isNotBlank(value)){       \\n        Base64 base64 = new Base64();        \\n        return new String(base64.decode(value.getBytes()));    \\n    }    \\n    return null;\\n}\\n```\\n\\n在配置文件`application.yml`里，使用加密后的值，加个特殊的前缀，例如`SEC@`\\n\\n```yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://192.168.0.111:3306/test\\n    username: SEC@cm9vdA==\\n    password: SEC@TXlzcWxAMTIz\\n    type: com.alibaba.druid.pool.DruidDataSource\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n```\\n\\n在`pom.xml`中添加`jasypt-spring-boot-starter`依赖\\n\\n```xml\\n<dependency>\\n    <groupId>com.github.ulisesbocchio</groupId>    \\n    <artifactId>jasypt-spring-boot-starter</artifactId>\\n    <version>2.1.0</version>\\n</dependency>\\n```\\n\\n写一个`Configuration`  bean，实现`jasypt`提供的`EncryptablePropertyResolver`接口，在`resolvePropertyValue(String value)`方法中将配置文件中前缀为`SEC@`的加了密的value截取出来，使用之前写好的解密方法进行解密。\\n\\n```java\\nimport com.swcares.attms.util.EncryptUtil;\\nimport com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\n\\n@Configuration\\npublic class EncryptionPropertyConfig {\\n\\n    @Bean(name = \\\"encryptablePropertyResolver\\\")\\n    public EncryptablePropertyResolver encryptablePropertyResolver() {\\n        return new EncryptionPropertyResolver();    \\n    }    \\n    \\n    class EncryptionPropertyResolver implements EncryptablePropertyResolver {\\n        @Override        \\n        public String resolvePropertyValue(String value) {            \\n            if (value.startsWith(\\\"SEC@\\\")) {                \\n                String propertyValue = value.substring(4);               \\n                return EncryptUtil.decode(propertyValue);            \\n            }\\n            return value;        \\n        }       \\n    }\\n}\\n\\n```\\n\\n之前写过一个[Spring项目数据库密码加密](__GHOST_URL__/springxiang-mu-shu-ju-ku-mi-ma-jia-mi/)，是普通的Spring项目的实现，原理都一样，加个密再用，至少比明文密码安全一点。\\n\\nThe end.\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>写一个工具类 <code>EncryptUtil.java</code>，完成加密解密方法</p>\n<pre><code class=\"language-java\">// 加密\npublic static String encode(String value){\n    if(StringUtils.isNotBlank(value)){        \n        Base64 base64 = new Base64();       \n        return new String(base64.encode(value.getBytes()));   \n    }    \n    return null;\n}\n\n// 解密\npublic static String decode(String value){    \n    if(StringUtils.isNotBlank(value)){       \n        Base64 base64 = new Base64();        \n        return new String(base64.decode(value.getBytes()));    \n    }    \n    return null;\n}\n</code></pre>\n<p>在配置文件<code>application.yml</code>里，使用加密后的值，加个特殊的前缀，例如<code>SEC@</code></p>\n<pre><code class=\"language-yml\">spring:\n  datasource:\n    url: jdbc:mysql://192.168.0.111:3306/test\n    username: SEC@cm9vdA==\n    password: SEC@TXlzcWxAMTIz\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n</code></pre>\n<p>在<code>pom.xml</code>中添加<code>jasypt-spring-boot-starter</code>依赖</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;    \n    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>写一个<code>Configuration</code>  bean，实现<code>jasypt</code>提供的<code>EncryptablePropertyResolver</code>接口，在<code>resolvePropertyValue(String value)</code>方法中将配置文件中前缀为<code>SEC@</code>的加了密的value截取出来，使用之前写好的解密方法进行解密。</p>\n<pre><code class=\"language-java\">import com.swcares.attms.util.EncryptUtil;\nimport com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class EncryptionPropertyConfig {\n\n    @Bean(name = &quot;encryptablePropertyResolver&quot;)\n    public EncryptablePropertyResolver encryptablePropertyResolver() {\n        return new EncryptionPropertyResolver();    \n    }    \n    \n    class EncryptionPropertyResolver implements EncryptablePropertyResolver {\n        @Override        \n        public String resolvePropertyValue(String value) {            \n            if (value.startsWith(&quot;SEC@&quot;)) {                \n                String propertyValue = value.substring(4);               \n                return EncryptUtil.decode(propertyValue);            \n            }\n            return value;        \n        }       \n    }\n}\n\n</code></pre>\n<p>之前写过一个<a href=\"__GHOST_URL__/springxiang-mu-shu-ju-ku-mi-ma-jia-mi/\">Spring项目数据库密码加密</a>，是普通的Spring项目的实现，原理都一样，加个密再用，至少比明文密码安全一点。</p>\n<p>The end.</p>\n<!--kg-card-end: markdown-->","comment_id":"619b491feff3f40001c5e961","plaintext":"写一个工具类 EncryptUtil.java，完成加密解密方法\n\n// 加密\npublic static String encode(String value){\n    if(StringUtils.isNotBlank(value)){        \n        Base64 base64 = new Base64();       \n        return new String(base64.encode(value.getBytes()));   \n    }    \n    return null;\n}\n\n// 解密\npublic static String decode(String value){    \n    if(StringUtils.isNotBlank(value)){       \n        Base64 base64 = new Base64();        \n        return new String(base64.decode(value.getBytes()));    \n    }    \n    return null;\n}\n\n\n在配置文件application.yml里，使用加密后的值，加个特殊的前缀，例如SEC@\n\nspring:\n  datasource:\n    url: jdbc:mysql://192.168.0.111:3306/test\n    username: SEC@cm9vdA==\n    password: SEC@TXlzcWxAMTIz\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n\n在pom.xml中添加jasypt-spring-boot-starter依赖\n\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>    \n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>2.1.0</version>\n</dependency>\n\n\n写一个Configuration bean，实现jasypt提供的EncryptablePropertyResolver接口，在\nresolvePropertyValue(String value)方法中将配置文件中前缀为SEC@\n的加了密的value截取出来，使用之前写好的解密方法进行解密。\n\nimport com.swcares.attms.util.EncryptUtil;\nimport com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class EncryptionPropertyConfig {\n\n    @Bean(name = \"encryptablePropertyResolver\")\n    public EncryptablePropertyResolver encryptablePropertyResolver() {\n        return new EncryptionPropertyResolver();    \n    }    \n    \n    class EncryptionPropertyResolver implements EncryptablePropertyResolver {\n        @Override        \n        public String resolvePropertyValue(String value) {            \n            if (value.startsWith(\"SEC@\")) {                \n                String propertyValue = value.substring(4);               \n                return EncryptUtil.decode(propertyValue);            \n            }\n            return value;        \n        }       \n    }\n}\n\n\n\n之前写过一个Spring项目数据库密码加密\n[http://nocoder.org/springxiang-mu-shu-ju-ku-mi-ma-jia-mi/]\n，是普通的Spring项目的实现，原理都一样，加个密再用，至少比明文密码安全一点。\n\nThe end.","feature_image":"__GHOST_URL__/content/images/2021/12/encrypt.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-22 07:39:11","created_by":"1","updated_at":"2021-12-01 17:10:18","updated_by":"1","published_at":"2021-11-22 07:41:10","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61a7a09c5f5de50001a50787","uuid":"e1778c54-09de-42c6-8367-341bf90d0ecd","title":"CAS 5.3 服务搭建与客户端接入","slug":"cas-shi-jian","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n> 最近在做中心内部信息化的一些工作，优先级比较高的就是解决单点登录问题。调研了几个单点登录方案后，选用CAS作为单点登录系统。为了方便后续搜索问题解决办法，随大流使用了5.3这个版本。\\n\\n## CAS Enterprise Single Sign-On\\n\\nCAS 5.3官方文档 https://apereo.github.io/cas/5.3.x/\\n\\n## CAS 5.3环境搭建\\n\\n按照官网强烈建议的`WAR Overlay`的方式安装，以便后续升级。使用这个模板[apereo/cas-overlay-template](https://github.com/apereo/cas-overlay-template)创建一个5.3版本的项目。overlay的方式，大概意思就是把war包下要修改的文件按相同的路径复制出来作为源码，这样在编译后，自己复制出来修改的那些文件就会替换原有的文件。\\n\\n### 修改日志路径\\n\\n把`log4j2.xml`复制到src/main/resources/下，修改`baseDir`的路径\\n\\n```\\n<Property name=\\\"baseDir\\\">/home/yangjl/github/cas-overlay-template/etc/cas/logs</Property>\\n```\\n\\n### 支持http\\n\\n**修改 HTTPSandIMAPS-10000001.json**\\n\\n把 `WEB-INF/classes/services/HTTPSandIMAPS-10000001.json` 复制到 `src/main/resources/services/HTTPSandIMAPS-10000001.json`，在 `serviceId` 的内容里增加 `http`\\n\\n\\n```json\\n{\\n\\t\\\"@class\\\" : \\\"org.apereo.cas.services.RegexRegisteredService\\\",\\n  \\t\\\"serviceId\\\" : \\\"^(https|imaps|http)://.*\\\",\\n  \\t\\\"name\\\" : \\\"HTTPS and IMAPS\\\",\\n  \\t\\\"id\\\" : 10000001,\\n  \\t\\\"description\\\" : \\\"This service definition authorizes all application urls that support HTTPS and IMAPS protocols.\\\",\\n  \\t\\\"evaluationOrder\\\" : 10000\\n}\\n```\\n\\n\\n**修改 `application.properties`**\\n\\n把 `application.properties` 复制到`src/main/resources`下\\n\\n注释以下三行\\n\\n```\\n#server.ssl.key-store=file:/etc/cas/thekeystore\\n#server.ssl.key-store-password=changeit\\n#server.ssl.key-password=changeit\\n```\\n\\n增加下面两行\\n\\n```\\ncas.tgc.secure=false\\ncas.serviceRegistry.initFromJson=true\\n```\\n\\n\\n### 连接MySQL数据库\\n\\n**修改pom.xml**,增加依赖\\n\\n```xml\\n<dependency>\\n    <groupId>org.apereo.cas</groupId>\\n    <artifactId>cas-server-support-jdbc</artifactId>\\n    <version>${cas.version}</version>\\n</dependency>\\n<dependency>\\n    <groupId>org.apereo.cas</groupId>\\n    <artifactId>cas-server-support-jdbc-drivers</artifactId>\\n    <version>${cas.version}</version>\\n</dependency>\\n```\\n\\n上面的`cas-server-support-jdbc-drivers`包含了MySQL的驱动，不需要单独引入MySQL的依赖\\n\\n> 注意：MySQL8 的驱动类为：`com.mysql.cj.jdbc.Driver`\\n\\n在 配置文件增加以下配置\\n\\n```\\n# 根据用户名查询密码\\ncas.authn.jdbc.query[0].sql=select username, password from user where username=?\\n# 密码的字段名\\ncas.authn.jdbc.query[0].fieldPassword=password\\ncas.authn.jdbc.query[0].url=jdbc:mysql://127.0.0.1:3306/cas\\ncas.authn.jdbc.query[0].user=root\\ncas.authn.jdbc.query[0].password=123456\\ncas.authn.jdbc.query[0].driverClass=com.mysql.cj.jdbc.Driver\\n\\n把配置文件里的默认用户注释掉\\n#cas.authn.accept.users=casuser::Mellon\\n```\\n\\n#### 使用加密的用户密码\\n\\n以下是使用MD5加密的配置，也可以指定自定义的实现类\\n\\n```\\n# NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2\\ncas.authn.jdbc.query[0].passwordEncoder.type=DEFAULT\\ncas.authn.jdbc.query[0].passwordEncoder.encodingAlgorithm=MD5\\n```\\n\\n## CAS-Client 接入CAS\\n\\n### Springboot-thymeleaf-shiro项目接入CAS\\n\\n参考这个网友的项目 https://github.com/gkaigk1987/shiro-pac4j-cas-demo\\n\\nThe End.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>最近在做中心内部信息化的一些工作，优先级比较高的就是解决单点登录问题。调研了几个单点登录方案后，选用CAS作为单点登录系统。为了方便后续搜索问题解决办法，随大流使用了5.3这个版本。</p>\n</blockquote>\n<h2 id=\"cas-enterprise-single-sign-on\">CAS Enterprise Single Sign-On</h2>\n<p>CAS 5.3官方文档 <a href=\"https://apereo.github.io/cas/5.3.x/\">https://apereo.github.io/cas/5.3.x/</a></p>\n<h2 id=\"cas-53%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\">CAS 5.3环境搭建</h2>\n<p>按照官网强烈建议的<code>WAR Overlay</code>的方式安装，以便后续升级。使用这个模板<a href=\"https://github.com/apereo/cas-overlay-template\">apereo/cas-overlay-template</a>创建一个5.3版本的项目。overlay的方式，大概意思就是把war包下要修改的文件按相同的路径复制出来作为源码，这样在编译后，自己复制出来修改的那些文件就会替换原有的文件。</p>\n<h3 id=\"%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E8%B7%AF%E5%BE%84\">修改日志路径</h3>\n<p>把<code>log4j2.xml</code>复制到src/main/resources/下，修改<code>baseDir</code>的路径</p>\n<pre><code>&lt;Property name=&quot;baseDir&quot;&gt;/home/yangjl/github/cas-overlay-template/etc/cas/logs&lt;/Property&gt;\n</code></pre>\n<h3 id=\"%E6%94%AF%E6%8C%81http\">支持http</h3>\n<p><strong>修改 HTTPSandIMAPS-10000001.json</strong></p>\n<p>把 <code>WEB-INF/classes/services/HTTPSandIMAPS-10000001.json</code> 复制到 <code>src/main/resources/services/HTTPSandIMAPS-10000001.json</code>，在 <code>serviceId</code> 的内容里增加 <code>http</code></p>\n<pre><code class=\"language-json\">{\n\t&quot;@class&quot; : &quot;org.apereo.cas.services.RegexRegisteredService&quot;,\n  \t&quot;serviceId&quot; : &quot;^(https|imaps|http)://.*&quot;,\n  \t&quot;name&quot; : &quot;HTTPS and IMAPS&quot;,\n  \t&quot;id&quot; : 10000001,\n  \t&quot;description&quot; : &quot;This service definition authorizes all application urls that support HTTPS and IMAPS protocols.&quot;,\n  \t&quot;evaluationOrder&quot; : 10000\n}\n</code></pre>\n<p><strong>修改 <code>application.properties</code></strong></p>\n<p>把 <code>application.properties</code> 复制到<code>src/main/resources</code>下</p>\n<p>注释以下三行</p>\n<pre><code>#server.ssl.key-store=file:/etc/cas/thekeystore\n#server.ssl.key-store-password=changeit\n#server.ssl.key-password=changeit\n</code></pre>\n<p>增加下面两行</p>\n<pre><code>cas.tgc.secure=false\ncas.serviceRegistry.initFromJson=true\n</code></pre>\n<h3 id=\"%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93\">连接MySQL数据库</h3>\n<p><strong>修改pom.xml</strong>,增加依赖</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;\n    &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;${cas.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;\n    &lt;artifactId&gt;cas-server-support-jdbc-drivers&lt;/artifactId&gt;\n    &lt;version&gt;${cas.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>上面的<code>cas-server-support-jdbc-drivers</code>包含了MySQL的驱动，不需要单独引入MySQL的依赖</p>\n<blockquote>\n<p>注意：MySQL8 的驱动类为：<code>com.mysql.cj.jdbc.Driver</code></p>\n</blockquote>\n<p>在 配置文件增加以下配置</p>\n<pre><code># 根据用户名查询密码\ncas.authn.jdbc.query[0].sql=select username, password from user where username=?\n# 密码的字段名\ncas.authn.jdbc.query[0].fieldPassword=password\ncas.authn.jdbc.query[0].url=jdbc:mysql://127.0.0.1:3306/cas\ncas.authn.jdbc.query[0].user=root\ncas.authn.jdbc.query[0].password=123456\ncas.authn.jdbc.query[0].driverClass=com.mysql.cj.jdbc.Driver\n\n把配置文件里的默认用户注释掉\n#cas.authn.accept.users=casuser::Mellon\n</code></pre>\n<h4 id=\"%E4%BD%BF%E7%94%A8%E5%8A%A0%E5%AF%86%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81\">使用加密的用户密码</h4>\n<p>以下是使用MD5加密的配置，也可以指定自定义的实现类</p>\n<pre><code># NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2\ncas.authn.jdbc.query[0].passwordEncoder.type=DEFAULT\ncas.authn.jdbc.query[0].passwordEncoder.encodingAlgorithm=MD5\n</code></pre>\n<h2 id=\"cas-client-%E6%8E%A5%E5%85%A5cas\">CAS-Client 接入CAS</h2>\n<h3 id=\"springboot-thymeleaf-shiro%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5cas\">Springboot-thymeleaf-shiro项目接入CAS</h3>\n<p>参考这个网友的项目 <a href=\"https://github.com/gkaigk1987/shiro-pac4j-cas-demo\">https://github.com/gkaigk1987/shiro-pac4j-cas-demo</a></p>\n<p>The End.</p>\n<!--kg-card-end: markdown-->","comment_id":"61a7a09c5f5de50001a50787","plaintext":"> 最近在做中心内部信息化的一些工作，优先级比较高的就是解决单点登录问题。调研了几个单点登录方案后，选用CAS作为单点登录系统。为了方便后续搜索问题解决办法，随大流使用了5.3这个版本。\n\n\nCAS Enterprise Single Sign-On\nCAS 5.3官方文档 https://apereo.github.io/cas/5.3.x/\n\nCAS 5.3环境搭建\n按照官网强烈建议的WAR Overlay的方式安装，以便后续升级。使用这个模板apereo/cas-overlay-template\n[https://github.com/apereo/cas-overlay-template]\n创建一个5.3版本的项目。overlay的方式，大概意思就是把war包下要修改的文件按相同的路径复制出来作为源码，这样在编译后，自己复制出来修改的那些文件就会替换原有的文件。\n\n修改日志路径\n把log4j2.xml复制到src/main/resources/下，修改baseDir的路径\n\n<Property name=\"baseDir\">/home/yangjl/github/cas-overlay-template/etc/cas/logs</Property>\n\n\n支持http\n修改 HTTPSandIMAPS-10000001.json\n\n把 WEB-INF/classes/services/HTTPSandIMAPS-10000001.json 复制到 \nsrc/main/resources/services/HTTPSandIMAPS-10000001.json，在 serviceId 的内容里增加 http\n\n{\n\t\"@class\" : \"org.apereo.cas.services.RegexRegisteredService\",\n  \t\"serviceId\" : \"^(https|imaps|http)://.*\",\n  \t\"name\" : \"HTTPS and IMAPS\",\n  \t\"id\" : 10000001,\n  \t\"description\" : \"This service definition authorizes all application urls that support HTTPS and IMAPS protocols.\",\n  \t\"evaluationOrder\" : 10000\n}\n\n\n修改 application.properties\n\n把 application.properties 复制到src/main/resources下\n\n注释以下三行\n\n#server.ssl.key-store=file:/etc/cas/thekeystore\n#server.ssl.key-store-password=changeit\n#server.ssl.key-password=changeit\n\n\n增加下面两行\n\ncas.tgc.secure=false\ncas.serviceRegistry.initFromJson=true\n\n\n连接MySQL数据库\n修改pom.xml,增加依赖\n\n<dependency>\n    <groupId>org.apereo.cas</groupId>\n    <artifactId>cas-server-support-jdbc</artifactId>\n    <version>${cas.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.apereo.cas</groupId>\n    <artifactId>cas-server-support-jdbc-drivers</artifactId>\n    <version>${cas.version}</version>\n</dependency>\n\n\n上面的cas-server-support-jdbc-drivers包含了MySQL的驱动，不需要单独引入MySQL的依赖\n\n> 注意：MySQL8 的驱动类为：com.mysql.cj.jdbc.Driver\n\n\n在 配置文件增加以下配置\n\n# 根据用户名查询密码\ncas.authn.jdbc.query[0].sql=select username, password from user where username=?\n# 密码的字段名\ncas.authn.jdbc.query[0].fieldPassword=password\ncas.authn.jdbc.query[0].url=jdbc:mysql://127.0.0.1:3306/cas\ncas.authn.jdbc.query[0].user=root\ncas.authn.jdbc.query[0].password=123456\ncas.authn.jdbc.query[0].driverClass=com.mysql.cj.jdbc.Driver\n\n把配置文件里的默认用户注释掉\n#cas.authn.accept.users=casuser::Mellon\n\n\n使用加密的用户密码\n以下是使用MD5加密的配置，也可以指定自定义的实现类\n\n# NONE|DEFAULT|STANDARD|BCRYPT|SCRYPT|PBKDF2\ncas.authn.jdbc.query[0].passwordEncoder.type=DEFAULT\ncas.authn.jdbc.query[0].passwordEncoder.encodingAlgorithm=MD5\n\n\nCAS-Client 接入CAS\nSpringboot-thymeleaf-shiro项目接入CAS\n参考这个网友的项目 https://github.com/gkaigk1987/shiro-pac4j-cas-demo\n\nThe End.","feature_image":"__GHOST_URL__/content/images/2021/12/cas.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-01 16:19:40","created_by":"1","updated_at":"2022-03-20 13:59:19","updated_by":"1","published_at":"2021-12-01 17:04:58","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61aceebe1fb64e0001fdd026","uuid":"527506d8-4650-46b3-b422-55eb91606fef","title":"About","slug":"about","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"**Hi, I am Jason Yang.**\\n\\n**I love technology, software architecture, java and various interesting technologies.**\\n\\n<iframe src=\\\"//player.bilibili.com/player.html?aid=467482684&bvid=BV11L411w7Kt&cid=554594001&page=1\\\" scrolling=\\\"no\\\" border=\\\"0\\\" frameborder=\\\"no\\\" framespacing=\\\"0\\\" allowfullscreen=\\\"true\\\"> </iframe>\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>Hi, I am Jason Yang.</strong></p>\n<p><strong>I love technology, software architecture, java and various interesting technologies.</strong></p>\n<iframe src=\"//player.bilibili.com/player.html?aid=467482684&bvid=BV11L411w7Kt&cid=554594001&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe><!--kg-card-end: markdown-->","comment_id":"61aceebe1fb64e0001fdd026","plaintext":"Hi, I am Jason Yang.\n\nI love technology, software architecture, java and various interesting\ntechnologies.","feature_image":null,"featured":0,"type":"page","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-05 16:54:22","created_by":"1","updated_at":"2022-04-02 17:32:11","updated_by":"1","published_at":"2021-12-05 16:55:05","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b017eb664800012e4fcb","uuid":"ea43ecf6-0c8d-42a3-b829-cd3e65da51c1","title":"Nginx 502 connect failed(13: Permission denied) while connecting to upstream","slug":"nginx-502-permission-denied-solution","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n## Problem\\n\\n```shell\\n502 error\\n\\n2021/12/14 22:52:13 [crit] 9524#0: *22859 connect() to 127.0.0.1:2368 failed (13: Permission denied) while connecting to upstream, client: 111.30.182.61, server: nocoder.org, request: \\\"GET /dfs-maze/ HTTP/1.1\\\", upstream: \\\"http://127.0.0.1:2368/dfs-maze/\\\", host: \\\"nocoder.org\\\"\\n```\\n\\n## Solution\\n\\nTemporarily effective\\n\\n```shell\\nsetenforce 0\\n```\\n\\nor permanently effective after reboot\\n\\n```shell\\nvim /etc/selinux/config\\n\\nSELINUX=disabled\\n```\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><h2 id=\"problem\">Problem</h2>\n<pre><code class=\"language-shell\">502 error\n\n2021/12/14 22:52:13 [crit] 9524#0: *22859 connect() to 127.0.0.1:2368 failed (13: Permission denied) while connecting to upstream, client: 111.30.182.61, server: nocoder.org, request: &quot;GET /dfs-maze/ HTTP/1.1&quot;, upstream: &quot;http://127.0.0.1:2368/dfs-maze/&quot;, host: &quot;nocoder.org&quot;\n</code></pre>\n<h2 id=\"solution\">Solution</h2>\n<p>Temporarily effective</p>\n<pre><code class=\"language-shell\">setenforce 0\n</code></pre>\n<p>or permanently effective after reboot</p>\n<pre><code class=\"language-shell\">vim /etc/selinux/config\n\nSELINUX=disabled\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"61b8b017eb664800012e4fcb","plaintext":"Problem\n502 error\n\n2021/12/14 22:52:13 [crit] 9524#0: *22859 connect() to 127.0.0.1:2368 failed (13: Permission denied) while connecting to upstream, client: 111.30.182.61, server: nocoder.org, request: \"GET /dfs-maze/ HTTP/1.1\", upstream: \"http://127.0.0.1:2368/dfs-maze/\", host: \"nocoder.org\"\n\n\nSolution\nTemporarily effective\n\nsetenforce 0\n\n\nor permanently effective after reboot\n\nvim /etc/selinux/config\n\nSELINUX=disabled","feature_image":"__GHOST_URL__/content/images/2021/12/NGINX-logo-rgb-large.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 14:54:15","created_by":"1","updated_at":"2022-03-20 13:57:31","updated_by":"1","published_at":"2021-12-14 15:06:04","published_by":"1","custom_excerpt":"Permission denied while connecting to upstream.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b44feb664800012e5007","uuid":"a682e3f9-b9b6-4a81-ac16-ddec14d75895","title":"Java8 lambda表达式10个示例","slug":"java8-lambdabiao-da-shi-10ge-shi-li","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n> 本文由 ImportNew - lemeilleur 翻译自 javarevisited。欢迎加入翻译小组。转载请见文末要求。\\n\\nJava 8 刚于几周前发布，日期是2014年3月18日，这次开创性的发布在Java社区引发了不少讨论，并让大家感到激动。特性之一便是随同发布的lambda表达式，它将允许我们将行为传到函数里。在Java 8之前，如果想将行为传入函数，仅有的选择就是匿名类，需要6行代码。而定义行为最重要的那行代码，却混在中间不够突出。Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码。这样有时可读性更好，表达更清晰。在Java生态系统中，函数式表达与对面向对象的全面支持是个激动人心的进步。将进一步促进并行第三方库的发展，充分利用多核CPU。尽管业界需要时间来消化Java 8，但我认为任何严谨的Java开发者都不应忽视此次Java发布的核心特性，即lambda表达式、函数式接口、流API、默认方法和新的Date以及Time API。作为开发人员，我发现学习和掌握lambda表达式的最佳方法就是勇于尝试，尽可能多练习lambda表达式例子。鉴于受Java 8发布的影响最大的是Java集合框架（Java Collections framework），所以最好练习流API和lambda表达式，用于对列表（Lists）和集合（Collections）数据进行提取、过滤和排序。我一直在进行关于Java 8的写作，过去也曾分享过一些资源来帮助大家掌握Java 8。本文分享在代码中最有用的10个lambda表达式的使用方法，这些例子都短小精悍，将帮助你快速学会lambda表达式。\\n\\n##Java 8 lambda表达式示例\\n\\n我个人对Java 8发布非常激动，尤其是lambda表达式和流API。越来越多的了解它们，我能写出更干净的代码。虽然一开始并不是这样。第一次看到用lambda表达式写出来的Java代码时，我对这种神秘的语法感到非常失望，认为它们把Java搞得不可读，但我错了。花了一天时间做了一些lambda表达式和流API示例的练习后，我开心的看到了更清晰的Java代码。这有点像学习泛型，第一次见的时候我很讨厌它。我甚至继续使用老版Java 1.4来处理集合，直到有一天，朋友跟我介绍了使用泛型的好处（才意识到它的好处）。所以基本立场就是，不要畏惧lambda表达式以及方法引用的神秘语法，做几次练习，从集合类中提取、过滤数据之后，你就会喜欢上它。下面让我们开启学习Java 8 lambda表达式的学习之旅吧，首先从简单例子开始。\\n\\n###例1、用lambda表达式实现Runnable\\n我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -> {}代码块替代了整个匿名类。\\n```java\\n// Java 8之前：\\nnew Thread(new Runnable() {\\n    @Override\\n    public void run() {\\n    System.out.println(\\\"Before Java8, too much code for too little to do\\\");\\n    }\\n}).start();\\n\\n//Java 8方式：\\nnew Thread( () -> System.out.println(\\\"In Java8, Lambda expression rocks !!\\\") ).start();\\n\\n```\\n 输出\\n ```\\ntoo much code, for too little to do\\nLambda expression rocks !!\\n```\\n这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：\\n\\n```java\\n(params) -> expression\\n(params) -> statement\\n(params) -> { statements }\\n```\\n例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：\\n\\n```java\\n() -> System.out.println(\\\"Hello Lambda Expressions\\\");\\n```\\n如果你的方法接收两个参数，那么可以写成如下这样：\\n\\n```\\n(int even, int odd) -> even + odd\\n```\\n顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。\\n\\n###例2、使用Java 8 lambda表达式进行事件处理\\n如果你用过Swing API编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：\\n\\n```\\n// Java 8之前：\\nJButton show =  new JButton(\\\"Show\\\");\\nshow.addActionListener(new ActionListener() {\\n    @Override\\n    public void actionPerformed(ActionEvent e) {\\n    System.out.println(\\\"Event handling without lambda expression is boring\\\");\\n    }\\n});\\n```\\n\\n```\\n// Java 8方式：\\nshow.addActionListener((e) -> {\\n    System.out.println(\\\"Light, Camera, Action !! Lambda expressions Rocks\\\");\\n});\\n```\\nJava开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 Comparator。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 Runnable 和 ActionListener 的过程中的套路来做。\\n\\n###例3、使用lambda表达式对列表进行迭代\\n如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在使用lambda或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个 forEach()  方法，它可以迭代所有对象，并将你的lambda代码应用在其中。\\n\\n```\\n// Java 8之前：\\nList features = Arrays.asList(\\\"Lambdas\\\", \\\"Default Method\\\", \\\"Stream API\\\", \\\"Date and Time API\\\");\\nfor (String feature : features) {\\n    System.out.println(feature);\\n}\\n```\\n```\\n// Java 8之后：\\nList features = Arrays.asList(\\\"Lambdas\\\", \\\"Default Method\\\", \\\"Stream API\\\", \\\"Date and Time API\\\");\\nfeatures.forEach(n -> System.out.println(n));\\n \\n// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，\\n// 看起来像C++的作用域解析运算符\\nfeatures.forEach(System.out::println);\\n```\\n输出：\\n\\n```\\nLambdas\\nDefault Method\\nStream API\\nDate and Time API\\n```\\n列表循环的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。你可以看到C++里面的双冒号、范围解析操作符现在在Java 8中用来表示方法引用。\\n\\n###例4、使用lambda表达式和函数式接口Predicate\\n除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。下面是Java 8 Predicate 的例子，展示了过滤集合数据的多种常用方法。Predicate接口非常适用于做过滤。\\n```\\npublic static void main(args[]){\\n    List languages = Arrays.asList(\\\"Java\\\", \\\"Scala\\\", \\\"C++\\\", \\\"Haskell\\\", \\\"Lisp\\\");\\n \\n    System.out.println(\\\"Languages which starts with J :\\\");\\n    filter(languages, (str)->str.startsWith(\\\"J\\\"));\\n \\n    System.out.println(\\\"Languages which ends with a \\\");\\n    filter(languages, (str)->str.endsWith(\\\"a\\\"));\\n \\n    System.out.println(\\\"Print all languages :\\\");\\n    filter(languages, (str)->true);\\n \\n    System.out.println(\\\"Print no language : \\\");\\n    filter(languages, (str)->false);\\n \\n    System.out.println(\\\"Print language whose length greater than 4:\\\");\\n    filter(languages, (str)->str.length() > 4);\\n}\\n \\npublic static void filter(List names, Predicate condition) {\\n    for(String name: names)  {\\n        if(condition.test(name)) {\\n            System.out.println(name + \\\" \\\");\\n        }\\n    }\\n}\\n```\\n输出：\\n\\n```\\nLanguages which starts with J :\\nJava\\nLanguages which ends with a\\nJava\\nScala\\nPrint all languages :\\nJava\\nScala\\nC++\\nHaskell\\nLisp\\nPrint no language :\\nPrint language whose length greater than 4:\\nScala\\nHaskell\\n```\\n```\\n// 更好的办法\\npublic static void filter(List names, Predicate condition) {\\n    names.stream().filter((name) -> (condition.test(name))).forEach((name) -> {\\n        System.out.println(name + \\\" \\\");\\n    });\\n}\\n```\\n可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。\\n###例5、如何在lambda表达式中加入Predicate\\n\\n上个例子说到，java.util.function.Predicate 允许将两个或更多的 Predicate 合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。例如，要得到所有以J开始，长度为四个字母的语言，可以定义两个独立的 Predicate 示例分别表示每一个条件，然后用 Predicate.and() 方法将它们合并起来，如下所示：\\n\\n```\\n// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，\\n// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入\\nPredicate<String> startsWithJ = (n) -> n.startsWith(\\\"J\\\");\\nPredicate<String> fourLetterLong = (n) -> n.length() == 4;\\nnames.stream()\\n    .filter(startsWithJ.and(fourLetterLong))\\n    .forEach((n) -> System.out.print(\\\"nName, which starts with 'J' and four letter long is : \\\" + n));\\n```\\n类似地，也可以使用 or() 和 xor() 方法。本例着重介绍了如下要点：可按需要将 Predicate 作为单独条件然后将其合并起来使用。简而言之，你可以以传统Java命令方式使用 Predicate 接口，也可以充分利用lambda表达式达到事半功倍的效果。\\n\\n###例6、Java 8中使用lambda表达式的Map和Reduce示例\\n\\n本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -> x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。使用流API的收集器类，可以得到所有含税的开销。有 toList() 这样的方法将 map 或任何其他操作的结果合并起来。由于收集器在流上做终端操作，因此之后便不能重用流了。你甚至可以用流API的 reduce() 方法将所有数字合成一个，下一个例子将会讲到。\\n```\\n// 不使用lambda表达式为每个订单加上12%的税\\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\\nfor (Integer cost : costBeforeTax) {\\n    double price = cost + .12*cost;\\n    System.out.println(price);\\n}\\n \\n// 使用lambda表达式\\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\\ncostBeforeTax.stream().map((cost) -> cost + .12*cost).forEach(System.out::println);\\n```\\n输出：\\n```\\n112.0\\n224.0\\n336.0\\n448.0\\n560.0\\n112.0\\n224.0\\n336.0\\n448.0\\n560.0\\n```\\n###例6.2、Java 8中使用lambda表达式的Map和Reduce示例\\n在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用 reduce() 方法计算总和。\\n\\n```\\n// 为每个订单加上12%的税\\n// 老方法：\\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\\ndouble total = 0;\\nfor (Integer cost : costBeforeTax) {\\n    double price = cost + .12*cost;\\n    total = total + price;\\n}\\nSystem.out.println(\\\"Total : \\\" + total);\\n \\n// 新方法：\\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\\ndouble bill = costBeforeTax.stream().map((cost) -> cost + .12*cost).reduce((sum, cost) -> sum + cost).get();\\nSystem.out.println(\\\"Total : \\\" + bill);\\n```\\n输出：\\n\\n```\\nTotal : 1680.0\\nTotal : 1680.0\\n```\\n###例7、通过过滤创建一个String列表\\n\\n过滤是Java开发者在大规模集合上的一个常用操作，而现在使用lambda表达式和流API过滤大规模数据集合是惊人的简单。流提供了一个 filter() 方法，接受一个 Predicate 对象，即可以传入一个lambda表达式作为过滤逻辑。下面的例子是用lambda表达式过滤Java集合，将帮助理解。\\n\\n```\\n// 创建一个字符串列表，每个字符串长度大于2\\nList<String> filtered = strList.stream().filter(x -> x.length()> 2).collect(Collectors.toList());\\nSystem.out.printf(\\\"Original List : %s, filtered list : %s %n\\\", strList, filtered);\\n```\\n输出：\\n\\n```\\nOriginal List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]\\n```\\n另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。\\n\\n###例8、对列表的每个元素应用函数\\n\\n我们通常需要对列表的每个元素使用某个函数，例如逐一乘以某个数、除以某个数或者做其它操作。这些操作都很适合用 map() 方法，可以将转换逻辑以lambda表达式的形式放在 map() 方法里，就可以对集合的各个元素进行转换了，如下所示。\\n\\n```\\n// 将字符串换成大写并用逗号链接起来\\nList<String> G7 = Arrays.asList(\\\"USA\\\", \\\"Japan\\\", \\\"France\\\", \\\"Germany\\\", \\\"Italy\\\", \\\"U.K.\\\",\\\"Canada\\\");\\nString G7Countries = G7.stream().map(x -> x.toUpperCase()).collect(Collectors.joining(\\\", \\\"));\\nSystem.out.println(G7Countries);\\n```\\n输出：\\n```\\nUSA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA\\n```\\n###例9、复制不同的值，创建一个子列表\\n\\n本例展示了如何利用流的 distinct() 方法来对集合进行去重。\\n\\n```\\n// 用所有不同的数字创建一个正方形列表\\nList<Integer> numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);\\nList<Integer> distinct = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());\\nSystem.out.printf(\\\"Original List : %s,  Square Without duplicates : %s %n\\\", numbers, distinct);\\n```\\n输出：\\n\\n```\\nOriginal List : [9, 10, 3, 4, 7, 3, 4],  Square Without duplicates : [81, 100, 9, 16, 49]\\n```\\n###例10、计算集合元素的最大值、最小值、总和以及平均值\\n\\nIntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage() 方法来获得列表的所有元素的总和及平均值。\\n\\n```\\n//获取数字的个数、最小值、最大值、总和以及平均值\\nList<Integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\\nIntSummaryStatistics stats = primes.stream().mapToInt((x) -> x).summaryStatistics();\\nSystem.out.println(\\\"Highest prime number in List : \\\" + stats.getMax());\\nSystem.out.println(\\\"Lowest prime number in List : \\\" + stats.getMin());\\nSystem.out.println(\\\"Sum of all prime numbers : \\\" + stats.getSum());\\nSystem.out.println(\\\"Average of all prime numbers : \\\" + stats.getAverage());\\n```\\n输出：\\n```\\nHighest prime number in List : 29\\nLowest prime number in List : 2\\nSum of all prime numbers : 129\\nAverage of all prime numbers : 12.9\\n```\\nLambda表达式 vs 匿名类\\n\\n既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法。\\n\\nJava 8 Lambda表达式要点\\n\\n10个Java lambda表达式、流API示例\\n到目前为止我们看到了Java 8的10个lambda表达式，这对于新手来说是个合适的任务量，你可能需要亲自运行示例程序以便掌握。试着修改要求创建自己的例子，达到快速学习的目的。我还想建议大家使用Netbeans IDE来练习lambda表达式，它对Java 8支持良好。当把代码转换成函数式的时候，Netbeans会及时给你提示。只需跟着Netbeans的提示，就能很容易地把匿名类转换成lambda表达式。此外，如果你喜欢阅读，那么记得看一下Java 8的lambdas，实用函数式编程这本书（Java 8 Lambdas, pragmatic functional programming），作者是Richard Warburton，或者也可以看看Manning的Java 8实战（Java 8 in Action），这本书虽然还没出版，但我猜线上有第一章的免费pdf。不过，在你开始忙其它事情之前，先回顾一下Java 8的lambda表达式、默认方法和函数式接口的重点知识。\\n\\n1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。\\n\\n2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。\\n\\n```\\nlist.forEach(n -> System.out.println(n)); \\nlist.forEach(System.out::println);  // 使用方法引用\\n```\\n然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：\\n\\n```\\nlist.forEach((String s) -> System.out.println(\\\"*\\\" + s + \\\"*\\\"));\\n```\\n事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。\\n\\n3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。\\n\\n4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。\\n\\n5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：\\n\\n```\\nprivate static java.lang.Object lambda$0(java.lang.String);\\n```\\n6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。\\n\\n```\\nList<Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\\nint factor = 2;\\nprimes.forEach(element -> { factor++; });\\n```\\n```\\nCompile time error : \\\"local variables referenced from a lambda expression must be final or effectively final\\\"\\n```\\n另外，只是访问它而不作修改是可以的，如下所示：\\n\\n```\\nList<Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\\nint factor = 2;\\nprimes.forEach(element -> { System.out.println(factor*element); });\\n```\\n输出：\\n```\\n1\\n2\\n3\\n4\\n4\\n6\\n10\\n14\\n```\\n因此，它看起来更像不可变闭包，类似于Python。\\n\\n以上就是Java 8的lambda表达式的全部10个例子。此次修改将成为Java史上最大的一次，将深远影响未来Java开发者使用集合框架的方式。我想规模最相似的一次修改就是Java 5的发布了，它带来了很多优点，提升了代码质量，例如：泛型、枚举、自动装箱（Autoboxing）、静态导入、并发API和变量参数。上述特性使得Java代码更加清晰，我想lambda表达式也将进一步改进它。我在期待着开发并行第三方库，这可以使高性能应用变得更容易写。\\n\\n> 更多阅读：http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc\\n原文链接： javarevisited 翻译： ImportNew.com - lemeilleur\\n译文链接： http://www.importnew.com/16436.html\\n[ 转载请保留原文出处、译者和译文链接。]\\n作者： lemeilleur\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>本文由 ImportNew - lemeilleur 翻译自 javarevisited。欢迎加入翻译小组。转载请见文末要求。</p>\n</blockquote>\n<p>Java 8 刚于几周前发布，日期是2014年3月18日，这次开创性的发布在Java社区引发了不少讨论，并让大家感到激动。特性之一便是随同发布的lambda表达式，它将允许我们将行为传到函数里。在Java 8之前，如果想将行为传入函数，仅有的选择就是匿名类，需要6行代码。而定义行为最重要的那行代码，却混在中间不够突出。Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码。这样有时可读性更好，表达更清晰。在Java生态系统中，函数式表达与对面向对象的全面支持是个激动人心的进步。将进一步促进并行第三方库的发展，充分利用多核CPU。尽管业界需要时间来消化Java 8，但我认为任何严谨的Java开发者都不应忽视此次Java发布的核心特性，即lambda表达式、函数式接口、流API、默认方法和新的Date以及Time API。作为开发人员，我发现学习和掌握lambda表达式的最佳方法就是勇于尝试，尽可能多练习lambda表达式例子。鉴于受Java 8发布的影响最大的是Java集合框架（Java Collections framework），所以最好练习流API和lambda表达式，用于对列表（Lists）和集合（Collections）数据进行提取、过滤和排序。我一直在进行关于Java 8的写作，过去也曾分享过一些资源来帮助大家掌握Java 8。本文分享在代码中最有用的10个lambda表达式的使用方法，这些例子都短小精悍，将帮助你快速学会lambda表达式。</p>\n<h2 id=\"java-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B\">Java 8 lambda表达式示例</h2>\n<p>我个人对Java 8发布非常激动，尤其是lambda表达式和流API。越来越多的了解它们，我能写出更干净的代码。虽然一开始并不是这样。第一次看到用lambda表达式写出来的Java代码时，我对这种神秘的语法感到非常失望，认为它们把Java搞得不可读，但我错了。花了一天时间做了一些lambda表达式和流API示例的练习后，我开心的看到了更清晰的Java代码。这有点像学习泛型，第一次见的时候我很讨厌它。我甚至继续使用老版Java 1.4来处理集合，直到有一天，朋友跟我介绍了使用泛型的好处（才意识到它的好处）。所以基本立场就是，不要畏惧lambda表达式以及方法引用的神秘语法，做几次练习，从集合类中提取、过滤数据之后，你就会喜欢上它。下面让我们开启学习Java 8 lambda表达式的学习之旅吧，首先从简单例子开始。</p>\n<h3 id=\"%E4%BE%8B1%E3%80%81%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0runnable\">例1、用lambda表达式实现Runnable</h3>\n<p>我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -&gt; {}代码块替代了整个匿名类。</p>\n<pre><code class=\"language-java\">// Java 8之前：\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n    System.out.println(&quot;Before Java8, too much code for too little to do&quot;);\n    }\n}).start();\n\n//Java 8方式：\nnew Thread( () -&gt; System.out.println(&quot;In Java8, Lambda expression rocks !!&quot;) ).start();\n\n</code></pre>\n<p>输出</p>\n<pre><code>too much code, for too little to do\nLambda expression rocks !!\n</code></pre>\n<p>这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：</p>\n<pre><code class=\"language-java\">(params) -&gt; expression\n(params) -&gt; statement\n(params) -&gt; { statements }\n</code></pre>\n<p>例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：</p>\n<pre><code class=\"language-java\">() -&gt; System.out.println(&quot;Hello Lambda Expressions&quot;);\n</code></pre>\n<p>如果你的方法接收两个参数，那么可以写成如下这样：</p>\n<pre><code>(int even, int odd) -&gt; even + odd\n</code></pre>\n<p>顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。</p>\n<h3 id=\"%E4%BE%8B2%E3%80%81%E4%BD%BF%E7%94%A8java-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86\">例2、使用Java 8 lambda表达式进行事件处理</h3>\n<p>如果你用过Swing API编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：</p>\n<pre><code>// Java 8之前：\nJButton show =  new JButton(&quot;Show&quot;);\nshow.addActionListener(new ActionListener() {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n    System.out.println(&quot;Event handling without lambda expression is boring&quot;);\n    }\n});\n</code></pre>\n<pre><code>// Java 8方式：\nshow.addActionListener((e) -&gt; {\n    System.out.println(&quot;Light, Camera, Action !! Lambda expressions Rocks&quot;);\n});\n</code></pre>\n<p>Java开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 Comparator。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 Runnable 和 ActionListener 的过程中的套路来做。</p>\n<h3 id=\"%E4%BE%8B3%E3%80%81%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%B9%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3\">例3、使用lambda表达式对列表进行迭代</h3>\n<p>如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在使用lambda或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个 forEach()  方法，它可以迭代所有对象，并将你的lambda代码应用在其中。</p>\n<pre><code>// Java 8之前：\nList features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);\nfor (String feature : features) {\n    System.out.println(feature);\n}\n</code></pre>\n<pre><code>// Java 8之后：\nList features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);\nfeatures.forEach(n -&gt; System.out.println(n));\n \n// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，\n// 看起来像C++的作用域解析运算符\nfeatures.forEach(System.out::println);\n</code></pre>\n<p>输出：</p>\n<pre><code>Lambdas\nDefault Method\nStream API\nDate and Time API\n</code></pre>\n<p>列表循环的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。你可以看到C++里面的双冒号、范围解析操作符现在在Java 8中用来表示方法引用。</p>\n<h3 id=\"%E4%BE%8B4%E3%80%81%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3predicate\">例4、使用lambda表达式和函数式接口Predicate</h3>\n<p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。下面是Java 8 Predicate 的例子，展示了过滤集合数据的多种常用方法。Predicate接口非常适用于做过滤。</p>\n<pre><code>public static void main(args[]){\n    List languages = Arrays.asList(&quot;Java&quot;, &quot;Scala&quot;, &quot;C++&quot;, &quot;Haskell&quot;, &quot;Lisp&quot;);\n \n    System.out.println(&quot;Languages which starts with J :&quot;);\n    filter(languages, (str)-&gt;str.startsWith(&quot;J&quot;));\n \n    System.out.println(&quot;Languages which ends with a &quot;);\n    filter(languages, (str)-&gt;str.endsWith(&quot;a&quot;));\n \n    System.out.println(&quot;Print all languages :&quot;);\n    filter(languages, (str)-&gt;true);\n \n    System.out.println(&quot;Print no language : &quot;);\n    filter(languages, (str)-&gt;false);\n \n    System.out.println(&quot;Print language whose length greater than 4:&quot;);\n    filter(languages, (str)-&gt;str.length() &gt; 4);\n}\n \npublic static void filter(List names, Predicate condition) {\n    for(String name: names)  {\n        if(condition.test(name)) {\n            System.out.println(name + &quot; &quot;);\n        }\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>Languages which starts with J :\nJava\nLanguages which ends with a\nJava\nScala\nPrint all languages :\nJava\nScala\nC++\nHaskell\nLisp\nPrint no language :\nPrint language whose length greater than 4:\nScala\nHaskell\n</code></pre>\n<pre><code>// 更好的办法\npublic static void filter(List names, Predicate condition) {\n    names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; {\n        System.out.println(name + &quot; &quot;);\n    });\n}\n</code></pre>\n<p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。</p>\n<h3 id=\"%E4%BE%8B5%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%8A%A0%E5%85%A5predicate\">例5、如何在lambda表达式中加入Predicate</h3>\n<p>上个例子说到，java.util.function.Predicate 允许将两个或更多的 Predicate 合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。例如，要得到所有以J开始，长度为四个字母的语言，可以定义两个独立的 Predicate 示例分别表示每一个条件，然后用 Predicate.and() 方法将它们合并起来，如下所示：</p>\n<pre><code>// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，\n// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入\nPredicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(&quot;J&quot;);\nPredicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == 4;\nnames.stream()\n    .filter(startsWithJ.and(fourLetterLong))\n    .forEach((n) -&gt; System.out.print(&quot;nName, which starts with 'J' and four letter long is : &quot; + n));\n</code></pre>\n<p>类似地，也可以使用 or() 和 xor() 方法。本例着重介绍了如下要点：可按需要将 Predicate 作为单独条件然后将其合并起来使用。简而言之，你可以以传统Java命令方式使用 Predicate 接口，也可以充分利用lambda表达式达到事半功倍的效果。</p>\n<h3 id=\"%E4%BE%8B6%E3%80%81java-8%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84map%E5%92%8Creduce%E7%A4%BA%E4%BE%8B\">例6、Java 8中使用lambda表达式的Map和Reduce示例</h3>\n<p>本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -&gt; x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。使用流API的收集器类，可以得到所有含税的开销。有 toList() 这样的方法将 map 或任何其他操作的结果合并起来。由于收集器在流上做终端操作，因此之后便不能重用流了。你甚至可以用流API的 reduce() 方法将所有数字合成一个，下一个例子将会讲到。</p>\n<pre><code>// 不使用lambda表达式为每个订单加上12%的税\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\nfor (Integer cost : costBeforeTax) {\n    double price = cost + .12*cost;\n    System.out.println(price);\n}\n \n// 使用lambda表达式\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ncostBeforeTax.stream().map((cost) -&gt; cost + .12*cost).forEach(System.out::println);\n</code></pre>\n<p>输出：</p>\n<pre><code>112.0\n224.0\n336.0\n448.0\n560.0\n112.0\n224.0\n336.0\n448.0\n560.0\n</code></pre>\n<h3 id=\"%E4%BE%8B62%E3%80%81java-8%E4%B8%AD%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84map%E5%92%8Creduce%E7%A4%BA%E4%BE%8B\">例6.2、Java 8中使用lambda表达式的Map和Reduce示例</h3>\n<p>在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用 reduce() 方法计算总和。</p>\n<pre><code>// 为每个订单加上12%的税\n// 老方法：\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble total = 0;\nfor (Integer cost : costBeforeTax) {\n    double price = cost + .12*cost;\n    total = total + price;\n}\nSystem.out.println(&quot;Total : &quot; + total);\n \n// 新方法：\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();\nSystem.out.println(&quot;Total : &quot; + bill);\n</code></pre>\n<p>输出：</p>\n<pre><code>Total : 1680.0\nTotal : 1680.0\n</code></pre>\n<h3 id=\"%E4%BE%8B7%E3%80%81%E9%80%9A%E8%BF%87%E8%BF%87%E6%BB%A4%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAstring%E5%88%97%E8%A1%A8\">例7、通过过滤创建一个String列表</h3>\n<p>过滤是Java开发者在大规模集合上的一个常用操作，而现在使用lambda表达式和流API过滤大规模数据集合是惊人的简单。流提供了一个 filter() 方法，接受一个 Predicate 对象，即可以传入一个lambda表达式作为过滤逻辑。下面的例子是用lambda表达式过滤Java集合，将帮助理解。</p>\n<pre><code>// 创建一个字符串列表，每个字符串长度大于2\nList&lt;String&gt; filtered = strList.stream().filter(x -&gt; x.length()&gt; 2).collect(Collectors.toList());\nSystem.out.printf(&quot;Original List : %s, filtered list : %s %n&quot;, strList, filtered);\n</code></pre>\n<p>输出：</p>\n<pre><code>Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]\n</code></pre>\n<p>另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。</p>\n<h3 id=\"%E4%BE%8B8%E3%80%81%E5%AF%B9%E5%88%97%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%BA%94%E7%94%A8%E5%87%BD%E6%95%B0\">例8、对列表的每个元素应用函数</h3>\n<p>我们通常需要对列表的每个元素使用某个函数，例如逐一乘以某个数、除以某个数或者做其它操作。这些操作都很适合用 map() 方法，可以将转换逻辑以lambda表达式的形式放在 map() 方法里，就可以对集合的各个元素进行转换了，如下所示。</p>\n<pre><code>// 将字符串换成大写并用逗号链接起来\nList&lt;String&gt; G7 = Arrays.asList(&quot;USA&quot;, &quot;Japan&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, &quot;U.K.&quot;,&quot;Canada&quot;);\nString G7Countries = G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(&quot;, &quot;));\nSystem.out.println(G7Countries);\n</code></pre>\n<p>输出：</p>\n<pre><code>USA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA\n</code></pre>\n<h3 id=\"%E4%BE%8B9%E3%80%81%E5%A4%8D%E5%88%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%EF%BC%8C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E5%88%97%E8%A1%A8\">例9、复制不同的值，创建一个子列表</h3>\n<p>本例展示了如何利用流的 distinct() 方法来对集合进行去重。</p>\n<pre><code>// 用所有不同的数字创建一个正方形列表\nList&lt;Integer&gt; numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);\nList&lt;Integer&gt; distinct = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());\nSystem.out.printf(&quot;Original List : %s,  Square Without duplicates : %s %n&quot;, numbers, distinct);\n</code></pre>\n<p>输出：</p>\n<pre><code>Original List : [9, 10, 3, 4, 7, 3, 4],  Square Without duplicates : [81, 100, 9, 16, 49]\n</code></pre>\n<h3 id=\"%E4%BE%8B10%E3%80%81%E8%AE%A1%E7%AE%97%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E6%80%BB%E5%92%8C%E4%BB%A5%E5%8F%8A%E5%B9%B3%E5%9D%87%E5%80%BC\">例10、计算集合元素的最大值、最小值、总和以及平均值</h3>\n<p>IntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage() 方法来获得列表的所有元素的总和及平均值。</p>\n<pre><code>//获取数字的个数、最小值、最大值、总和以及平均值\nList&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\nIntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();\nSystem.out.println(&quot;Highest prime number in List : &quot; + stats.getMax());\nSystem.out.println(&quot;Lowest prime number in List : &quot; + stats.getMin());\nSystem.out.println(&quot;Sum of all prime numbers : &quot; + stats.getSum());\nSystem.out.println(&quot;Average of all prime numbers : &quot; + stats.getAverage());\n</code></pre>\n<p>输出：</p>\n<pre><code>Highest prime number in List : 29\nLowest prime number in List : 2\nSum of all prime numbers : 129\nAverage of all prime numbers : 12.9\n</code></pre>\n<p>Lambda表达式 vs 匿名类</p>\n<p>既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法。</p>\n<p>Java 8 Lambda表达式要点</p>\n<p>10个Java lambda表达式、流API示例<br>\n到目前为止我们看到了Java 8的10个lambda表达式，这对于新手来说是个合适的任务量，你可能需要亲自运行示例程序以便掌握。试着修改要求创建自己的例子，达到快速学习的目的。我还想建议大家使用Netbeans IDE来练习lambda表达式，它对Java 8支持良好。当把代码转换成函数式的时候，Netbeans会及时给你提示。只需跟着Netbeans的提示，就能很容易地把匿名类转换成lambda表达式。此外，如果你喜欢阅读，那么记得看一下Java 8的lambdas，实用函数式编程这本书（Java 8 Lambdas, pragmatic functional programming），作者是Richard Warburton，或者也可以看看Manning的Java 8实战（Java 8 in Action），这本书虽然还没出版，但我猜线上有第一章的免费pdf。不过，在你开始忙其它事情之前，先回顾一下Java 8的lambda表达式、默认方法和函数式接口的重点知识。</p>\n<p>1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。</p>\n<p>2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。</p>\n<pre><code>list.forEach(n -&gt; System.out.println(n)); \nlist.forEach(System.out::println);  // 使用方法引用\n</code></pre>\n<p>然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：</p>\n<pre><code>list.forEach((String s) -&gt; System.out.println(&quot;*&quot; + s + &quot;*&quot;));\n</code></pre>\n<p>事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。</p>\n<p>3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</p>\n<p>4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。</p>\n<p>5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：</p>\n<pre><code>private static java.lang.Object lambda$0(java.lang.String);\n</code></pre>\n<p>6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。</p>\n<pre><code>List&lt;Integer&gt; primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -&gt; { factor++; });\n</code></pre>\n<pre><code>Compile time error : &quot;local variables referenced from a lambda expression must be final or effectively final&quot;\n</code></pre>\n<p>另外，只是访问它而不作修改是可以的，如下所示：</p>\n<pre><code>List&lt;Integer&gt; primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -&gt; { System.out.println(factor*element); });\n</code></pre>\n<p>输出：</p>\n<pre><code>1\n2\n3\n4\n4\n6\n10\n14\n</code></pre>\n<p>因此，它看起来更像不可变闭包，类似于Python。</p>\n<p>以上就是Java 8的lambda表达式的全部10个例子。此次修改将成为Java史上最大的一次，将深远影响未来Java开发者使用集合框架的方式。我想规模最相似的一次修改就是Java 5的发布了，它带来了很多优点，提升了代码质量，例如：泛型、枚举、自动装箱（Autoboxing）、静态导入、并发API和变量参数。上述特性使得Java代码更加清晰，我想lambda表达式也将进一步改进它。我在期待着开发并行第三方库，这可以使高性能应用变得更容易写。</p>\n<blockquote>\n<p>更多阅读：<a href=\"http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc\">http://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc</a><br>\n原文链接： javarevisited 翻译： ImportNew.com - lemeilleur<br>\n译文链接： <a href=\"http://www.importnew.com/16436.html\">http://www.importnew.com/16436.html</a><br>\n[ 转载请保留原文出处、译者和译文链接。]<br>\n作者： lemeilleur</p>\n</blockquote>\n<!--kg-card-end: markdown-->","comment_id":"61b8b44feb664800012e5007","plaintext":"> 本文由 ImportNew - lemeilleur 翻译自 javarevisited。欢迎加入翻译小组。转载请见文末要求。\n\n\nJava 8\n刚于几周前发布，日期是2014年3月18日，这次开创性的发布在Java社区引发了不少讨论，并让大家感到激动。特性之一便是随同发布的lambda表达式，它将允许我们将行为传到函数里。在Java\n8之前，如果想将行为传入函数，仅有的选择就是匿名类，需要6行代码。而定义行为最重要的那行代码，却混在中间不够突出。Lambda表达式取代了匿名类，取消了模板，允许用函数式风格编写代码。这样有时可读性更好，表达更清晰。在Java生态系统中，函数式表达与对面向对象的全面支持是个激动人心的进步。将进一步促进并行第三方库的发展，充分利用多核CPU。尽管业界需要时间来消化Java\n8，但我认为任何严谨的Java开发者都不应忽视此次Java发布的核心特性，即lambda表达式、函数式接口、流API、默认方法和新的Date以及Time\nAPI。作为开发人员，我发现学习和掌握lambda表达式的最佳方法就是勇于尝试，尽可能多练习lambda表达式例子。鉴于受Java\n8发布的影响最大的是Java集合框架（Java Collections\nframework），所以最好练习流API和lambda表达式，用于对列表（Lists）和集合（Collections）数据进行提取、过滤和排序。我一直在进行关于Java\n8的写作，过去也曾分享过一些资源来帮助大家掌握Java\n8。本文分享在代码中最有用的10个lambda表达式的使用方法，这些例子都短小精悍，将帮助你快速学会lambda表达式。\n\nJava 8 lambda表达式示例\n我个人对Java\n8发布非常激动，尤其是lambda表达式和流API。越来越多的了解它们，我能写出更干净的代码。虽然一开始并不是这样。第一次看到用lambda表达式写出来的Java代码时，我对这种神秘的语法感到非常失望，认为它们把Java搞得不可读，但我错了。花了一天时间做了一些lambda表达式和流API示例的练习后，我开心的看到了更清晰的Java代码。这有点像学习泛型，第一次见的时候我很讨厌它。我甚至继续使用老版Java\n1.4来处理集合，直到有一天，朋友跟我介绍了使用泛型的好处（才意识到它的好处）。所以基本立场就是，不要畏惧lambda表达式以及方法引用的神秘语法，做几次练习，从集合类中提取、过滤数据之后，你就会喜欢上它。下面让我们开启学习Java\n8 lambda表达式的学习之旅吧，首先从简单例子开始。\n\n例1、用lambda表达式实现Runnable\n我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java\n8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -> {}代码块替代了整个匿名类。\n\n// Java 8之前：\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n    System.out.println(\"Before Java8, too much code for too little to do\");\n    }\n}).start();\n\n//Java 8方式：\nnew Thread( () -> System.out.println(\"In Java8, Lambda expression rocks !!\") ).start();\n\n\n\n输出\n\ntoo much code, for too little to do\nLambda expression rocks !!\n\n\n这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：\n\n(params) -> expression\n(params) -> statement\n(params) -> { statements }\n\n\n例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：\n\n() -> System.out.println(\"Hello Lambda Expressions\");\n\n\n如果你的方法接收两个参数，那么可以写成如下这样：\n\n(int even, int odd) -> even + odd\n\n\n顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。\n\n例2、使用Java 8 lambda表达式进行事件处理\n如果你用过Swing\nAPI编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：\n\n// Java 8之前：\nJButton show =  new JButton(\"Show\");\nshow.addActionListener(new ActionListener() {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n    System.out.println(\"Event handling without lambda expression is boring\");\n    }\n});\n\n\n// Java 8方式：\nshow.addActionListener((e) -> {\n    System.out.println(\"Light, Camera, Action !! Lambda expressions Rocks\");\n});\n\n\nJava开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 Comparator。在Java\n8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 Runnable 和\nActionListener 的过程中的套路来做。\n\n例3、使用lambda表达式对列表进行迭代\n如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java\n8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在使用lambda或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个\nforEach() 方法，它可以迭代所有对象，并将你的lambda代码应用在其中。\n\n// Java 8之前：\nList features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");\nfor (String feature : features) {\n    System.out.println(feature);\n}\n\n\n// Java 8之后：\nList features = Arrays.asList(\"Lambdas\", \"Default Method\", \"Stream API\", \"Date and Time API\");\nfeatures.forEach(n -> System.out.println(n));\n \n// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，\n// 看起来像C++的作用域解析运算符\nfeatures.forEach(System.out::println);\n\n\n输出：\n\nLambdas\nDefault Method\nStream API\nDate and Time API\n\n\n列表循环的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。你可以看到C++里面的双冒号、范围解析操作符现在在Java\n8中用来表示方法引用。\n\n例4、使用lambda表达式和函数式接口Predicate\n除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做\njava.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用\njava.util.function.Predicate\n函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。下面是Java 8 Predicate\n的例子，展示了过滤集合数据的多种常用方法。Predicate接口非常适用于做过滤。\n\npublic static void main(args[]){\n    List languages = Arrays.asList(\"Java\", \"Scala\", \"C++\", \"Haskell\", \"Lisp\");\n \n    System.out.println(\"Languages which starts with J :\");\n    filter(languages, (str)->str.startsWith(\"J\"));\n \n    System.out.println(\"Languages which ends with a \");\n    filter(languages, (str)->str.endsWith(\"a\"));\n \n    System.out.println(\"Print all languages :\");\n    filter(languages, (str)->true);\n \n    System.out.println(\"Print no language : \");\n    filter(languages, (str)->false);\n \n    System.out.println(\"Print language whose length greater than 4:\");\n    filter(languages, (str)->str.length() > 4);\n}\n \npublic static void filter(List names, Predicate condition) {\n    for(String name: names)  {\n        if(condition.test(name)) {\n            System.out.println(name + \" \");\n        }\n    }\n}\n\n\n输出：\n\nLanguages which starts with J :\nJava\nLanguages which ends with a\nJava\nScala\nPrint all languages :\nJava\nScala\nC++\nHaskell\nLisp\nPrint no language :\nPrint language whose length greater than 4:\nScala\nHaskell\n\n\n// 更好的办法\npublic static void filter(List names, Predicate condition) {\n    names.stream().filter((name) -> (condition.test(name))).forEach((name) -> {\n        System.out.println(name + \" \");\n    });\n}\n\n\n可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter()\n方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。\n\n例5、如何在lambda表达式中加入Predicate\n上个例子说到，java.util.function.Predicate 允许将两个或更多的 Predicate\n合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter()\n方法的条件合并起来。例如，要得到所有以J开始，长度为四个字母的语言，可以定义两个独立的 Predicate 示例分别表示每一个条件，然后用\nPredicate.and() 方法将它们合并起来，如下所示：\n\n// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，\n// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入\nPredicate<String> startsWithJ = (n) -> n.startsWith(\"J\");\nPredicate<String> fourLetterLong = (n) -> n.length() == 4;\nnames.stream()\n    .filter(startsWithJ.and(fourLetterLong))\n    .forEach((n) -> System.out.print(\"nName, which starts with 'J' and four letter long is : \" + n));\n\n\n类似地，也可以使用 or() 和 xor() 方法。本例着重介绍了如下要点：可按需要将 Predicate\n作为单独条件然后将其合并起来使用。简而言之，你可以以传统Java命令方式使用 Predicate 接口，也可以充分利用lambda表达式达到事半功倍的效果。\n\n例6、Java 8中使用lambda表达式的Map和Reduce示例\n本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x\n-> x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach()\n将列表元素打印出来。使用流API的收集器类，可以得到所有含税的开销。有 toList() 这样的方法将 map\n或任何其他操作的结果合并起来。由于收集器在流上做终端操作，因此之后便不能重用流了。你甚至可以用流API的 reduce()\n方法将所有数字合成一个，下一个例子将会讲到。\n\n// 不使用lambda表达式为每个订单加上12%的税\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\nfor (Integer cost : costBeforeTax) {\n    double price = cost + .12*cost;\n    System.out.println(price);\n}\n \n// 使用lambda表达式\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ncostBeforeTax.stream().map((cost) -> cost + .12*cost).forEach(System.out::println);\n\n\n输出：\n\n112.0\n224.0\n336.0\n448.0\n560.0\n112.0\n224.0\n336.0\n448.0\n560.0\n\n\n例6.2、Java 8中使用lambda表达式的Map和Reduce示例\n在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce()\n函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce\n并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce\n操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似\naverage()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble()\n方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用\nreduce() 方法计算总和。\n\n// 为每个订单加上12%的税\n// 老方法：\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble total = 0;\nfor (Integer cost : costBeforeTax) {\n    double price = cost + .12*cost;\n    total = total + price;\n}\nSystem.out.println(\"Total : \" + total);\n \n// 新方法：\nList costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);\ndouble bill = costBeforeTax.stream().map((cost) -> cost + .12*cost).reduce((sum, cost) -> sum + cost).get();\nSystem.out.println(\"Total : \" + bill);\n\n\n输出：\n\nTotal : 1680.0\nTotal : 1680.0\n\n\n例7、通过过滤创建一个String列表\n过滤是Java开发者在大规模集合上的一个常用操作，而现在使用lambda表达式和流API过滤大规模数据集合是惊人的简单。流提供了一个 filter()\n方法，接受一个 Predicate 对象，即可以传入一个lambda表达式作为过滤逻辑。下面的例子是用lambda表达式过滤Java集合，将帮助理解。\n\n// 创建一个字符串列表，每个字符串长度大于2\nList<String> filtered = strList.stream().filter(x -> x.length()> 2).collect(Collectors.toList());\nSystem.out.printf(\"Original List : %s, filtered list : %s %n\", strList, filtered);\n\n\n输出：\n\nOriginal List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]\n\n\n另外，关于 filter()\n方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。\n\n例8、对列表的每个元素应用函数\n我们通常需要对列表的每个元素使用某个函数，例如逐一乘以某个数、除以某个数或者做其它操作。这些操作都很适合用 map()\n方法，可以将转换逻辑以lambda表达式的形式放在 map() 方法里，就可以对集合的各个元素进行转换了，如下所示。\n\n// 将字符串换成大写并用逗号链接起来\nList<String> G7 = Arrays.asList(\"USA\", \"Japan\", \"France\", \"Germany\", \"Italy\", \"U.K.\",\"Canada\");\nString G7Countries = G7.stream().map(x -> x.toUpperCase()).collect(Collectors.joining(\", \"));\nSystem.out.println(G7Countries);\n\n\n输出：\n\nUSA, JAPAN, FRANCE, GERMANY, ITALY, U.K., CANADA\n\n\n例9、复制不同的值，创建一个子列表\n本例展示了如何利用流的 distinct() 方法来对集合进行去重。\n\n// 用所有不同的数字创建一个正方形列表\nList<Integer> numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);\nList<Integer> distinct = numbers.stream().map( i -> i*i).distinct().collect(Collectors.toList());\nSystem.out.printf(\"Original List : %s,  Square Without duplicates : %s %n\", numbers, distinct);\n\n\n输出：\n\nOriginal List : [9, 10, 3, 4, 7, 3, 4],  Square Without duplicates : [81, 100, 9, 16, 49]\n\n\n例10、计算集合元素的最大值、最小值、总和以及平均值\nIntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回\nIntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic\ns，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage()\n方法来获得列表的所有元素的总和及平均值。\n\n//获取数字的个数、最小值、最大值、总和以及平均值\nList<Integer> primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);\nIntSummaryStatistics stats = primes.stream().mapToInt((x) -> x).summaryStatistics();\nSystem.out.println(\"Highest prime number in List : \" + stats.getMax());\nSystem.out.println(\"Lowest prime number in List : \" + stats.getMin());\nSystem.out.println(\"Sum of all prime numbers : \" + stats.getSum());\nSystem.out.println(\"Average of all prime numbers : \" + stats.getAverage());\n\n\n输出：\n\nHighest prime number in List : 29\nLowest prime number in List : 2\nSum of all prime numbers : 129\nAverage of all prime numbers : 12.9\n\n\nLambda表达式 vs 匿名类\n\n既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this\n关键字指向匿名类，而lambda表达式的 this\n关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的\ninvokedynamic 字节码指令来动态绑定这个方法。\n\nJava 8 Lambda表达式要点\n\n10个Java lambda表达式、流API示例\n到目前为止我们看到了Java\n8的10个lambda表达式，这对于新手来说是个合适的任务量，你可能需要亲自运行示例程序以便掌握。试着修改要求创建自己的例子，达到快速学习的目的。我还想建议大家使用Netbeans\nIDE来练习lambda表达式，它对Java\n8支持良好。当把代码转换成函数式的时候，Netbeans会及时给你提示。只需跟着Netbeans的提示，就能很容易地把匿名类转换成lambda表达式。此外，如果你喜欢阅读，那么记得看一下Java\n8的lambdas，实用函数式编程这本书（Java 8 Lambdas, pragmatic functional\nprogramming），作者是Richard Warburton，或者也可以看看Manning的Java 8实战（Java 8 in\nAction），这本书虽然还没出版，但我猜线上有第一章的免费pdf。不过，在你开始忙其它事情之前，先回顾一下Java\n8的lambda表达式、默认方法和函数式接口的重点知识。\n\n1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single\nAbstract Method\n单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者\nCallable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如\nPredicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。\n\n2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。\n\nlist.forEach(n -> System.out.println(n)); \nlist.forEach(System.out::println);  // 使用方法引用\n\n\n然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：\n\nlist.forEach((String s) -> System.out.println(\"*\" + s + \"*\"));\n\n\n事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。\n\n3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。\n\n4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。\n\n5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap\n工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：\n\nprivate static java.lang.Object lambda$0(java.lang.String);\n\n\n6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。\n\nList<Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -> { factor++; });\n\n\nCompile time error : \"local variables referenced from a lambda expression must be final or effectively final\"\n\n\n另外，只是访问它而不作修改是可以的，如下所示：\n\nList<Integer> primes = Arrays.asList(new Integer[]{2, 3,5,7});\nint factor = 2;\nprimes.forEach(element -> { System.out.println(factor*element); });\n\n\n输出：\n\n1\n2\n3\n4\n4\n6\n10\n14\n\n\n因此，它看起来更像不可变闭包，类似于Python。\n\n以上就是Java\n8的lambda表达式的全部10个例子。此次修改将成为Java史上最大的一次，将深远影响未来Java开发者使用集合框架的方式。我想规模最相似的一次修改就是Java\n5的发布了，它带来了很多优点，提升了代码质量，例如：泛型、枚举、自动装箱（Autoboxing）、静态导入、并发API和变量参数。上述特性使得Java代码更加清晰，我想lambda表达式也将进一步改进它。我在期待着开发并行第三方库，这可以使高性能应用变得更容易写。\n\n> 更多阅读：\nhttp://javarevisited.blogspot.com/2014/02/10-example-of-lambda-expressions-in-java8.html#ixzz3gCMp6Vhc\n原文链接： javarevisited 翻译： ImportNew.com - lemeilleur\n译文链接： http://www.importnew.com/16436.html\n[ 转载请保留原文出处、译者和译文链接。]\n作者： lemeilleur","feature_image":"__GHOST_URL__/content/images/2021/12/java-2.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:12:15","created_by":"1","updated_at":"2021-12-14 15:51:20","updated_by":"1","published_at":"2017-06-09 21:36:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b4ddeb664800012e5019","uuid":"2eacc9bd-dd4a-4610-96d0-6982e44a2678","title":"20条数据库设计最佳实践","slug":"20tiao-shu-ju-ku-she-ji-zui-jia-shi-jian","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n> 翻译自 https://dzone.com/articles/20-database-design-best\\n\\n1. 对`table`和`column`使用明确定义的单词并且风格一致的命名。\\n2. 表名使用单数（例如：使用`StudentCourse` 而不是`StudentCourses`），`table`代表着一个实体的集合，不需要用复数命名。\\n3. 表名不要用空格，否则，您将不得不使用`'{'，'['，'''`等字符来定义表，访问时还需要用引号`“Student Course”`， 直接用`StudentCourse`会更好。\\n4. 表名不要使用不必要的前缀或者后缀，例如使用`School`而不是`TblSchool, SchoolTable`。\\n5. 保持密码的安全性，需要用的时候在程序里解密\\n6. 所有表使用`integer`类型ID字段。 即使暂时不需要ID，将来也可能会需要，例如关联表，索引等。\\n7. 索引选择`integer`类型的列，`varchar`列索引会引起性能问题。\\n8. 使用位字段存储布尔值，使用`integer`或`varchar`是不必要的存储消耗。布尔值的字段列命名使用`is`作为前缀。\\n9. 提供数据库访问权限，不要把管理员权限分配给所有人。\\n10. 尽量避免出现select * 查询除非必须需要，使用select [需要的列]可以提高查询效率。\\n11. 如果应用程序代码足够大，则使用`ORM（object relational mapping）`框架（例如` hibernate`，`MyBatis` ...）。ORM框架的性能问题可以通过详细的配置参数来处理。\\n12. 将大表、不用的表或很少使用的表，部分划分到不同的物理存储区以提高查询性能。\\n13. 对于大型，敏感和任务评论者数据库系统，使用灾难恢复和安全服务，如故障转移群集，自动备份，复制等。\\n14.  使用约束（外键，检查，非空...）来保证数据的完整性。 不要把所有的控制权都交给程序代码处理。\\n15. 缺乏数据库文档是非常可恶的。 用ER图和说明文档来记录数据库设计。 也为触发器，存储过程和其他脚本编写注释行。\\n16. 在大表上经常使用的查询创建索引。 分析工具可以用来确定需要定义哪些索引。 对于多行数据的查询，聚簇索引通常更好。 对于点查询，非聚集索引通常更好。\\n17. 数据库服务器和Web服务器必须放置在不同的机器上。 这将提供更高的安全性（攻击者无法直接访问数据），并且由于请求数量和进程使用率降低，服务器CPU和内存性能会更好。\\n18. 由于性能问题，不得在频繁查询的表中定义图像和`Blob`数据列。 这些数据必须放在单独的表中，并且它们的指针可以在查询的表中使用。\\n19. 标准化必须根据需要使用，以优化性能。 欠规范化会导致数据的过度重复，过度规范化会导致太多表中的过多连接。两者都会影响性能。\\n20. 一定要为数据库设计留足够的时间，否则可能会花费比设计多成百上千倍的时间来维护设计不佳的数据库甚至需要重新设计。\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>翻译自 <a href=\"https://dzone.com/articles/20-database-design-best\">https://dzone.com/articles/20-database-design-best</a></p>\n</blockquote>\n<ol>\n<li>对<code>table</code>和<code>column</code>使用明确定义的单词并且风格一致的命名。</li>\n<li>表名使用单数（例如：使用<code>StudentCourse</code> 而不是<code>StudentCourses</code>），<code>table</code>代表着一个实体的集合，不需要用复数命名。</li>\n<li>表名不要用空格，否则，您将不得不使用<code>'{'，'['，'''</code>等字符来定义表，访问时还需要用引号<code>“Student Course”</code>， 直接用<code>StudentCourse</code>会更好。</li>\n<li>表名不要使用不必要的前缀或者后缀，例如使用<code>School</code>而不是<code>TblSchool, SchoolTable</code>。</li>\n<li>保持密码的安全性，需要用的时候在程序里解密</li>\n<li>所有表使用<code>integer</code>类型ID字段。 即使暂时不需要ID，将来也可能会需要，例如关联表，索引等。</li>\n<li>索引选择<code>integer</code>类型的列，<code>varchar</code>列索引会引起性能问题。</li>\n<li>使用位字段存储布尔值，使用<code>integer</code>或<code>varchar</code>是不必要的存储消耗。布尔值的字段列命名使用<code>is</code>作为前缀。</li>\n<li>提供数据库访问权限，不要把管理员权限分配给所有人。</li>\n<li>尽量避免出现select * 查询除非必须需要，使用select [需要的列]可以提高查询效率。</li>\n<li>如果应用程序代码足够大，则使用<code>ORM（object relational mapping）</code>框架（例如<code> hibernate</code>，<code>MyBatis</code> ...）。ORM框架的性能问题可以通过详细的配置参数来处理。</li>\n<li>将大表、不用的表或很少使用的表，部分划分到不同的物理存储区以提高查询性能。</li>\n<li>对于大型，敏感和任务评论者数据库系统，使用灾难恢复和安全服务，如故障转移群集，自动备份，复制等。</li>\n<li>使用约束（外键，检查，非空...）来保证数据的完整性。 不要把所有的控制权都交给程序代码处理。</li>\n<li>缺乏数据库文档是非常可恶的。 用ER图和说明文档来记录数据库设计。 也为触发器，存储过程和其他脚本编写注释行。</li>\n<li>在大表上经常使用的查询创建索引。 分析工具可以用来确定需要定义哪些索引。 对于多行数据的查询，聚簇索引通常更好。 对于点查询，非聚集索引通常更好。</li>\n<li>数据库服务器和Web服务器必须放置在不同的机器上。 这将提供更高的安全性（攻击者无法直接访问数据），并且由于请求数量和进程使用率降低，服务器CPU和内存性能会更好。</li>\n<li>由于性能问题，不得在频繁查询的表中定义图像和<code>Blob</code>数据列。 这些数据必须放在单独的表中，并且它们的指针可以在查询的表中使用。</li>\n<li>标准化必须根据需要使用，以优化性能。 欠规范化会导致数据的过度重复，过度规范化会导致太多表中的过多连接。两者都会影响性能。</li>\n<li>一定要为数据库设计留足够的时间，否则可能会花费比设计多成百上千倍的时间来维护设计不佳的数据库甚至需要重新设计。</li>\n</ol>\n<!--kg-card-end: markdown-->","comment_id":"61b8b4ddeb664800012e5019","plaintext":"> 翻译自 https://dzone.com/articles/20-database-design-best\n\n\n 1.  对table和column使用明确定义的单词并且风格一致的命名。\n 2.  表名使用单数（例如：使用StudentCourse 而不是StudentCourses），table代表着一个实体的集合，不需要用复数命名。\n 3.  表名不要用空格，否则，您将不得不使用'{'，'['，'''等字符来定义表，访问时还需要用引号“Student Course”， 直接用\n     StudentCourse会更好。\n 4.  表名不要使用不必要的前缀或者后缀，例如使用School而不是TblSchool, SchoolTable。\n 5.  保持密码的安全性，需要用的时候在程序里解密\n 6.  所有表使用integer类型ID字段。 即使暂时不需要ID，将来也可能会需要，例如关联表，索引等。\n 7.  索引选择integer类型的列，varchar列索引会引起性能问题。\n 8.  使用位字段存储布尔值，使用integer或varchar是不必要的存储消耗。布尔值的字段列命名使用is作为前缀。\n 9.  提供数据库访问权限，不要把管理员权限分配给所有人。\n 10. 尽量避免出现select * 查询除非必须需要，使用select [需要的列]可以提高查询效率。\n 11. 如果应用程序代码足够大，则使用ORM（object relational mapping）框架（例如 hibernate，MyBatis \n     ...）。ORM框架的性能问题可以通过详细的配置参数来处理。\n 12. 将大表、不用的表或很少使用的表，部分划分到不同的物理存储区以提高查询性能。\n 13. 对于大型，敏感和任务评论者数据库系统，使用灾难恢复和安全服务，如故障转移群集，自动备份，复制等。\n 14. 使用约束（外键，检查，非空...）来保证数据的完整性。 不要把所有的控制权都交给程序代码处理。\n 15. 缺乏数据库文档是非常可恶的。 用ER图和说明文档来记录数据库设计。 也为触发器，存储过程和其他脚本编写注释行。\n 16. 在大表上经常使用的查询创建索引。 分析工具可以用来确定需要定义哪些索引。 对于多行数据的查询，聚簇索引通常更好。 对于点查询，非聚集索引通常更好。\n 17. 数据库服务器和Web服务器必须放置在不同的机器上。\n     这将提供更高的安全性（攻击者无法直接访问数据），并且由于请求数量和进程使用率降低，服务器CPU和内存性能会更好。\n 18. 由于性能问题，不得在频繁查询的表中定义图像和Blob数据列。 这些数据必须放在单独的表中，并且它们的指针可以在查询的表中使用。\n 19. 标准化必须根据需要使用，以优化性能。 欠规范化会导致数据的过度重复，过度规范化会导致太多表中的过多连接。两者都会影响性能。\n 20. 一定要为数据库设计留足够的时间，否则可能会花费比设计多成百上千倍的时间来维护设计不佳的数据库甚至需要重新设计。","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:14:37","created_by":"1","updated_at":"2021-12-14 15:16:00","updated_by":"1","published_at":"2018-06-12 22:29:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b55ceb664800012e5028","uuid":"e0344f85-33df-4367-8432-75a0fe9a10c4","title":"Apache Commons Codec 加密解密","slug":"apache-commons-codec-jia-mi-jie-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\nApache Commons Codec 提供了常见的编码器和解码器，如Base64，Hex等。\\n\\n以下是使用Base64进行加密和解密示例代码：\\n```java\\npackage org.nocoder.utils;\\n\\nimport org.apache.commons.codec.binary.Base64;\\nimport org.apache.commons.lang3.StringUtils;\\n\\n/**\\n * EncryptUtil\\n * Created by jason on 2017/7/18.\\n */\\npublic class EncryptUtil {\\n\\n    /**\\n     * 加密\\n     * @param value\\n     * @return encode string value\\n     */\\n    public static String encode(String value){\\n        if(StringUtils.isNotBlank(value)){\\n            Base64 base64 = new Base64();\\n            return new String(base64.encode(value.getBytes()));\\n        }\\n        return null;\\n    }\\n\\n    /**\\n     * 解密\\n     * @param value\\n     * @return decode string value\\n     */\\n    public static String decode(String value){\\n        if(StringUtils.isNotBlank(value)){\\n            Base64 base64 = new Base64();\\n            return new String(base64.decode(value.getBytes()));\\n        }\\n        return null;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(EncryptUtil.encode(\\\"test\\\"));\\n        System.out.println(EncryptUtil.decode(\\\"dGVzdA==\\\"));\\n    }\\n}\\n\\n```\\nApache Commons Codec 官方网址：http://commons.apache.org/proper/commons-codec/\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>Apache Commons Codec 提供了常见的编码器和解码器，如Base64，Hex等。</p>\n<p>以下是使用Base64进行加密和解密示例代码：</p>\n<pre><code class=\"language-java\">package org.nocoder.utils;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * EncryptUtil\n * Created by jason on 2017/7/18.\n */\npublic class EncryptUtil {\n\n    /**\n     * 加密\n     * @param value\n     * @return encode string value\n     */\n    public static String encode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.encode(value.getBytes()));\n        }\n        return null;\n    }\n\n    /**\n     * 解密\n     * @param value\n     * @return decode string value\n     */\n    public static String decode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.decode(value.getBytes()));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(EncryptUtil.encode(&quot;test&quot;));\n        System.out.println(EncryptUtil.decode(&quot;dGVzdA==&quot;));\n    }\n}\n\n</code></pre>\n<p>Apache Commons Codec 官方网址：<a href=\"http://commons.apache.org/proper/commons-codec/\">http://commons.apache.org/proper/commons-codec/</a></p>\n<!--kg-card-end: markdown-->","comment_id":"61b8b55ceb664800012e5028","plaintext":"Apache Commons Codec 提供了常见的编码器和解码器，如Base64，Hex等。\n\n以下是使用Base64进行加密和解密示例代码：\n\npackage org.nocoder.utils;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * EncryptUtil\n * Created by jason on 2017/7/18.\n */\npublic class EncryptUtil {\n\n    /**\n     * 加密\n     * @param value\n     * @return encode string value\n     */\n    public static String encode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.encode(value.getBytes()));\n        }\n        return null;\n    }\n\n    /**\n     * 解密\n     * @param value\n     * @return decode string value\n     */\n    public static String decode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.decode(value.getBytes()));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(EncryptUtil.encode(\"test\"));\n        System.out.println(EncryptUtil.decode(\"dGVzdA==\"));\n    }\n}\n\n\n\nApache Commons Codec 官方网址：http://commons.apache.org/proper/commons-codec/","feature_image":"__GHOST_URL__/content/images/2021/12/java-1.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:16:44","created_by":"1","updated_at":"2021-12-14 15:51:07","updated_by":"1","published_at":"2017-07-18 15:52:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b5a6eb664800012e5036","uuid":"955c0aec-0102-41c4-bcdf-4883b5bd4faa","title":"windows下把exe程序注册成服务","slug":"windowsxia-ba-execheng-xu-zhu-ce-cheng-fu-wu","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n1、下载instsrv.exe和srvany.exe这两个文件，放在`C:\\\\WINDOWS\\\\SysWOW64`目录下\\n\\n2、管理员权限运行命令提示符，进入`C:\\\\WINDOWS\\\\SysWOW64`目录\\n\\n```bash\\n# 使用instsrv.exe将srvany.exe注册成服务,中间的srvany是服务名，完成后使用services.msc可以在服务列表里看到\\ninstsrv.exe srvany srvany.exe\\n```\\n\\n3、命令提示符`regedit`，打开注册表编辑器，找到刚刚注册的服务目录\\n\\n```bash\\n计算机\\\\HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\srvany\\n```\\n\\n在目录下新建一个项`Parameters`，在`Parameters`下新建一个`字符串值`，数值名称为`Application`，数值数据为可执行文件的路径，例如`D:\\\\\\\\local\\\\\\\\IntelliJIDEA_LicenseServer.exe`\\n\\n4、命令提示符`services.msc`，找到`srvany`服务启动即可\\n\\nGame Over！\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>1、下载instsrv.exe和srvany.exe这两个文件，放在<code>C:\\WINDOWS\\SysWOW64</code>目录下</p>\n<p>2、管理员权限运行命令提示符，进入<code>C:\\WINDOWS\\SysWOW64</code>目录</p>\n<pre><code class=\"language-bash\"># 使用instsrv.exe将srvany.exe注册成服务,中间的srvany是服务名，完成后使用services.msc可以在服务列表里看到\ninstsrv.exe srvany srvany.exe\n</code></pre>\n<p>3、命令提示符<code>regedit</code>，打开注册表编辑器，找到刚刚注册的服务目录</p>\n<pre><code class=\"language-bash\">计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\srvany\n</code></pre>\n<p>在目录下新建一个项<code>Parameters</code>，在<code>Parameters</code>下新建一个<code>字符串值</code>，数值名称为<code>Application</code>，数值数据为可执行文件的路径，例如<code>D:\\\\local\\\\IntelliJIDEA_LicenseServer.exe</code></p>\n<p>4、命令提示符<code>services.msc</code>，找到<code>srvany</code>服务启动即可</p>\n<p>Game Over！</p>\n<!--kg-card-end: markdown-->","comment_id":"61b8b5a6eb664800012e5036","plaintext":"1、下载instsrv.exe和srvany.exe这两个文件，放在C:\\WINDOWS\\SysWOW64目录下\n\n2、管理员权限运行命令提示符，进入C:\\WINDOWS\\SysWOW64目录\n\n# 使用instsrv.exe将srvany.exe注册成服务,中间的srvany是服务名，完成后使用services.msc可以在服务列表里看到\ninstsrv.exe srvany srvany.exe\n\n\n3、命令提示符regedit，打开注册表编辑器，找到刚刚注册的服务目录\n\n计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\srvany\n\n\n在目录下新建一个项Parameters，在Parameters下新建一个字符串值，数值名称为Application，数值数据为可执行文件的路径，例如\nD:\\\\local\\\\IntelliJIDEA_LicenseServer.exe\n\n4、命令提示符services.msc，找到srvany服务启动即可\n\nGame Over！","feature_image":"__GHOST_URL__/content/images/2021/12/windows.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:17:58","created_by":"1","updated_at":"2021-12-14 15:53:35","updated_by":"1","published_at":"2017-12-07 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b5feeb664800012e5040","uuid":"750953a7-3b53-4a16-b548-71d0f0637932","title":"StrongLoop compare with pm2 and Forever","slug":"strongloop-compare-with-pm2-and-forever","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n\\n| Feature                          | StrongLoop Process Manager                               | pm2                                                     | Forever                    |\\n| -------------------------------- | -------------------------------------------------------- | ------------------------------------------------------- | -------------------------- |\\n| Run app locally                  | slc start                                                | pm2 start app.js -name foo                              | forever start app.js       |\\n| Restart on failure               | Yes                                                      | Yes                                                     | Yes                        |\\n| Graceful/rolling restarts        | Available                                                | Available                                               | No                         |\\n| OS startup script support        | Yes                                                      | Yes                                                     | No                         |\\n| Security                         | HTTP auth and HTTP+SSH                                   | SSH only for deploy                                     | No                         |\\n| Set environment variables        | Available on install and with slc ctl env-set command    | Available as part of ecosystem configuration            | No                         |\\n| Log aggregation/rotation         | Yes; log file and syslog                                 | Yes; multihost, with rotation. Log file only; no syslog | No                         |\\n| Multiple app support             | Manages multiple local or remote apps                    | Manages multiple local or remote apps                   | Manage multiple local apps |\\n| Language Support                 | Node only                                                | Can run any script file                                 | Can run any script file    |\\n| Build & Deploy                   |                                                          |                                                         |                            |\\n| Build and package repositories   | Supports Git and npm-pack based builds                   | No                                                      | No                         |\\n| Deploy apps to Docker container  | Yes                                                      | No                                                      | No                         |\\n| Remote deploy                    | Yes                                                      | Yes                                                     | No                         |\\n| Multiple deploys/revert          | Deploys over SSH, HTTP.  Revert any previous deployment. | Deploys over SSH, revert to previous deployment         | No                         |\\n| Clustering & Management          |                                                          |                                                         |                            |\\n| Clustering                       | Available                                                | Available                                               | No                         |\\n| Resize clusters                  | At deploy-time, start-time, and runtime                  | At deploy-time and start-time only                      | No                         |\\n| Manage remotely                  | Deploy over SSH+HTTP Manage over REST (+SSH)             | Deploy over SSH                                         | No                         |\\n| Load balancer auto-configuration | Yes                                                      | No                                                      | No                         |\\n| Profiling                        |                                                          |                                                         |                            |\\n| Profiling                        | Heap and CPU profiles                                    | No                                                      | No                         |\\n| Profile triggering               | Trigger profiling based on slow event loop               | No                                                      | No                         |\\n| Metrics                          |                                                          |                                                         |                            |\\n| Metrics                          | CPU, memory, database, NoSQL connectors, many others     | CPU, memory, stack traces reported on error output      | No                         |\\n| Integrate with external metrics  | Yes: StatsD, graphite, Splunk, etc.                      | keymetrics.io only                                      | No                         |\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>StrongLoop Process Manager</th>\n<th>pm2</th>\n<th>Forever</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Run app locally</td>\n<td>slc start</td>\n<td>pm2 start app.js -name foo</td>\n<td>forever start app.js</td>\n</tr>\n<tr>\n<td>Restart on failure</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Graceful/rolling restarts</td>\n<td>Available</td>\n<td>Available</td>\n<td>No</td>\n</tr>\n<tr>\n<td>OS startup script support</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Security</td>\n<td>HTTP auth and HTTP+SSH</td>\n<td>SSH only for deploy</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Set environment variables</td>\n<td>Available on install and with slc ctl env-set command</td>\n<td>Available as part of ecosystem configuration</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Log aggregation/rotation</td>\n<td>Yes; log file and syslog</td>\n<td>Yes; multihost, with rotation. Log file only; no syslog</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Multiple app support</td>\n<td>Manages multiple local or remote apps</td>\n<td>Manages multiple local or remote apps</td>\n<td>Manage multiple local apps</td>\n</tr>\n<tr>\n<td>Language Support</td>\n<td>Node only</td>\n<td>Can run any script file</td>\n<td>Can run any script file</td>\n</tr>\n<tr>\n<td>Build &amp; Deploy</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Build and package repositories</td>\n<td>Supports Git and npm-pack based builds</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Deploy apps to Docker container</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Remote deploy</td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Multiple deploys/revert</td>\n<td>Deploys over SSH, HTTP.  Revert any previous deployment.</td>\n<td>Deploys over SSH, revert to previous deployment</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Clustering &amp; Management</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Clustering</td>\n<td>Available</td>\n<td>Available</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Resize clusters</td>\n<td>At deploy-time, start-time, and runtime</td>\n<td>At deploy-time and start-time only</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Manage remotely</td>\n<td>Deploy over SSH+HTTP Manage over REST (+SSH)</td>\n<td>Deploy over SSH</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Load balancer auto-configuration</td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Profiling</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Profiling</td>\n<td>Heap and CPU profiles</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Profile triggering</td>\n<td>Trigger profiling based on slow event loop</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Metrics</td>\n<td>CPU, memory, database, NoSQL connectors, many others</td>\n<td>CPU, memory, stack traces reported on error output</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Integrate with external metrics</td>\n<td>Yes: StatsD, graphite, Splunk, etc.</td>\n<td>keymetrics.io only</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: markdown-->","comment_id":"61b8b5feeb664800012e5040","plaintext":"FeatureStrongLoop Process Managerpm2ForeverRun app locallyslc startpm2 start\napp.js -name fooforever start app.jsRestart on failureYesYesYesGraceful/rolling\nrestartsAvailableAvailableNoOS startup script supportYesYesNoSecurityHTTP auth\nand HTTP+SSHSSH only for deployNoSet environment variablesAvailable on install\nand with slc ctl env-set commandAvailable as part of ecosystem configurationNo\nLog aggregation/rotationYes; log file and syslogYes; multihost, with rotation.\nLog file only; no syslogNoMultiple app supportManages multiple local or remote\nappsManages multiple local or remote appsManage multiple local appsLanguage\nSupportNode onlyCan run any script fileCan run any script fileBuild & Deploy\nBuild and package repositoriesSupports Git and npm-pack based buildsNoNoDeploy\napps to Docker containerYesNoNoRemote deployYesYesNoMultiple deploys/revert\nDeploys over SSH, HTTP. Revert any previous deployment.Deploys over SSH, revert\nto previous deploymentNoClustering & ManagementClusteringAvailableAvailableNo\nResize clustersAt deploy-time, start-time, and runtimeAt deploy-time and\nstart-time onlyNoManage remotelyDeploy over SSH+HTTP Manage over REST (+SSH)\nDeploy over SSHNoLoad balancer auto-configurationYesNoNoProfilingProfilingHeap\nand CPU profilesNoNoProfile triggeringTrigger profiling based on slow event loop\nNoNoMetricsMetricsCPU, memory, database, NoSQL connectors, many othersCPU,\nmemory, stack traces reported on error outputNoIntegrate with external metrics\nYes: StatsD, graphite, Splunk, etc.keymetrics.io onlyNo","feature_image":"__GHOST_URL__/content/images/2021/12/pm2.20d3ef.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:19:26","created_by":"1","updated_at":"2021-12-14 15:46:45","updated_by":"1","published_at":"2018-06-12 15:02:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b64aeb664800012e504c","uuid":"0615878c-6c6c-4850-be67-71d75912354a","title":"策略模式","slug":"ce-lue-mo-shi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n\\n在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\\n\\n## 介绍\\n**意图**：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\\n**主要解决**：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\\n**何时使用**：一个系统有许多许多类，而区分它们的只是他们直接的行为。\\n**如何解决**：将这些算法封装成一个一个的类，任意地替换。\\n**关键代码**：实现同一个接口。\\n**应用实例**：\\n1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。\\n2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 \\n3、JAVA AWT 中的 LayoutManager。\\n**优点**： \\n1、算法可以自由切换。 \\n2、避免使用多重条件判断。 \\n3、扩展性良好。\\n**缺点**： \\n1、策略类会增多。 \\n2、所有策略类都需要对外暴露。\\n**使用场景**： \\n1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 \\n2、一个系统需要动态地在几种算法中选择一种。 \\n3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\\n**注意事项**：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\\n##实现\\n我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。\\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。\\n[](``)\\n\\n步骤 1\\n创建一个接口。\\nStrategy.java\\n```java\\npublic interface Strategy {\\n   public int doOperation(int num1, int num2);\\n}\\n```\\n步骤 2\\n创建实现接口的实体类。\\nOperationAdd.java\\n```java\\npublic class OperationAdd implements Strategy{\\n   @Override\\n   public int doOperation(int num1, int num2) {\\n      return num1 + num2;\\n   }\\n}\\n```\\nOperationSubstract.java\\n```java\\npublic class OperationSubstract implements Strategy{\\n   @Override\\n   public int doOperation(int num1, int num2) {\\n      return num1 - num2;\\n   }\\n}\\n```\\nOperationMultiply.java\\n```java\\npublic class OperationMultiply implements Strategy{\\n   @Override\\n   public int doOperation(int num1, int num2) {\\n      return num1 * num2;\\n   }\\n}\\n```\\n步骤 3\\n创建 Context 类。\\n```java\\nContext.java\\npublic class Context {\\n   private Strategy strategy;\\n\\n   public Context(Strategy strategy){\\n      this.strategy = strategy;\\n   }\\n\\n   public int executeStrategy(int num1, int num2){\\n      return strategy.doOperation(num1, num2);\\n   }\\n}\\n```\\n步骤 4\\n使用 Context 来查看当它改变策略 Strategy 时的行为变化。\\nStrategyPatternDemo.java\\n```java\\npublic class StrategyPatternDemo {\\n   public static void main(String[] args) {\\n      Context context = new Context(new OperationAdd());        \\n      System.out.println(\\\"10 + 5 = \\\" + context.executeStrategy(10, 5));\\n\\n      context = new Context(new OperationSubstract());        \\n      System.out.println(\\\"10 - 5 = \\\" + context.executeStrategy(10, 5));\\n\\n      context = new Context(new OperationMultiply());        \\n      System.out.println(\\\"10 * 5 = \\\" + context.executeStrategy(10, 5));\\n   }\\n}\\n```\\n步骤 5\\n验证输出。\\n```\\n10 + 5 = 15\\n10 - 5 = 5\\n10 * 5 = 50\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。<br>\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>\n<h2 id=\"%E4%BB%8B%E7%BB%8D\">介绍</h2>\n<p><strong>意图</strong>：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br>\n<strong>主要解决</strong>：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。<br>\n<strong>何时使用</strong>：一个系统有许多许多类，而区分它们的只是他们直接的行为。<br>\n<strong>如何解决</strong>：将这些算法封装成一个一个的类，任意地替换。<br>\n<strong>关键代码</strong>：实现同一个接口。<br>\n<strong>应用实例</strong>：<br>\n1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。<br>\n2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。<br>\n3、JAVA AWT 中的 LayoutManager。<br>\n<strong>优点</strong>：<br>\n1、算法可以自由切换。<br>\n2、避免使用多重条件判断。<br>\n3、扩展性良好。<br>\n<strong>缺点</strong>：<br>\n1、策略类会增多。<br>\n2、所有策略类都需要对外暴露。<br>\n<strong>使用场景</strong>：<br>\n1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>\n2、一个系统需要动态地在几种算法中选择一种。<br>\n3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。<br>\n<strong>注意事项</strong>：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>\n<h2 id=\"%E5%AE%9E%E7%8E%B0\">实现</h2>\n<p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。<br>\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。<br>\n<a href=\"%60%60\"></a></p>\n<p>步骤 1<br>\n创建一个接口。<br>\nStrategy.java</p>\n<pre><code class=\"language-java\">public interface Strategy {\n   public int doOperation(int num1, int num2);\n}\n</code></pre>\n<p>步骤 2<br>\n创建实现接口的实体类。<br>\nOperationAdd.java</p>\n<pre><code class=\"language-java\">public class OperationAdd implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 + num2;\n   }\n}\n</code></pre>\n<p>OperationSubstract.java</p>\n<pre><code class=\"language-java\">public class OperationSubstract implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 - num2;\n   }\n}\n</code></pre>\n<p>OperationMultiply.java</p>\n<pre><code class=\"language-java\">public class OperationMultiply implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 * num2;\n   }\n}\n</code></pre>\n<p>步骤 3<br>\n创建 Context 类。</p>\n<pre><code class=\"language-java\">Context.java\npublic class Context {\n   private Strategy strategy;\n\n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n\n   public int executeStrategy(int num1, int num2){\n      return strategy.doOperation(num1, num2);\n   }\n}\n</code></pre>\n<p>步骤 4<br>\n使用 Context 来查看当它改变策略 Strategy 时的行为变化。<br>\nStrategyPatternDemo.java</p>\n<pre><code class=\"language-java\">public class StrategyPatternDemo {\n   public static void main(String[] args) {\n      Context context = new Context(new OperationAdd());        \n      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));\n\n      context = new Context(new OperationSubstract());        \n      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));\n\n      context = new Context(new OperationMultiply());        \n      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));\n   }\n}\n</code></pre>\n<p>步骤 5<br>\n验证输出。</p>\n<pre><code>10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"61b8b64aeb664800012e504c","plaintext":"在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n\n介绍\n意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。\n应用实例：\n1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。\n2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。\n3、JAVA AWT 中的 LayoutManager。\n优点：\n1、算法可以自由切换。\n2、避免使用多重条件判断。\n3、扩展性良好。\n缺点：\n1、策略类会增多。\n2、所有策略类都需要对外暴露。\n使用场景：\n1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。\n2、一个系统需要动态地在几种算法中选择一种。\n3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n\n实现\n我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。\n[%60%60]\n\n步骤 1\n创建一个接口。\nStrategy.java\n\npublic interface Strategy {\n   public int doOperation(int num1, int num2);\n}\n\n\n步骤 2\n创建实现接口的实体类。\nOperationAdd.java\n\npublic class OperationAdd implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 + num2;\n   }\n}\n\n\nOperationSubstract.java\n\npublic class OperationSubstract implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 - num2;\n   }\n}\n\n\nOperationMultiply.java\n\npublic class OperationMultiply implements Strategy{\n   @Override\n   public int doOperation(int num1, int num2) {\n      return num1 * num2;\n   }\n}\n\n\n步骤 3\n创建 Context 类。\n\nContext.java\npublic class Context {\n   private Strategy strategy;\n\n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n\n   public int executeStrategy(int num1, int num2){\n      return strategy.doOperation(num1, num2);\n   }\n}\n\n\n步骤 4\n使用 Context 来查看当它改变策略 Strategy 时的行为变化。\nStrategyPatternDemo.java\n\npublic class StrategyPatternDemo {\n   public static void main(String[] args) {\n      Context context = new Context(new OperationAdd());        \n      System.out.println(\"10 + 5 = \" + context.executeStrategy(10, 5));\n\n      context = new Context(new OperationSubstract());        \n      System.out.println(\"10 - 5 = \" + context.executeStrategy(10, 5));\n\n      context = new Context(new OperationMultiply());        \n      System.out.println(\"10 * 5 = \" + context.executeStrategy(10, 5));\n   }\n}\n\n\n步骤 5\n验证输出。\n\n10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50","feature_image":"__GHOST_URL__/content/images/2021/12/Strategy_Pattern_in_UML.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:20:42","created_by":"1","updated_at":"2021-12-14 15:54:48","updated_by":"1","published_at":"2017-10-03 10:31:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b6b0eb664800012e5059","uuid":"996e6024-821e-4161-ade7-7dcdf84a9a76","title":"近期接触的技术点总结","slug":"jin-qi-jie-hong-de-ji-zhu-dian-zong-jie","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n> 花点时间总结一下来公司这些日子做的东西，自我感觉良好，跟着春哥学了不少东西，这半年还是很充实的。\\n> 记得有一次春哥笑着跟我说，“你要相信，别人能做出来的东西，你也可以。”\\n\\n### 架构设计\\n\\n- 领域驱动设计\\n- 分布式系统架构设计\\n\\n### 框架应用\\n\\n- eureka\\n- springboot\\n- alibaba oss\\n- alibaba canal应用\\n    - 伪装slave向mysql请求binlog，将分析结果发送到客户端，客户端获取到数据变更后，作相应数据的统计分析操作\\n- mysql\\n    - binlog\\n- elasticsearch\\n    - 全文检索，用于app搜索功能\\n- node.js\\n- vue\\n    - 前端框架\\n- pm2\\n    - 用于生产环境的nodejs server\\n\\n### CI/CD\\n\\n- jenkins pipeline\\n    - 从gitlab拉取项目源码\\n    - mvn命令打包，使用maven-dockerfile插件实现自动构建和上传到远程私有仓库\\n\\n### 容器应用\\n\\n- docker\\n    - 云图书馆所有java应用docker化\\n    - jenkins pipeline实现半自动化\\n    - docker-compose\\n\\n### 中间件\\n\\n- nginx\\n- kafka\\n\\n### 设计模式应用\\n\\n- 数据统计分析系统重构\\n\\t- 观察者模式\\n\\t- 责任链模式\\n\\t- 命令模式\\n- ARTS\\n\\t- 代理模式\\n\\t\\t- 静态代理\\n\\t\\t- 动态代理\\n\\t- 策略模式\\n\\n\\n### 操作系统\\n\\n- ubuntu\\n    - 了解到我的日常工作不用依赖于windows系统后，果断换了ubuntu，很爽\\n\\n### 工具\\n\\n- idea\\n- vscode \\n\\t- 很好用的编辑器，出自微软\\n- navicat\\n\\t- 数据库客户端\\n- xmind\\n\\t- 思维导图\\n- pycharm\\n\\t- python 编辑器\\n\\n\\n### 脚本语言\\n\\n- python \\n    - 写了一个清理docker image的小程序，从配置文件读取server信息，使用ssh登陆到server，执行shell命令\\n\\n### Java\\n\\n- 多线程\\n- 异常处理\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>花点时间总结一下来公司这些日子做的东西，自我感觉良好，跟着春哥学了不少东西，这半年还是很充实的。<br>\n记得有一次春哥笑着跟我说，“你要相信，别人能做出来的东西，你也可以。”</p>\n</blockquote>\n<h3 id=\"%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1\">架构设计</h3>\n<ul>\n<li>领域驱动设计</li>\n<li>分布式系统架构设计</li>\n</ul>\n<h3 id=\"%E6%A1%86%E6%9E%B6%E5%BA%94%E7%94%A8\">框架应用</h3>\n<ul>\n<li>eureka</li>\n<li>springboot</li>\n<li>alibaba oss</li>\n<li>alibaba canal应用\n<ul>\n<li>伪装slave向mysql请求binlog，将分析结果发送到客户端，客户端获取到数据变更后，作相应数据的统计分析操作</li>\n</ul>\n</li>\n<li>mysql\n<ul>\n<li>binlog</li>\n</ul>\n</li>\n<li>elasticsearch\n<ul>\n<li>全文检索，用于app搜索功能</li>\n</ul>\n</li>\n<li>node.js</li>\n<li>vue\n<ul>\n<li>前端框架</li>\n</ul>\n</li>\n<li>pm2\n<ul>\n<li>用于生产环境的nodejs server</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"cicd\">CI/CD</h3>\n<ul>\n<li>jenkins pipeline\n<ul>\n<li>从gitlab拉取项目源码</li>\n<li>mvn命令打包，使用maven-dockerfile插件实现自动构建和上传到远程私有仓库</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"%E5%AE%B9%E5%99%A8%E5%BA%94%E7%94%A8\">容器应用</h3>\n<ul>\n<li>docker\n<ul>\n<li>云图书馆所有java应用docker化</li>\n<li>jenkins pipeline实现半自动化</li>\n<li>docker-compose</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"%E4%B8%AD%E9%97%B4%E4%BB%B6\">中间件</h3>\n<ul>\n<li>nginx</li>\n<li>kafka</li>\n</ul>\n<h3 id=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8\">设计模式应用</h3>\n<ul>\n<li>数据统计分析系统重构\n<ul>\n<li>观察者模式</li>\n<li>责任链模式</li>\n<li>命令模式</li>\n</ul>\n</li>\n<li>ARTS\n<ul>\n<li>代理模式\n<ul>\n<li>静态代理</li>\n<li>动态代理</li>\n</ul>\n</li>\n<li>策略模式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\">操作系统</h3>\n<ul>\n<li>ubuntu\n<ul>\n<li>了解到我的日常工作不用依赖于windows系统后，果断换了ubuntu，很爽</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"%E5%B7%A5%E5%85%B7\">工具</h3>\n<ul>\n<li>idea</li>\n<li>vscode\n<ul>\n<li>很好用的编辑器，出自微软</li>\n</ul>\n</li>\n<li>navicat\n<ul>\n<li>数据库客户端</li>\n</ul>\n</li>\n<li>xmind\n<ul>\n<li>思维导图</li>\n</ul>\n</li>\n<li>pycharm\n<ul>\n<li>python 编辑器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80\">脚本语言</h3>\n<ul>\n<li>python\n<ul>\n<li>写了一个清理docker image的小程序，从配置文件读取server信息，使用ssh登陆到server，执行shell命令</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"java\">Java</h3>\n<ul>\n<li>多线程</li>\n<li>异常处理</li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"61b8b6b0eb664800012e5059","plaintext":"> 花点时间总结一下来公司这些日子做的东西，自我感觉良好，跟着春哥学了不少东西，这半年还是很充实的。\n记得有一次春哥笑着跟我说，“你要相信，别人能做出来的东西，你也可以。”\n\n\n架构设计\n * 领域驱动设计\n * 分布式系统架构设计\n\n框架应用\n * eureka\n * springboot\n * alibaba oss\n * alibaba canal应用 * 伪装slave向mysql请求binlog，将分析结果发送到客户端，客户端获取到数据变更后，作相应数据的统计分析操作\n   \n   \n * mysql * binlog\n   \n   \n * elasticsearch * 全文检索，用于app搜索功能\n   \n   \n * node.js\n * vue * 前端框架\n   \n   \n * pm2 * 用于生产环境的nodejs server\n   \n   \n\nCI/CD\n * jenkins pipeline * 从gitlab拉取项目源码\n    * mvn命令打包，使用maven-dockerfile插件实现自动构建和上传到远程私有仓库\n   \n   \n\n容器应用\n * docker * 云图书馆所有java应用docker化\n    * jenkins pipeline实现半自动化\n    * docker-compose\n   \n   \n\n中间件\n * nginx\n * kafka\n\n设计模式应用\n * 数据统计分析系统重构 * 观察者模式\n    * 责任链模式\n    * 命令模式\n   \n   \n * ARTS * 代理模式 * 静态代理\n       * 动态代理\n      \n      \n    * 策略模式\n   \n   \n\n操作系统\n * ubuntu * 了解到我的日常工作不用依赖于windows系统后，果断换了ubuntu，很爽\n   \n   \n\n工具\n * idea\n * vscode * 很好用的编辑器，出自微软\n   \n   \n * navicat * 数据库客户端\n   \n   \n * xmind * 思维导图\n   \n   \n * pycharm * python 编辑器\n   \n   \n\n脚本语言\n * python * 写了一个清理docker image的小程序，从配置文件读取server信息，使用ssh登陆到server，执行shell命令\n   \n   \n\nJava\n * 多线程\n * 异常处理","feature_image":"__GHOST_URL__/content/images/2021/12/Design-Thinking-1240x640-1024x529.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:22:24","created_by":"1","updated_at":"2021-12-14 15:47:42","updated_by":"1","published_at":"2018-09-29 07:06:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b6fceb664800012e5067","uuid":"c51ee0a8-420c-45a6-82bf-7b706adc40c1","title":"Running Your Spring Boot Application","slug":"running-your-spring-boot-application","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n\\nOne of the biggest advantages of packaging your application as a jar and using an embedded HTTP server is that you can run your application as you would any other. Debugging Spring Boot applications is also easy. You do not need any special IDE plugins or extensions.\\n\\n| ![[Note]](https://docs.spring.io/spring-boot/docs/current/reference/html/images/note.png) |\\n| ------------------------------------------------------------ |\\n| This section only covers jar based packaging. If you choose to package your application as a war file, you should refer to your server and IDE documentation. |\\n\\n## 19.1 Running from an IDE\\n\\nYou can run a Spring Boot application from your IDE as a simple Java application. However, you first need to import your project. Import steps vary depending on your IDE and build system. Most IDEs can import Maven projects directly. For example, Eclipse users can select `Import…` → `Existing Maven Projects` from the `File`menu.\\n\\nIf you cannot directly import your project into your IDE, you may be able to generate IDE metadata by using a build plugin. Maven includes plugins for [Eclipse](https://maven.apache.org/plugins/maven-eclipse-plugin/) and [IDEA](https://maven.apache.org/plugins/maven-idea-plugin/). Gradle offers plugins for [various IDEs](https://docs.gradle.org/4.2.1/userguide/userguide.html).\\n\\n| ![[Tip]](https://docs.spring.io/spring-boot/docs/current/reference/html/images/tip.png) |\\n| ------------------------------------------------------------ |\\n| If you accidentally run a web application twice, you see a “Port already in use” error. STS users can use the `Relaunch` button rather than the `Run` button to ensure that any existing instance is closed. |\\n\\n## 19.2 Running as a Packaged Application\\n\\nIf you use the Spring Boot Maven or Gradle plugins to create an executable jar, you can run your application using `java -jar`, as shown in the following example:\\n\\n```\\n$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar\\n```\\n\\nIt is also possible to run a packaged application with remote debugging support enabled. Doing so lets you attach a debugger to your packaged application, as shown in the following example:\\n\\n```\\n$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\\\\\n       -jar target/myapplication-0.0.1-SNAPSHOT.jar\\n```\\n\\n## 19.3 Using the Maven Plugin\\n\\nThe Spring Boot Maven plugin includes a `run` goal that can be used to quickly compile and run your application. Applications run in an exploded form, as they do in your IDE. The following example shows a typical Maven command to run a Spring Boot application:\\n\\n```\\n$ mvn spring-boot:run\\n```\\n\\nYou might also want to use the `MAVEN_OPTS` operating system environment variable, as shown in the following example:\\n\\n```\\n$ export MAVEN_OPTS=-Xmx1024m\\n```\\n\\n## 19.4 Using the Gradle Plugin\\n\\nThe Spring Boot Gradle plugin also includes a `bootRun` task that can be used to run your application in an exploded form. The `bootRun` task is added whenever you apply the `org.springframework.boot` and `java` plugins and is shown in the following example:\\n\\n```\\n$ gradle bootRun\\n```\\n\\nYou might also want to use the `JAVA_OPTS` operating system environment variable, as shown in the following example:\\n\\n```\\n$ export JAVA_OPTS=-Xmx1024m\\n```\\n\\n## 19.5 Hot Swapping\\n\\nSince Spring Boot applications are just plain Java applications, JVM hot-swapping should work out of the box. JVM hot swapping is somewhat limited with the bytecode that it can replace. For a more complete solution, [JRebel](https://zeroturnaround.com/software/jrebel/) can be used.\\n\\nThe `spring-boot-devtools` module also includes support for quick application restarts. See the [Chapter 20, *Developer Tools*](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html) section later in this chapter and the [Hot swapping “How-to”](https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html) for details.\\n\\n------\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>One of the biggest advantages of packaging your application as a jar and using an embedded HTTP server is that you can run your application as you would any other. Debugging Spring Boot applications is also easy. You do not need any special IDE plugins or extensions.</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://docs.spring.io/spring-boot/docs/current/reference/html/images/note.png\" alt=\"[Note]\" loading=\"lazy\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>This section only covers jar based packaging. If you choose to package your application as a war file, you should refer to your server and IDE documentation.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"191-running-from-an-ide\">19.1 Running from an IDE</h2>\n<p>You can run a Spring Boot application from your IDE as a simple Java application. However, you first need to import your project. Import steps vary depending on your IDE and build system. Most IDEs can import Maven projects directly. For example, Eclipse users can select <code>Import…</code> → <code>Existing Maven Projects</code> from the <code>File</code>menu.</p>\n<p>If you cannot directly import your project into your IDE, you may be able to generate IDE metadata by using a build plugin. Maven includes plugins for <a href=\"https://maven.apache.org/plugins/maven-eclipse-plugin/\">Eclipse</a> and <a href=\"https://maven.apache.org/plugins/maven-idea-plugin/\">IDEA</a>. Gradle offers plugins for <a href=\"https://docs.gradle.org/4.2.1/userguide/userguide.html\">various IDEs</a>.</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://docs.spring.io/spring-boot/docs/current/reference/html/images/tip.png\" alt=\"[Tip]\" loading=\"lazy\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>If you accidentally run a web application twice, you see a “Port already in use” error. STS users can use the <code>Relaunch</code> button rather than the <code>Run</code> button to ensure that any existing instance is closed.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"192-running-as-a-packaged-application\">19.2 Running as a Packaged Application</h2>\n<p>If you use the Spring Boot Maven or Gradle plugins to create an executable jar, you can run your application using <code>java -jar</code>, as shown in the following example:</p>\n<pre><code>$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar\n</code></pre>\n<p>It is also possible to run a packaged application with remote debugging support enabled. Doing so lets you attach a debugger to your packaged application, as shown in the following example:</p>\n<pre><code>$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\\n       -jar target/myapplication-0.0.1-SNAPSHOT.jar\n</code></pre>\n<h2 id=\"193-using-the-maven-plugin\">19.3 Using the Maven Plugin</h2>\n<p>The Spring Boot Maven plugin includes a <code>run</code> goal that can be used to quickly compile and run your application. Applications run in an exploded form, as they do in your IDE. The following example shows a typical Maven command to run a Spring Boot application:</p>\n<pre><code>$ mvn spring-boot:run\n</code></pre>\n<p>You might also want to use the <code>MAVEN_OPTS</code> operating system environment variable, as shown in the following example:</p>\n<pre><code>$ export MAVEN_OPTS=-Xmx1024m\n</code></pre>\n<h2 id=\"194-using-the-gradle-plugin\">19.4 Using the Gradle Plugin</h2>\n<p>The Spring Boot Gradle plugin also includes a <code>bootRun</code> task that can be used to run your application in an exploded form. The <code>bootRun</code> task is added whenever you apply the <code>org.springframework.boot</code> and <code>java</code> plugins and is shown in the following example:</p>\n<pre><code>$ gradle bootRun\n</code></pre>\n<p>You might also want to use the <code>JAVA_OPTS</code> operating system environment variable, as shown in the following example:</p>\n<pre><code>$ export JAVA_OPTS=-Xmx1024m\n</code></pre>\n<h2 id=\"195-hot-swapping\">19.5 Hot Swapping</h2>\n<p>Since Spring Boot applications are just plain Java applications, JVM hot-swapping should work out of the box. JVM hot swapping is somewhat limited with the bytecode that it can replace. For a more complete solution, <a href=\"https://zeroturnaround.com/software/jrebel/\">JRebel</a> can be used.</p>\n<p>The <code>spring-boot-devtools</code> module also includes support for quick application restarts. See the <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html\">Chapter 20, <em>Developer Tools</em></a> section later in this chapter and the <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html\">Hot swapping “How-to”</a> for details.</p>\n<hr>\n<!--kg-card-end: markdown-->","comment_id":"61b8b6fceb664800012e5067","plaintext":"One of the biggest advantages of packaging your application as a jar and using\nan embedded HTTP server is that you can run your application as you would any\nother. Debugging Spring Boot applications is also easy. You do not need any\nspecial IDE plugins or extensions.\n\nThis section only covers jar based packaging. If you choose to package your\napplication as a war file, you should refer to your server and IDE\ndocumentation.19.1 Running from an IDE\nYou can run a Spring Boot application from your IDE as a simple Java\napplication. However, you first need to import your project. Import steps vary\ndepending on your IDE and build system. Most IDEs can import Maven projects\ndirectly. For example, Eclipse users can select Import… → Existing Maven\nProjects from the Filemenu.\n\nIf you cannot directly import your project into your IDE, you may be able to\ngenerate IDE metadata by using a build plugin. Maven includes plugins for \nEclipse [https://maven.apache.org/plugins/maven-eclipse-plugin/] and IDEA\n[https://maven.apache.org/plugins/maven-idea-plugin/]. Gradle offers plugins for \nvarious IDEs [https://docs.gradle.org/4.2.1/userguide/userguide.html].\n\nIf you accidentally run a web application twice, you see a “Port already in use”\nerror. STS users can use the Relaunch button rather than the Run button to\nensure that any existing instance is closed.19.2 Running as a Packaged\nApplication\nIf you use the Spring Boot Maven or Gradle plugins to create an executable jar,\nyou can run your application using java -jar, as shown in the following example:\n\n$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar\n\n\nIt is also possible to run a packaged application with remote debugging support\nenabled. Doing so lets you attach a debugger to your packaged application, as\nshown in the following example:\n\n$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\\n       -jar target/myapplication-0.0.1-SNAPSHOT.jar\n\n\n19.3 Using the Maven Plugin\nThe Spring Boot Maven plugin includes a run goal that can be used to quickly\ncompile and run your application. Applications run in an exploded form, as they\ndo in your IDE. The following example shows a typical Maven command to run a\nSpring Boot application:\n\n$ mvn spring-boot:run\n\n\nYou might also want to use the MAVEN_OPTS operating system environment variable,\nas shown in the following example:\n\n$ export MAVEN_OPTS=-Xmx1024m\n\n\n19.4 Using the Gradle Plugin\nThe Spring Boot Gradle plugin also includes a bootRun task that can be used to\nrun your application in an exploded form. The bootRun task is added whenever you\napply the org.springframework.boot and java plugins and is shown in the\nfollowing example:\n\n$ gradle bootRun\n\n\nYou might also want to use the JAVA_OPTS operating system environment variable,\nas shown in the following example:\n\n$ export JAVA_OPTS=-Xmx1024m\n\n\n19.5 Hot Swapping\nSince Spring Boot applications are just plain Java applications, JVM\nhot-swapping should work out of the box. JVM hot swapping is somewhat limited\nwith the bytecode that it can replace. For a more complete solution, JRebel\n[https://zeroturnaround.com/software/jrebel/] can be used.\n\nThe spring-boot-devtools module also includes support for quick application\nrestarts. See the Chapter 20, Developer Tools\n[https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html] \nsection later in this chapter and the Hot swapping “How-to”\n[https://docs.spring.io/spring-boot/docs/current/reference/html/howto-hotswapping.html] \nfor details.\n\n\n--------------------------------------------------------------------------------","feature_image":"__GHOST_URL__/content/images/2021/12/spring-boot-logo-1-1.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:23:40","created_by":"1","updated_at":"2021-12-14 15:48:42","updated_by":"1","published_at":"2018-05-31 18:27:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b75beb664800012e5073","uuid":"9d5506a2-a7f3-45fe-bce7-bd5143cfee92","title":"反向代理","slug":"fan-xiang-dai-li","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n\\n> **反向代理**（Reverse Proxy）方式是指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\\n\\n举个例子，一个用户访问 [http://www.example.com/readme](http://www.example.com/readme)，但是 www.example.com 上并不存在 readme 页面，它是偷偷从另外一台服务器上取回来，然后作为自己的内容返回给用户。但是用户并不知情这个过程。对用户来说，就像是直接从 www.example.com 获取 readme 页面一样。这里所提到的 www.example.com 这个域名对应的服务器就设置了反向代理功能。\\n\\n反向代理服务器，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。如下图所示：\\n\\n![](https://raw.githubusercontent.com/jasonyang86/nocoder/master/data/images/201806/proxy.png)\\n\\n#### 反向代理典型应用场景\\n\\n反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问，加强安全防护。反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供 **缓冲** 服务。另外，反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。\\n\\nNginx 的其中一个用途是做 HTTP 反向代理，下面简单介绍 Nginx 作为反向代理服务器的方法。\\n\\n>场景描述：访问本地服务器上的 README.md 文件 [http://localhost/README.md](http://localhost/README.md)，本地服务器进行反向代理，从 [https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md](https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md) 获取页面内容。\\n\\n`nginx.conf` 配置示例：\\n\\n```nginx\\nworker_processes 1;\\n\\npid logs/nginx.pid;\\nerror_log logs/error.log warn;\\n\\nevents {\\n    worker_connections 3000;\\n}\\n\\nhttp {\\n    include mime.types;\\n    server_tokens off;\\n\\n\\t## 下面配置反向代理的参数\\n    server {\\n        listen    8866;\\n\\n        ## 1. 用户访问 http://ip:port，则反向代理到 https://github.com\\n        location / {\\n            proxy_pass  https://github.com;\\n            proxy_redirect     off;\\n            proxy_set_header   Host             $host;\\n            proxy_set_header   X-Real-IP        $remote_addr;\\n            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\\n        }\\n\\n        ## 2.用户访问 http://ip:port/README.md，则反向代理到\\n        ##   https://github.com/.../README.md\\n        location /README.md {\\n            proxy_set_header  X-Real-IP  $remote_addr;\\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\n            proxy_pass https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md;\\n        }\\n    }\\n}\\n```\\n\\n成功启动 Nginx 后，我们打开浏览器，验证下反向代理的效果。在浏览器地址栏中输入 `localhost/README.md`，返回的结果是我们 GitHub 源代码的 README 页面。如下图：\\n\\n![](https://raw.githubusercontent.com/moonbingbing/openresty-best-practices/master/images/proxy_example.png)\\n\\n我们只需要配置一下 `nginx.conf` 文件，不用写任何 web 页面，就可以偷偷地从别的服务器上读取一个页面返回给用户。\\n\\n下面我们来看一下 `nginx.conf` 里用到的配置项：\\n\\n(1) location\\n\\nlocation 项对请求 URI 进行匹配，location 后面配置了匹配规则。例如上面的例子中，如果请求的 URI 是 `localhost/`，则会匹配 `location /` 这一项；如果请求的 URI 是 `localhost/README.md`，则会匹配 `location /README.md` 这项。\\n\\n上面这个例子只是针对一个确定的 URI 做了反向代理，有的读者会有疑惑：如果对每个页面都进行这样的配置，那将会大量重复，能否做 **批量** 配置呢？此时需要配合使用 location 的正则匹配功能。具体实现方法可参考 Nginx 文档中 [关于 location 的描述](http://nginx.org/en/docs/http/ngx_http_core_module.html#location)。\\n\\n(2) proxy_pass\\n\\nproxy_pass 后面跟着一个 URL，用来将请求反向代理到 URL 参数指定的服务器上。例如我们上面例子中的 `proxy_pass https://github.com`，则将匹配的请求反向代理到 `https://github.com`。\\n\\n(3) proxy_set_header\\n\\n默认情况下，反向代理不会转发原始请求中的 Host 头部，如果需要转发，就需要加上这句：`proxy_set_header Host $host;`\\n\\n除了上面提到的常用配置项，还有 proxy_redirect、proxy_set_body、proxy_limit_rate 等参数，具体用法可以到[Nginx 官网](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)查看。\\n\\n#### 正向代理\\n\\n既然有反向代理，自然也有正向代理。简单来说，正向代理就像一个跳板，例如一个用户访问不了某网站（例如 `www.google.com`），但是他能访问一个代理服务器，这个代理服务器能访问 `www.google.com`，于是用户可以先连上代理服务器，告诉它需要访问的内容，代理服务器去取回来返回给用户。例如一些常见的翻墙工具、游戏代理就是利用正向代理的原理工作的，我们需要在这些正向代理工具上配置服务器的 IP 地址等信息。\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p><strong>反向代理</strong>（Reverse Proxy）方式是指用代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n</blockquote>\n<p>举个例子，一个用户访问 <a href=\"http://www.example.com/readme\">http://www.example.com/readme</a>，但是 www.example.com 上并不存在 readme 页面，它是偷偷从另外一台服务器上取回来，然后作为自己的内容返回给用户。但是用户并不知情这个过程。对用户来说，就像是直接从 www.example.com 获取 readme 页面一样。这里所提到的 www.example.com 这个域名对应的服务器就设置了反向代理功能。</p>\n<p>反向代理服务器，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/jasonyang86/nocoder/master/data/images/201806/proxy.png\" alt=\"\" loading=\"lazy\"></p>\n<h4 id=\"%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\">反向代理典型应用场景</h4>\n<p>反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问，加强安全防护。反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供 <strong>缓冲</strong> 服务。另外，反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。</p>\n<p>Nginx 的其中一个用途是做 HTTP 反向代理，下面简单介绍 Nginx 作为反向代理服务器的方法。</p>\n<blockquote>\n<p>场景描述：访问本地服务器上的 README.md 文件 <a href=\"http://localhost/README.md\">http://localhost/README.md</a>，本地服务器进行反向代理，从 <a href=\"https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md\">https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md</a> 获取页面内容。</p>\n</blockquote>\n<p><code>nginx.conf</code> 配置示例：</p>\n<pre><code class=\"language-nginx\">worker_processes 1;\n\npid logs/nginx.pid;\nerror_log logs/error.log warn;\n\nevents {\n    worker_connections 3000;\n}\n\nhttp {\n    include mime.types;\n    server_tokens off;\n\n\t## 下面配置反向代理的参数\n    server {\n        listen    8866;\n\n        ## 1. 用户访问 http://ip:port，则反向代理到 https://github.com\n        location / {\n            proxy_pass  https://github.com;\n            proxy_redirect     off;\n            proxy_set_header   Host             $host;\n            proxy_set_header   X-Real-IP        $remote_addr;\n            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n        }\n\n        ## 2.用户访问 http://ip:port/README.md，则反向代理到\n        ##   https://github.com/.../README.md\n        location /README.md {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md;\n        }\n    }\n}\n</code></pre>\n<p>成功启动 Nginx 后，我们打开浏览器，验证下反向代理的效果。在浏览器地址栏中输入 <code>localhost/README.md</code>，返回的结果是我们 GitHub 源代码的 README 页面。如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/moonbingbing/openresty-best-practices/master/images/proxy_example.png\" alt=\"\" loading=\"lazy\"></p>\n<p>我们只需要配置一下 <code>nginx.conf</code> 文件，不用写任何 web 页面，就可以偷偷地从别的服务器上读取一个页面返回给用户。</p>\n<p>下面我们来看一下 <code>nginx.conf</code> 里用到的配置项：</p>\n<p>(1) location</p>\n<p>location 项对请求 URI 进行匹配，location 后面配置了匹配规则。例如上面的例子中，如果请求的 URI 是 <code>localhost/</code>，则会匹配 <code>location /</code> 这一项；如果请求的 URI 是 <code>localhost/README.md</code>，则会匹配 <code>location /README.md</code> 这项。</p>\n<p>上面这个例子只是针对一个确定的 URI 做了反向代理，有的读者会有疑惑：如果对每个页面都进行这样的配置，那将会大量重复，能否做 <strong>批量</strong> 配置呢？此时需要配合使用 location 的正则匹配功能。具体实现方法可参考 Nginx 文档中 <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#location\">关于 location 的描述</a>。</p>\n<p>(2) proxy_pass</p>\n<p>proxy_pass 后面跟着一个 URL，用来将请求反向代理到 URL 参数指定的服务器上。例如我们上面例子中的 <code>proxy_pass https://github.com</code>，则将匹配的请求反向代理到 <code>https://github.com</code>。</p>\n<p>(3) proxy_set_header</p>\n<p>默认情况下，反向代理不会转发原始请求中的 Host 头部，如果需要转发，就需要加上这句：<code>proxy_set_header Host $host;</code></p>\n<p>除了上面提到的常用配置项，还有 proxy_redirect、proxy_set_body、proxy_limit_rate 等参数，具体用法可以到<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\">Nginx 官网</a>查看。</p>\n<h4 id=\"%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86\">正向代理</h4>\n<p>既然有反向代理，自然也有正向代理。简单来说，正向代理就像一个跳板，例如一个用户访问不了某网站（例如 <code>www.google.com</code>），但是他能访问一个代理服务器，这个代理服务器能访问 <code>www.google.com</code>，于是用户可以先连上代理服务器，告诉它需要访问的内容，代理服务器去取回来返回给用户。例如一些常见的翻墙工具、游戏代理就是利用正向代理的原理工作的，我们需要在这些正向代理工具上配置服务器的 IP 地址等信息。</p>\n<!--kg-card-end: markdown-->","comment_id":"61b8b75beb664800012e5073","plaintext":"> 反向代理（Reverse Proxy）方式是指用代理服务器来接受 internet\n上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet\n上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n举个例子，一个用户访问 http://www.example.com/readme，但是 www.example.com 上并不存在 readme\n页面，它是偷偷从另外一台服务器上取回来，然后作为自己的内容返回给用户。但是用户并不知情这个过程。对用户来说，就像是直接从 www.example.com 获取\nreadme 页面一样。这里所提到的 www.example.com 这个域名对应的服务器就设置了反向代理功能。\n\n反向代理服务器，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。如下图所示：\n\n\n\n反向代理典型应用场景\n反向代理的典型用途是将防火墙后面的服务器提供给 Internet 用户访问，加强安全防护。反向代理还可以为后端的多台服务器提供负载均衡，或为后端较慢的服务器提供 \n缓冲 服务。另外，反向代理还可以启用高级 URL 策略和管理技术，从而使处于不同 web 服务器系统的 web 页面同时存在于同一个 URL 空间下。\n\nNginx 的其中一个用途是做 HTTP 反向代理，下面简单介绍 Nginx 作为反向代理服务器的方法。\n\n> 场景描述：访问本地服务器上的 README.md 文件 http://localhost/README.md，本地服务器进行反向代理，从 \nhttps://github.com/moonbingbing/openresty-best-practices/blob/master/README.md \n获取页面内容。\n\n\nnginx.conf 配置示例：\n\nworker_processes 1;\n\npid logs/nginx.pid;\nerror_log logs/error.log warn;\n\nevents {\n    worker_connections 3000;\n}\n\nhttp {\n    include mime.types;\n    server_tokens off;\n\n\t## 下面配置反向代理的参数\n    server {\n        listen    8866;\n\n        ## 1. 用户访问 http://ip:port，则反向代理到 https://github.com\n        location / {\n            proxy_pass  https://github.com;\n            proxy_redirect     off;\n            proxy_set_header   Host             $host;\n            proxy_set_header   X-Real-IP        $remote_addr;\n            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n        }\n\n        ## 2.用户访问 http://ip:port/README.md，则反向代理到\n        ##   https://github.com/.../README.md\n        location /README.md {\n            proxy_set_header  X-Real-IP  $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass https://github.com/moonbingbing/openresty-best-practices/blob/master/README.md;\n        }\n    }\n}\n\n\n成功启动 Nginx 后，我们打开浏览器，验证下反向代理的效果。在浏览器地址栏中输入 localhost/README.md，返回的结果是我们 GitHub\n源代码的 README 页面。如下图：\n\n\n\n我们只需要配置一下 nginx.conf 文件，不用写任何 web 页面，就可以偷偷地从别的服务器上读取一个页面返回给用户。\n\n下面我们来看一下 nginx.conf 里用到的配置项：\n\n(1) location\n\nlocation 项对请求 URI 进行匹配，location 后面配置了匹配规则。例如上面的例子中，如果请求的 URI 是 localhost/，则会匹配 \nlocation / 这一项；如果请求的 URI 是 localhost/README.md，则会匹配 location /README.md 这项。\n\n上面这个例子只是针对一个确定的 URI 做了反向代理，有的读者会有疑惑：如果对每个页面都进行这样的配置，那将会大量重复，能否做 批量 配置呢？此时需要配合使用\nlocation 的正则匹配功能。具体实现方法可参考 Nginx 文档中 关于 location 的描述\n[http://nginx.org/en/docs/http/ngx_http_core_module.html#location]。\n\n(2) proxy_pass\n\nproxy_pass 后面跟着一个 URL，用来将请求反向代理到 URL 参数指定的服务器上。例如我们上面例子中的 proxy_pass\nhttps://github.com，则将匹配的请求反向代理到 https://github.com。\n\n(3) proxy_set_header\n\n默认情况下，反向代理不会转发原始请求中的 Host 头部，如果需要转发，就需要加上这句：proxy_set_header Host $host;\n\n除了上面提到的常用配置项，还有 proxy_redirect、proxy_set_body、proxy_limit_rate 等参数，具体用法可以到Nginx\n官网 [http://nginx.org/en/docs/http/ngx_http_proxy_module.html]查看。\n\n正向代理\n既然有反向代理，自然也有正向代理。简单来说，正向代理就像一个跳板，例如一个用户访问不了某网站（例如 www.google.com\n），但是他能访问一个代理服务器，这个代理服务器能访问 www.google.com\n，于是用户可以先连上代理服务器，告诉它需要访问的内容，代理服务器去取回来返回给用户。例如一些常见的翻墙工具、游戏代理就是利用正向代理的原理工作的，我们需要在这些正向代理工具上配置服务器的\nIP 地址等信息。","feature_image":"__GHOST_URL__/content/images/2021/12/NGINX-logo-rgb-large-1.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:25:15","created_by":"1","updated_at":"2021-12-14 15:51:47","updated_by":"1","published_at":"2018-06-05 18:49:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61b8b859eb664800012e5080","uuid":"674bcca3-bb7d-40b5-a08c-a021535fb921","title":"Typecho数据库设计","slug":"typechoshu-ju-ku-she-ji","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 转自Typecho官网\\n\\n## 主体结构\\n### 单用户博客数据量如何\\nTypecho的定位是单用户blog系统,在我们设计它的数据库之前有必要对个人博客系统的负载情况做一些评估.我有一个朋友,是一个勤奋的blogger,alexa排名在十万以上,日IP在10w左右.他选择了wordpress作为主要系统,我们知道wordpress系统的一个主页乐观的估计也有20余次查询.但这依然无法阻挡这款程序的流行,在去年对全球top10 blogger所使用的系统调查中,wordpress比其他系统有着明显的优势.很显然,wordpress的负载是可控的.\\n\\n当我们在设计一个单用户blog系统时,我们要时刻把*单用户*这三个字放在心上.单用户意味着数据的查询是很集中的,当一个用户页面的访问量比较小时,他几乎感觉不到这多出的几次查询带来多少延迟.而当访问量比较大时,他必然有实力去升级他的系统,而由于单用户系统的查询比较集中,我们可以通过部署文件缓存或者内存对象缓存来达到减轻数据库压力的目的,或者增加数据库数量来达到平滑的系统扩容.因此单用户系统设计重点在于灵活性和结构化,当我们集中地暴露系统瓶颈,从另一个方面也可以集中精力去解决它.\\n\\n### 5张表的设计\\n让我们列举一下一个blog系统需要哪些元素,这样也可以让我们更好地设计数据库表.我们需要文章,评论,分类,链接,用户,现在的blog系统还需要*文件,标签,链接分类,多重分类*,如果我们考虑到系统的灵活性,我们还需要将所有的可配置选项放到一个表中,类似于wordpress的options表.\\n\\n让我们来清点一下这些表.\\n\\n1. 文章表\\n2. 评论表\\n3. 文章分类表\\n4. 标签表\\n5. 链接表\\n6. 链接分类表\\n7. 文章与分类映射表(一对多)\\n8. 文章与标签映射表(一对多)\\n9. 配置表\\n10. 用户表\\n11. 文件表\\n\\n一共11张表,虽然不是很多但是总觉得还有抽象的余地.当我们仔细观察它们之间的关系后,除了配置表和用户表之外.其它表之间的关系都可以抽象为内容与项目之间的关系(可能是一对一,可能是一对多),比如评论与分类,链接与链接分类.通过这个抽象,我们可以把剩下的表缩减为3个表,那么来看看我们的第二版数据库结构\\n\\n1. 内容表\\n2. 关系表\\n3. 项目表\\n4. 配置表\\n5. 用户表\\n\\n根据以上设计以及我们的经验,只需要精心设计内容表和项目表的表结构就可以形成丰富的扩展应用.项目表与内容表的对应,形成了对内容的修饰.由于有了关系表的存在,内容与项目的关系可以是一对一也可以是一对多.\\n\\n### 内容与内容,6张表的设计\\n\\n如果你仔细分析一下上面的设计,你会发现一个隐藏的问题,那就是评论表的定义.显然评论表不可能是项目表,那么他只可能是内容表,但内容与内容之间的关系是我们以上设计中所没有定义的.观察评论与内容的关系\\n\\n1. 评论从属于内容,无法单独存在\\n2. 评论与内容是多对一的关系,且一条评论只能对应于一个内容\\n3. 评论的数量往往比较大,对于访问量比较大的blog,其单篇文章的评论往往要达到上百篇.\\n\\n根据以上考虑,评论表应该单独形成一个表与内容区分开,且根据常规做法以及速度上的考虑,评论应该用一个保留字段保存其从属内容的主键,以便查询.那么我们的第三版数据库结构就出炉了\\n\\n1. 内容表\\n2. 关系表\\n3. 项目表\\n4. 评论表\\n5. 配置表\\n6. 用户表\\n\\n### 梳理我们的设计\\n\\n让我们来看看内容表可以扩展出来的类型\\n\\n- post(文章)\\n- draft(草稿)\\n- page(页面)\\n- link(链接)\\n- attachment(文件)\\n\\n然后再来看看项目表里的类型\\n\\n- category(分类)\\n- tag(标签)\\n- link_category(链接分类)\\n\\n### 表以及字段命名\\n\\n考虑到标准化和国际化的需要,我们在表以及字段设置上应该尽量使用标准名称.而由于使用了一对多的关系映射,在可以预见的地方内容与项目之间都不可能使用联合查询,而是用多次*联动查询*,来取出多行关联数据.所以内容表与项目表的字段是可以重名的(在联合查询中,重名字段会被覆盖).以下是我对各数据表的命名\\n\\n1. 内容表 - contents\\n2. 关系表 - relationships\\n3. 项目表 - metas (meta的意思为关于什么的什么)\\n4. 评论表 - comments\\n5. 配置表 - options\\n6. 用户表 - users\\n\\n### 数据字典\\n\\n#### contents表\\n\\n|  键名 | 类型  |属性|注释|\\n| ------------ | ------------ |---|----|\\n| cid  | int(10)  |主键，非负，自增 | 主键|\\n|  title | varchar(200)  |可为空 |内容标题 |\\n|  slug | varchar(200)  | 索引，可为空|内容缩略名 |\\n|  created | int(10)  | 索引，非负，可为空|内容生成时的GMT unix时间戳 |\\n|  modified | int(10)  | 索引，非负，可为空|内容生成时的GMT unix时间戳 |\\n|text\\t|text\\t|可为空|\\t内容文字|\\n|order\\t|int(10)\\t|非负,可为空|\\t排序|\\n|authorId\\t|int(10)\\t|非负,可为空\\t|内容所属用户id|\\n|template\\t|varchar(32)\\t|可为空\\t|内容使用的模板|\\n|type\\t|varchar(16)\\t|可为空\\t|内容类别|\\n|status\\t|varchar(16)\\t|可为空\\t|内容状态|\\n|password\\t|varchar(32)\\t|可为空\\t|受保护内容,此字段对应内容保护密码|\\n|commentsNum\\t|int(10)\\t|非负,可为空\\t|内容所属评论数,冗余字段|\\n|allowComment\\t|char(1)\\t|可为空\\t|是否允许评论|\\n|allowPing\\t|char(1)\\t|可为空\\t|是否允许ping|\\n|allowFeed|\\tchar(1)|可为空\\t|允许出现在聚合中|\\n\\n#### relationships表\\n\\n|  键名 | 类型  |属性|注释|\\n| ------------ | ------------ |---|----|\\n|cid|\\tint(10)|\\t主键,非负\\t|内容主键|\\n|mid\\t|int(10)\\t|主键,非负\\t|项目主键|\\n\\n#### metas表\\n\\n|  键名 | 类型  |属性|注释|\\n| ------------ | ------------ |---|----|\\n|mid|\\tint(10)|\\t主键,非负\\t|项目主键|\\n|name|\\tvarchar(200)|可为空|名称|\\n|slug|\\tvarchar(200)|索引,可为空|\\t项目缩略名|\\n|type|\\tvarchar(32)|可为空\\t|项目类型|\\n|description|varchar(200)\\t|可为空\\t|选项描述|\\n|count|\\tint(10)\\t|非负,可为空|\\t项目所属内容个数|\\n|order|\\tint(10)\\t|非负,可为空|\\t项目排序|\\n\\n#### comments表\\n\\n|  键名 | 类型  |属性|注释|\\n| ------------ | ------------ |---|----|\\n|coid|\\tint(10)\\t|主键,非负,自增|\\tcomment表主键|\\n|cid|\\tint(10)|\\t索引,非负\\t|post表主键,关联字段|\\n|created|\\tint(10)|\\t非负,可为空|\\t评论生成时的GMT unix时间戳\\n|author\\t|varchar(200)|\\t可为空|\\t评论作者|\\n|authorId|\\tint(10)|\\t非负,可为空|\\t评论所属用户id|\\n|ownerId|\\tint(10)|\\t非负,可为空\\t|评论所属内容作者id|\\n|mail|\\tvarchar(200)\\t|可为空|\\t评论者邮件|\\n|url|\\tvarchar(200)|\\t可为空|\\t评论者网址|\\n|ip\\t|varchar(64)|\\t可为空\\t|评论者ip地址|\\n|agent\\t|varchar(200)\\t|可为空|\\t评论者客户端|\\n|text\\t|text\\t|可为空\\t|评论文字|\\n|type\\t|varchar(16)\\t|可为空|\\t评论类型|\\n|status\\t|varchar(16)\\t|可为空\\t|评论状态|\\n|parent\\t|int(10)\\t|可为空\\t|父级评论|\\n\\n#### options表\\n\\n|  键名 | 类型  |属性|注释|\\n| ------------ | ------------ |---|----|\\n|name|\\tvarchar(32)|\\t主键|\\t配置名称|\\n|user|\\tint(10)|\\t主键,非负|\\t配置所属用户,默认为0(全局配置)|\\n|value|\\ttext\\t|可为空\\t|配置值|\\n\\n#### users表\\n\\n|  键名 | 类型  |属性|注释|\\n| ------------ | ------------ |---|----|\\n|uid|\\tint(10)|\\t主键,非负,自增|\\tuser表主键|\\n|name|varchar(32)|\\t唯一\\t|用户名称|\\n|password|\\tvarchar(32)|\\t可为空\\t|用户密码|\\n|mail|\\tvarchar(200)\\t|唯一\\t|用户的邮箱|\\n|url|\\tvarchar(200)\\t|可为空\\t|用户的主页|\\n|screenName\\t|varchar(32)|可为空|用户显示的名称|\\n|created\\t|int(10)|\\t非负,可为空\\t|用户注册时的GMT unix时间戳|\\n|activated\\t|int(10)|\\t非负,可为空|\\t最后活动时间|\\n|logged\\t|int(10)|\\t非负,可为空|\\t上次登录最后活跃时间|\\n|group\\t|varchar(16)|\\tN/A|\\t用户组|\\n|authCode\\t|varchar(40)|\\t可为空\\t|用户登录验证码|\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>转自Typecho官网</p>\n</blockquote>\n<h2 id=\"%E4%B8%BB%E4%BD%93%E7%BB%93%E6%9E%84\">主体结构</h2>\n<h3 id=\"%E5%8D%95%E7%94%A8%E6%88%B7%E5%8D%9A%E5%AE%A2%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A6%82%E4%BD%95\">单用户博客数据量如何</h3>\n<p>Typecho的定位是单用户blog系统,在我们设计它的数据库之前有必要对个人博客系统的负载情况做一些评估.我有一个朋友,是一个勤奋的blogger,alexa排名在十万以上,日IP在10w左右.他选择了wordpress作为主要系统,我们知道wordpress系统的一个主页乐观的估计也有20余次查询.但这依然无法阻挡这款程序的流行,在去年对全球top10 blogger所使用的系统调查中,wordpress比其他系统有着明显的优势.很显然,wordpress的负载是可控的.</p>\n<p>当我们在设计一个单用户blog系统时,我们要时刻把<em>单用户</em>这三个字放在心上.单用户意味着数据的查询是很集中的,当一个用户页面的访问量比较小时,他几乎感觉不到这多出的几次查询带来多少延迟.而当访问量比较大时,他必然有实力去升级他的系统,而由于单用户系统的查询比较集中,我们可以通过部署文件缓存或者内存对象缓存来达到减轻数据库压力的目的,或者增加数据库数量来达到平滑的系统扩容.因此单用户系统设计重点在于灵活性和结构化,当我们集中地暴露系统瓶颈,从另一个方面也可以集中精力去解决它.</p>\n<h3 id=\"5%E5%BC%A0%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1\">5张表的设计</h3>\n<p>让我们列举一下一个blog系统需要哪些元素,这样也可以让我们更好地设计数据库表.我们需要文章,评论,分类,链接,用户,现在的blog系统还需要<em>文件,标签,链接分类,多重分类</em>,如果我们考虑到系统的灵活性,我们还需要将所有的可配置选项放到一个表中,类似于wordpress的options表.</p>\n<p>让我们来清点一下这些表.</p>\n<ol>\n<li>文章表</li>\n<li>评论表</li>\n<li>文章分类表</li>\n<li>标签表</li>\n<li>链接表</li>\n<li>链接分类表</li>\n<li>文章与分类映射表(一对多)</li>\n<li>文章与标签映射表(一对多)</li>\n<li>配置表</li>\n<li>用户表</li>\n<li>文件表</li>\n</ol>\n<p>一共11张表,虽然不是很多但是总觉得还有抽象的余地.当我们仔细观察它们之间的关系后,除了配置表和用户表之外.其它表之间的关系都可以抽象为内容与项目之间的关系(可能是一对一,可能是一对多),比如评论与分类,链接与链接分类.通过这个抽象,我们可以把剩下的表缩减为3个表,那么来看看我们的第二版数据库结构</p>\n<ol>\n<li>内容表</li>\n<li>关系表</li>\n<li>项目表</li>\n<li>配置表</li>\n<li>用户表</li>\n</ol>\n<p>根据以上设计以及我们的经验,只需要精心设计内容表和项目表的表结构就可以形成丰富的扩展应用.项目表与内容表的对应,形成了对内容的修饰.由于有了关系表的存在,内容与项目的关系可以是一对一也可以是一对多.</p>\n<h3 id=\"%E5%86%85%E5%AE%B9%E4%B8%8E%E5%86%85%E5%AE%B96%E5%BC%A0%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1\">内容与内容,6张表的设计</h3>\n<p>如果你仔细分析一下上面的设计,你会发现一个隐藏的问题,那就是评论表的定义.显然评论表不可能是项目表,那么他只可能是内容表,但内容与内容之间的关系是我们以上设计中所没有定义的.观察评论与内容的关系</p>\n<ol>\n<li>评论从属于内容,无法单独存在</li>\n<li>评论与内容是多对一的关系,且一条评论只能对应于一个内容</li>\n<li>评论的数量往往比较大,对于访问量比较大的blog,其单篇文章的评论往往要达到上百篇.</li>\n</ol>\n<p>根据以上考虑,评论表应该单独形成一个表与内容区分开,且根据常规做法以及速度上的考虑,评论应该用一个保留字段保存其从属内容的主键,以便查询.那么我们的第三版数据库结构就出炉了</p>\n<ol>\n<li>内容表</li>\n<li>关系表</li>\n<li>项目表</li>\n<li>评论表</li>\n<li>配置表</li>\n<li>用户表</li>\n</ol>\n<h3 id=\"%E6%A2%B3%E7%90%86%E6%88%91%E4%BB%AC%E7%9A%84%E8%AE%BE%E8%AE%A1\">梳理我们的设计</h3>\n<p>让我们来看看内容表可以扩展出来的类型</p>\n<ul>\n<li>post(文章)</li>\n<li>draft(草稿)</li>\n<li>page(页面)</li>\n<li>link(链接)</li>\n<li>attachment(文件)</li>\n</ul>\n<p>然后再来看看项目表里的类型</p>\n<ul>\n<li>category(分类)</li>\n<li>tag(标签)</li>\n<li>link_category(链接分类)</li>\n</ul>\n<h3 id=\"%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%AD%97%E6%AE%B5%E5%91%BD%E5%90%8D\">表以及字段命名</h3>\n<p>考虑到标准化和国际化的需要,我们在表以及字段设置上应该尽量使用标准名称.而由于使用了一对多的关系映射,在可以预见的地方内容与项目之间都不可能使用联合查询,而是用多次<em>联动查询</em>,来取出多行关联数据.所以内容表与项目表的字段是可以重名的(在联合查询中,重名字段会被覆盖).以下是我对各数据表的命名</p>\n<ol>\n<li>内容表 - contents</li>\n<li>关系表 - relationships</li>\n<li>项目表 - metas (meta的意思为关于什么的什么)</li>\n<li>评论表 - comments</li>\n<li>配置表 - options</li>\n<li>用户表 - users</li>\n</ol>\n<h3 id=\"%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8\">数据字典</h3>\n<h4 id=\"contents%E8%A1%A8\">contents表</h4>\n<table>\n<thead>\n<tr>\n<th>键名</th>\n<th>类型</th>\n<th>属性</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cid</td>\n<td>int(10)</td>\n<td>主键，非负，自增</td>\n<td>主键</td>\n</tr>\n<tr>\n<td>title</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>内容标题</td>\n</tr>\n<tr>\n<td>slug</td>\n<td>varchar(200)</td>\n<td>索引，可为空</td>\n<td>内容缩略名</td>\n</tr>\n<tr>\n<td>created</td>\n<td>int(10)</td>\n<td>索引，非负，可为空</td>\n<td>内容生成时的GMT unix时间戳</td>\n</tr>\n<tr>\n<td>modified</td>\n<td>int(10)</td>\n<td>索引，非负，可为空</td>\n<td>内容生成时的GMT unix时间戳</td>\n</tr>\n<tr>\n<td>text</td>\n<td>text</td>\n<td>可为空</td>\n<td>内容文字</td>\n</tr>\n<tr>\n<td>order</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>排序</td>\n</tr>\n<tr>\n<td>authorId</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>内容所属用户id</td>\n</tr>\n<tr>\n<td>template</td>\n<td>varchar(32)</td>\n<td>可为空</td>\n<td>内容使用的模板</td>\n</tr>\n<tr>\n<td>type</td>\n<td>varchar(16)</td>\n<td>可为空</td>\n<td>内容类别</td>\n</tr>\n<tr>\n<td>status</td>\n<td>varchar(16)</td>\n<td>可为空</td>\n<td>内容状态</td>\n</tr>\n<tr>\n<td>password</td>\n<td>varchar(32)</td>\n<td>可为空</td>\n<td>受保护内容,此字段对应内容保护密码</td>\n</tr>\n<tr>\n<td>commentsNum</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>内容所属评论数,冗余字段</td>\n</tr>\n<tr>\n<td>allowComment</td>\n<td>char(1)</td>\n<td>可为空</td>\n<td>是否允许评论</td>\n</tr>\n<tr>\n<td>allowPing</td>\n<td>char(1)</td>\n<td>可为空</td>\n<td>是否允许ping</td>\n</tr>\n<tr>\n<td>allowFeed</td>\n<td>char(1)</td>\n<td>可为空</td>\n<td>允许出现在聚合中</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"relationships%E8%A1%A8\">relationships表</h4>\n<table>\n<thead>\n<tr>\n<th>键名</th>\n<th>类型</th>\n<th>属性</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cid</td>\n<td>int(10)</td>\n<td>主键,非负</td>\n<td>内容主键</td>\n</tr>\n<tr>\n<td>mid</td>\n<td>int(10)</td>\n<td>主键,非负</td>\n<td>项目主键</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"metas%E8%A1%A8\">metas表</h4>\n<table>\n<thead>\n<tr>\n<th>键名</th>\n<th>类型</th>\n<th>属性</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mid</td>\n<td>int(10)</td>\n<td>主键,非负</td>\n<td>项目主键</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>名称</td>\n</tr>\n<tr>\n<td>slug</td>\n<td>varchar(200)</td>\n<td>索引,可为空</td>\n<td>项目缩略名</td>\n</tr>\n<tr>\n<td>type</td>\n<td>varchar(32)</td>\n<td>可为空</td>\n<td>项目类型</td>\n</tr>\n<tr>\n<td>description</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>选项描述</td>\n</tr>\n<tr>\n<td>count</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>项目所属内容个数</td>\n</tr>\n<tr>\n<td>order</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>项目排序</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"comments%E8%A1%A8\">comments表</h4>\n<table>\n<thead>\n<tr>\n<th>键名</th>\n<th>类型</th>\n<th>属性</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>coid</td>\n<td>int(10)</td>\n<td>主键,非负,自增</td>\n<td>comment表主键</td>\n</tr>\n<tr>\n<td>cid</td>\n<td>int(10)</td>\n<td>索引,非负</td>\n<td>post表主键,关联字段</td>\n</tr>\n<tr>\n<td>created</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>评论生成时的GMT unix时间戳</td>\n</tr>\n<tr>\n<td>author</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>评论作者</td>\n</tr>\n<tr>\n<td>authorId</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>评论所属用户id</td>\n</tr>\n<tr>\n<td>ownerId</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>评论所属内容作者id</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>评论者邮件</td>\n</tr>\n<tr>\n<td>url</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>评论者网址</td>\n</tr>\n<tr>\n<td>ip</td>\n<td>varchar(64)</td>\n<td>可为空</td>\n<td>评论者ip地址</td>\n</tr>\n<tr>\n<td>agent</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>评论者客户端</td>\n</tr>\n<tr>\n<td>text</td>\n<td>text</td>\n<td>可为空</td>\n<td>评论文字</td>\n</tr>\n<tr>\n<td>type</td>\n<td>varchar(16)</td>\n<td>可为空</td>\n<td>评论类型</td>\n</tr>\n<tr>\n<td>status</td>\n<td>varchar(16)</td>\n<td>可为空</td>\n<td>评论状态</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>int(10)</td>\n<td>可为空</td>\n<td>父级评论</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"options%E8%A1%A8\">options表</h4>\n<table>\n<thead>\n<tr>\n<th>键名</th>\n<th>类型</th>\n<th>属性</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>varchar(32)</td>\n<td>主键</td>\n<td>配置名称</td>\n</tr>\n<tr>\n<td>user</td>\n<td>int(10)</td>\n<td>主键,非负</td>\n<td>配置所属用户,默认为0(全局配置)</td>\n</tr>\n<tr>\n<td>value</td>\n<td>text</td>\n<td>可为空</td>\n<td>配置值</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"users%E8%A1%A8\">users表</h4>\n<table>\n<thead>\n<tr>\n<th>键名</th>\n<th>类型</th>\n<th>属性</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>uid</td>\n<td>int(10)</td>\n<td>主键,非负,自增</td>\n<td>user表主键</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar(32)</td>\n<td>唯一</td>\n<td>用户名称</td>\n</tr>\n<tr>\n<td>password</td>\n<td>varchar(32)</td>\n<td>可为空</td>\n<td>用户密码</td>\n</tr>\n<tr>\n<td>mail</td>\n<td>varchar(200)</td>\n<td>唯一</td>\n<td>用户的邮箱</td>\n</tr>\n<tr>\n<td>url</td>\n<td>varchar(200)</td>\n<td>可为空</td>\n<td>用户的主页</td>\n</tr>\n<tr>\n<td>screenName</td>\n<td>varchar(32)</td>\n<td>可为空</td>\n<td>用户显示的名称</td>\n</tr>\n<tr>\n<td>created</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>用户注册时的GMT unix时间戳</td>\n</tr>\n<tr>\n<td>activated</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>最后活动时间</td>\n</tr>\n<tr>\n<td>logged</td>\n<td>int(10)</td>\n<td>非负,可为空</td>\n<td>上次登录最后活跃时间</td>\n</tr>\n<tr>\n<td>group</td>\n<td>varchar(16)</td>\n<td>N/A</td>\n<td>用户组</td>\n</tr>\n<tr>\n<td>authCode</td>\n<td>varchar(40)</td>\n<td>可为空</td>\n<td>用户登录验证码</td>\n</tr>\n</tbody>\n</table>\n<!--kg-card-end: markdown-->","comment_id":"61b8b859eb664800012e5080","plaintext":"> 转自Typecho官网\n\n\n主体结构\n单用户博客数据量如何\nTypecho的定位是单用户blog系统,在我们设计它的数据库之前有必要对个人博客系统的负载情况做一些评估.我有一个朋友,是一个勤奋的blogger,alexa排名在十万以上,日IP在10w左右.他选择了wordpress作为主要系统,我们知道wordpress系统的一个主页乐观的估计也有20余次查询.但这依然无法阻挡这款程序的流行,在去年对全球top10\nblogger所使用的系统调查中,wordpress比其他系统有着明显的优势.很显然,wordpress的负载是可控的.\n\n当我们在设计一个单用户blog系统时,我们要时刻把单用户\n这三个字放在心上.单用户意味着数据的查询是很集中的,当一个用户页面的访问量比较小时,他几乎感觉不到这多出的几次查询带来多少延迟.而当访问量比较大时,他必然有实力去升级他的系统,而由于单用户系统的查询比较集中,我们可以通过部署文件缓存或者内存对象缓存来达到减轻数据库压力的目的,或者增加数据库数量来达到平滑的系统扩容.因此单用户系统设计重点在于灵活性和结构化,当我们集中地暴露系统瓶颈,从另一个方面也可以集中精力去解决它.\n\n5张表的设计\n让我们列举一下一个blog系统需要哪些元素,这样也可以让我们更好地设计数据库表.我们需要文章,评论,分类,链接,用户,现在的blog系统还需要\n文件,标签,链接分类,多重分类,如果我们考虑到系统的灵活性,我们还需要将所有的可配置选项放到一个表中,类似于wordpress的options表.\n\n让我们来清点一下这些表.\n\n 1.  文章表\n 2.  评论表\n 3.  文章分类表\n 4.  标签表\n 5.  链接表\n 6.  链接分类表\n 7.  文章与分类映射表(一对多)\n 8.  文章与标签映射表(一对多)\n 9.  配置表\n 10. 用户表\n 11. 文件表\n\n一共11张表,虽然不是很多但是总觉得还有抽象的余地.当我们仔细观察它们之间的关系后,除了配置表和用户表之外.其它表之间的关系都可以抽象为内容与项目之间的关系(可能是一对一,可能是一对多),比如评论与分类,链接与链接分类.通过这个抽象,我们可以把剩下的表缩减为3个表,那么来看看我们的第二版数据库结构\n\n 1. 内容表\n 2. 关系表\n 3. 项目表\n 4. 配置表\n 5. 用户表\n\n根据以上设计以及我们的经验,只需要精心设计内容表和项目表的表结构就可以形成丰富的扩展应用.项目表与内容表的对应,形成了对内容的修饰.由于有了关系表的存在,内容与项目的关系可以是一对一也可以是一对多.\n\n内容与内容,6张表的设计\n如果你仔细分析一下上面的设计,你会发现一个隐藏的问题,那就是评论表的定义.显然评论表不可能是项目表,那么他只可能是内容表,但内容与内容之间的关系是我们以上设计中所没有定义的.观察评论与内容的关系\n\n 1. 评论从属于内容,无法单独存在\n 2. 评论与内容是多对一的关系,且一条评论只能对应于一个内容\n 3. 评论的数量往往比较大,对于访问量比较大的blog,其单篇文章的评论往往要达到上百篇.\n\n根据以上考虑,评论表应该单独形成一个表与内容区分开,且根据常规做法以及速度上的考虑,评论应该用一个保留字段保存其从属内容的主键,以便查询.那么我们的第三版数据库结构就出炉了\n\n 1. 内容表\n 2. 关系表\n 3. 项目表\n 4. 评论表\n 5. 配置表\n 6. 用户表\n\n梳理我们的设计\n让我们来看看内容表可以扩展出来的类型\n\n * post(文章)\n * draft(草稿)\n * page(页面)\n * link(链接)\n * attachment(文件)\n\n然后再来看看项目表里的类型\n\n * category(分类)\n * tag(标签)\n * link_category(链接分类)\n\n表以及字段命名\n考虑到标准化和国际化的需要,我们在表以及字段设置上应该尽量使用标准名称.而由于使用了一对多的关系映射,在可以预见的地方内容与项目之间都不可能使用联合查询,而是用多次\n联动查询,来取出多行关联数据.所以内容表与项目表的字段是可以重名的(在联合查询中,重名字段会被覆盖).以下是我对各数据表的命名\n\n 1. 内容表 - contents\n 2. 关系表 - relationships\n 3. 项目表 - metas (meta的意思为关于什么的什么)\n 4. 评论表 - comments\n 5. 配置表 - options\n 6. 用户表 - users\n\n数据字典\ncontents表\n键名类型属性注释cidint(10)主键，非负，自增主键titlevarchar(200)可为空内容标题slugvarchar(200)索引，可为空内容缩略名\ncreatedint(10)索引，非负，可为空内容生成时的GMT unix时间戳modifiedint(10)索引，非负，可为空内容生成时的GMT\nunix时间戳texttext可为空内容文字orderint(10)非负,可为空排序authorIdint(10)非负,可为空内容所属用户idtemplate\nvarchar(32)可为空内容使用的模板typevarchar(16)可为空内容类别statusvarchar(16)可为空内容状态password\nvarchar(32)可为空受保护内容,此字段对应内容保护密码commentsNumint(10)非负,可为空内容所属评论数,冗余字段allowComment\nchar(1)可为空是否允许评论allowPingchar(1)可为空是否允许pingallowFeedchar(1)可为空允许出现在聚合中\nrelationships表\n键名类型属性注释cidint(10)主键,非负内容主键midint(10)主键,非负项目主键metas表\n键名类型属性注释midint(10)主键,非负项目主键namevarchar(200)可为空名称slugvarchar(200)索引,可为空项目缩略名type\nvarchar(32)可为空项目类型descriptionvarchar(200)可为空选项描述countint(10)非负,可为空项目所属内容个数order\nint(10)非负,可为空项目排序comments表\n键名类型属性注释coidint(10)主键,非负,自增comment表主键cidint(10)索引,非负post表主键,关联字段createdint(10)\n非负,可为空评论生成时的GMT unix时间戳authorvarchar(200)可为空评论作者authorIdint(10)非负,可为空评论所属用户id\nownerIdint(10)非负,可为空评论所属内容作者idmailvarchar(200)可为空评论者邮件urlvarchar(200)可为空评论者网址ip\nvarchar(64)可为空评论者ip地址agentvarchar(200)可为空评论者客户端texttext可为空评论文字typevarchar(16)可为空\n评论类型statusvarchar(16)可为空评论状态parentint(10)可为空父级评论options表\n键名类型属性注释namevarchar(32)主键配置名称userint(10)主键,非负配置所属用户,默认为0(全局配置)valuetext可为空配置值\nusers表\n键名类型属性注释uidint(10)主键,非负,自增user表主键namevarchar(32)唯一用户名称passwordvarchar(32)可为空用户密码\nmailvarchar(200)唯一用户的邮箱urlvarchar(200)可为空用户的主页screenNamevarchar(32)可为空用户显示的名称\ncreatedint(10)非负,可为空用户注册时的GMT unix时间戳activatedint(10)非负,可为空最后活动时间loggedint(10)\n非负,可为空上次登录最后活跃时间groupvarchar(16)N/A用户组authCodevarchar(40)可为空用户登录验证码","feature_image":"__GHOST_URL__/content/images/2021/12/typecho.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-12-14 15:29:29","created_by":"1","updated_at":"2021-12-14 15:45:33","updated_by":"1","published_at":"2018-02-02 08:34:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61d1c563ce958b0001b30bbe","uuid":"301f2e5c-4bb7-40c6-aa36-1de9b5be9531","title":"Fedora 删除不用的内核和启动选择项","slug":"fedora-shan-chu-duo-yu-de-nei-he-he-qi-dong-xuan-ze-xiang","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"默认情况下，用`sudo dnf update` 或 `sudo yum update`后，会将Linux内核一起更新，过一段时间，grub2 就会生成好几个启动项，如果更新内核后使用系统没有问题，就可以把旧的内核删除。\\n\\n我的M6800遇到的问题是，每次更新内核后，都需要重新安装显卡驱动，不然进不了GUI，这个很烦人，浪费时间，搞得我每次都有冲动重装系统。今天更新到5.15.12，又进不了桌面了，还好grub2可以让我选择从5.15.11启动。\\n\\n> 自我对话\\n> - TMD，装win算了，至少没这么多麻烦...然后我就去搜win10镜像了...\\n> - 行了吧你，Windows用不了几天你必然折腾回Linux，谁叫你爱折腾呢...\\n> - 好吧，还是不要逃避问题，折腾走起...\\n\\n冷静了一会儿，网上搜索试验了一番，把不用的内核都删除，然后dnf更新时排除内核，即不升级内核。\\n\\n使用`uname -r` 查看当前使用的内核\\n\\n```shell\\n[yangjl@fedora ~]$ uname -r\\n5.15.11-200.fc35.x86_64\\n```\\n\\n使用`rpm -aq|grep kernel`查看已经安装的内核\\n\\n```shell\\n[yangjl@fedora ~]$ sudo rpm -aq | grep kernel\\nlibreport-plugin-kerneloops-2.15.2-6.fc35.x86_64\\nabrt-addon-kerneloops-2.14.6-9.fc35.x86_64\\nkernel-headers-5.15.4-200.fc35.x86_64\\nkernel-srpm-macros-1.0-6.fc35.noarch\\nkernel-core-5.15.11-200.fc35.x86_64\\nkernel-modules-5.15.11-200.fc35.x86_64\\nkernel-5.15.11-200.fc35.x86_64\\nkernel-modules-extra-5.15.11-200.fc35.x86_64\\nkernel-devel-5.15.11-200.fc35.x86_64\\nkernel-devel-5.15.12-200.fc35.x86_64\\n```\\n\\n保留当前使用的内核，删除不用的内核 `sudo dnf remove -y kernel-core-5.15.12*`\\n\\n\\n`dnf` 和 `yum` 更新时可以使用exclude命令排除你不希望更新的package，例如更新除了firefox以外的所有package，可以这样\\n\\n```shell\\nsudo dnf update --exclude=firefox\\nsudo yum update --exclude=firefox\\n```\\n\\n再比如更新除了内核以外的所有package：\\n\\n```shell\\nsudo dnf update --exclude=kernel*\\nsudo yum update --exclude=kernel*\\n```\\n\\n如果觉得麻烦，在fedora下，可以通过修改`/etc/dnf/dnf.conf`，在`[main]`下添加`exclude=kernel*`,这样在使用`dnf update`和`yum update`时会排除kernel package 的更新。\\n\\n/etc/dnf/dnf.conf\\n\\n```shell\\n[main]\\ngpgcheck=1\\ninstallonly_limit=3\\nclean_requirements_on_remove=True\\nbest=False\\nskip_if_unavailable=True\\nexclude=kernel*\\n```\\n\\n## 参考文献\\n\\nhttps://chewett.co.uk/blog/800/exclude-fedora-packages-updating-dnf-yum/\\nhttps://laplacence.github.io/2017/02/27/Fedora_delete_redundancy_kernel/\\n\\n\\nThe end.\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>默认情况下，用<code>sudo dnf update</code> 或 <code>sudo yum update</code>后，会将Linux内核一起更新，过一段时间，grub2 就会生成好几个启动项，如果更新内核后使用系统没有问题，就可以把旧的内核删除。</p>\n<p>我的M6800遇到的问题是，每次更新内核后，都需要重新安装显卡驱动，不然进不了GUI，这个很烦人，浪费时间，搞得我每次都有冲动重装系统。今天更新到5.15.12，又进不了桌面了，还好grub2可以让我选择从5.15.11启动。</p>\n<blockquote>\n<p>自我对话</p>\n<ul>\n<li>TMD，装win算了，至少没这么多麻烦...然后我就去搜win10镜像了...</li>\n<li>行了吧你，Windows用不了几天你必然折腾回Linux，谁叫你爱折腾呢...</li>\n<li>好吧，还是不要逃避问题，折腾走起...</li>\n</ul>\n</blockquote>\n<p>冷静了一会儿，网上搜索试验了一番，把不用的内核都删除，然后dnf更新时排除内核，即不升级内核。</p>\n<p>使用<code>uname -r</code> 查看当前使用的内核</p>\n<pre><code class=\"language-shell\">[yangjl@fedora ~]$ uname -r\n5.15.11-200.fc35.x86_64\n</code></pre>\n<p>使用<code>rpm -aq|grep kernel</code>查看已经安装的内核</p>\n<pre><code class=\"language-shell\">[yangjl@fedora ~]$ sudo rpm -aq | grep kernel\nlibreport-plugin-kerneloops-2.15.2-6.fc35.x86_64\nabrt-addon-kerneloops-2.14.6-9.fc35.x86_64\nkernel-headers-5.15.4-200.fc35.x86_64\nkernel-srpm-macros-1.0-6.fc35.noarch\nkernel-core-5.15.11-200.fc35.x86_64\nkernel-modules-5.15.11-200.fc35.x86_64\nkernel-5.15.11-200.fc35.x86_64\nkernel-modules-extra-5.15.11-200.fc35.x86_64\nkernel-devel-5.15.11-200.fc35.x86_64\nkernel-devel-5.15.12-200.fc35.x86_64\n</code></pre>\n<p>保留当前使用的内核，删除不用的内核 <code>sudo dnf remove -y kernel-core-5.15.12*</code></p>\n<p><code>dnf</code> 和 <code>yum</code> 更新时可以使用exclude命令排除你不希望更新的package，例如更新除了firefox以外的所有package，可以这样</p>\n<pre><code class=\"language-shell\">sudo dnf update --exclude=firefox\nsudo yum update --exclude=firefox\n</code></pre>\n<p>再比如更新除了内核以外的所有package：</p>\n<pre><code class=\"language-shell\">sudo dnf update --exclude=kernel*\nsudo yum update --exclude=kernel*\n</code></pre>\n<p>如果觉得麻烦，在fedora下，可以通过修改<code>/etc/dnf/dnf.conf</code>，在<code>[main]</code>下添加<code>exclude=kernel*</code>,这样在使用<code>dnf update</code>和<code>yum update</code>时会排除kernel package 的更新。</p>\n<p>/etc/dnf/dnf.conf</p>\n<pre><code class=\"language-shell\">[main]\ngpgcheck=1\ninstallonly_limit=3\nclean_requirements_on_remove=True\nbest=False\nskip_if_unavailable=True\nexclude=kernel*\n</code></pre>\n<h2 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h2>\n<p><a href=\"https://chewett.co.uk/blog/800/exclude-fedora-packages-updating-dnf-yum/\">https://chewett.co.uk/blog/800/exclude-fedora-packages-updating-dnf-yum/</a><br>\n<a href=\"https://laplacence.github.io/2017/02/27/Fedora_delete_redundancy_kernel/\">https://laplacence.github.io/2017/02/27/Fedora_delete_redundancy_kernel/</a></p>\n<p>The end.</p>\n<!--kg-card-end: markdown-->","comment_id":"61d1c563ce958b0001b30bbe","plaintext":"默认情况下，用sudo dnf update 或 sudo yum update后，会将Linux内核一起更新，过一段时间，grub2\n就会生成好几个启动项，如果更新内核后使用系统没有问题，就可以把旧的内核删除。\n\n我的M6800遇到的问题是，每次更新内核后，都需要重新安装显卡驱动，不然进不了GUI，这个很烦人，浪费时间，搞得我每次都有冲动重装系统。今天更新到5.15.12，又进不了桌面了，还好grub2可以让我选择从5.15.11启动。\n\n> 自我对话\n\n * TMD，装win算了，至少没这么多麻烦...然后我就去搜win10镜像了...\n * 行了吧你，Windows用不了几天你必然折腾回Linux，谁叫你爱折腾呢...\n * 好吧，还是不要逃避问题，折腾走起...\n\n\n冷静了一会儿，网上搜索试验了一番，把不用的内核都删除，然后dnf更新时排除内核，即不升级内核。\n\n使用uname -r 查看当前使用的内核\n\n[yangjl@fedora ~]$ uname -r\n5.15.11-200.fc35.x86_64\n\n\n使用rpm -aq|grep kernel查看已经安装的内核\n\n[yangjl@fedora ~]$ sudo rpm -aq | grep kernel\nlibreport-plugin-kerneloops-2.15.2-6.fc35.x86_64\nabrt-addon-kerneloops-2.14.6-9.fc35.x86_64\nkernel-headers-5.15.4-200.fc35.x86_64\nkernel-srpm-macros-1.0-6.fc35.noarch\nkernel-core-5.15.11-200.fc35.x86_64\nkernel-modules-5.15.11-200.fc35.x86_64\nkernel-5.15.11-200.fc35.x86_64\nkernel-modules-extra-5.15.11-200.fc35.x86_64\nkernel-devel-5.15.11-200.fc35.x86_64\nkernel-devel-5.15.12-200.fc35.x86_64\n\n\n保留当前使用的内核，删除不用的内核 sudo dnf remove -y kernel-core-5.15.12*\n\ndnf 和 yum 更新时可以使用exclude命令排除你不希望更新的package，例如更新除了firefox以外的所有package，可以这样\n\nsudo dnf update --exclude=firefox\nsudo yum update --exclude=firefox\n\n\n再比如更新除了内核以外的所有package：\n\nsudo dnf update --exclude=kernel*\nsudo yum update --exclude=kernel*\n\n\n如果觉得麻烦，在fedora下，可以通过修改/etc/dnf/dnf.conf，在[main]下添加exclude=kernel*,这样在使用dnf\nupdate和yum update时会排除kernel package 的更新。\n\n/etc/dnf/dnf.conf\n\n[main]\ngpgcheck=1\ninstallonly_limit=3\nclean_requirements_on_remove=True\nbest=False\nskip_if_unavailable=True\nexclude=kernel*\n\n\n参考文献\nhttps://chewett.co.uk/blog/800/exclude-fedora-packages-updating-dnf-yum/\nhttps://laplacence.github.io/2017/02/27/Fedora_delete_redundancy_kernel/\n\nThe end.","feature_image":"__GHOST_URL__/content/images/2022/03/excluding-packages-update-on-fedora.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2022-01-02 15:31:47","created_by":"1","updated_at":"2022-03-20 14:03:11","updated_by":"1","published_at":"2022-01-02 16:10:01","published_by":"1","custom_excerpt":"过一段时间，grub2 就会生成好几个启动项，如果更新内核后使用系统没有问题，就可以把旧的内核删除。","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"62372731ce958b0001b30cab","uuid":"c1fff22c-b87e-4c6c-a480-79fc8f19d7b4","title":"领域事件","slug":"domain-event","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 原文：https://microservices.io/patterns/data/domain-event.html\\n> 译文：杨金龙\\n\\n## 领域事件\\n来自领域驱动设计（DDD）。\\n\\n## 上下文\\n\\n服务在更新其数据时通常需要发布事件。例如，可能需要这些事件来更新CQRS视图，或者该服务可能参与基于编排的saga，使用事件进行协调。\\n\\n## 问题\\n\\n在服务在更新数据时，如何发布事件？\\n\\n## 解决方案\\n\\n将服务的业务逻辑组织为 DDD 的**聚合**的集合，这些聚合在创建或更新时发出领域事件。服务发布这些领域事件，便于其它服务使用。\\n\\n## 关联模式\\n\\n- 在** Saga 和 CQRS 模式下需要这种模式\\n- **聚合模式**用于构建业务逻辑\\n- 事务发件箱模式用于将事件作为数据库事务的一部分发布\\n- 事件溯源有时用于发布领域事件\\n\\n## 推荐阅读\\n\\n- 《微服务架构设计模式》书中更详细的描述了这种模式。\\n\\n\\n全文完\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>原文：<a href=\"https://microservices.io/patterns/data/domain-event.html\">https://microservices.io/patterns/data/domain-event.html</a><br>\n译文：杨金龙</p>\n</blockquote>\n<h2 id=\"%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6\">领域事件</h2>\n<p>来自领域驱动设计（DDD）。</p>\n<h2 id=\"%E4%B8%8A%E4%B8%8B%E6%96%87\">上下文</h2>\n<p>服务在更新其数据时通常需要发布事件。例如，可能需要这些事件来更新CQRS视图，或者该服务可能参与基于编排的saga，使用事件进行协调。</p>\n<h2 id=\"%E9%97%AE%E9%A2%98\">问题</h2>\n<p>在服务在更新数据时，如何发布事件？</p>\n<h2 id=\"%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">解决方案</h2>\n<p>将服务的业务逻辑组织为 DDD 的<strong>聚合</strong>的集合，这些聚合在创建或更新时发出领域事件。服务发布这些领域事件，便于其它服务使用。</p>\n<h2 id=\"%E5%85%B3%E8%81%94%E6%A8%A1%E5%BC%8F\">关联模式</h2>\n<ul>\n<li>在** Saga 和 CQRS 模式下需要这种模式</li>\n<li><strong>聚合模式</strong>用于构建业务逻辑</li>\n<li>事务发件箱模式用于将事件作为数据库事务的一部分发布</li>\n<li>事件溯源有时用于发布领域事件</li>\n</ul>\n<h2 id=\"%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB\">推荐阅读</h2>\n<ul>\n<li>《微服务架构设计模式》书中更详细的描述了这种模式。</li>\n</ul>\n<p>全文完</p>\n<!--kg-card-end: markdown-->","comment_id":"62372731ce958b0001b30cab","plaintext":"> 原文：https://microservices.io/patterns/data/domain-event.html\n译文：杨金龙\n\n\n领域事件\n来自领域驱动设计（DDD）。\n\n上下文\n服务在更新其数据时通常需要发布事件。例如，可能需要这些事件来更新CQRS视图，或者该服务可能参与基于编排的saga，使用事件进行协调。\n\n问题\n在服务在更新数据时，如何发布事件？\n\n解决方案\n将服务的业务逻辑组织为 DDD 的聚合的集合，这些聚合在创建或更新时发出领域事件。服务发布这些领域事件，便于其它服务使用。\n\n关联模式\n * 在** Saga 和 CQRS 模式下需要这种模式\n * 聚合模式用于构建业务逻辑\n * 事务发件箱模式用于将事件作为数据库事务的一部分发布\n * 事件溯源有时用于发布领域事件\n\n推荐阅读\n * 《微服务架构设计模式》书中更详细的描述了这种模式。\n\n全文完","feature_image":"__GHOST_URL__/content/images/2022/03/domain-event.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2022-03-20 13:08:01","created_by":"1","updated_at":"2022-04-04 18:05:23","updated_by":"1","published_at":"2022-03-20 13:24:31","published_by":"1","custom_excerpt":"服务在更新其数据时通常需要发布事件。例如，可能需要这些事件来更新CQRS视图，或者该服务可能参与基于编排的saga，使用事件进行协调。","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"62372c67ce958b0001b30cec","uuid":"a23fbbce-114f-4fd5-9200-c07c9fc8f36b","title":"命令查询职责隔离（CQRS）","slug":"cqrs","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"# 命令查询职责隔离（CQRS）\\n\\n## 上下文\\n\\n我们已经使用了微服务架构模式和每个服务使用一个数据库模式。因此，实现连接来自多个服务的数据的查询不再简单。此外，如果我们使用了事件溯源模式，则不再容易查询数据。\\n\\n## 问题\\n\\n如何在微服务架构中实现多个服务中检索数据的查询？\\n\\n## 解决方案\\n\\n定义一个视图数据库，它是一个只读副本，目的在于支持查询。应用通过订阅拥有数据的服务发布的领域事件来保持副本与数据一致。\\n\\n![QuerySideService](__GHOST_URL__/content/images/2022/03/QuerySideService.png)\\n\\n## 例子\\n\\n- 微服务架构设计模式书中的FTGO示例应用有`Order History Service`，它实现了这种模式\\n\\n- 几个基于Eventuate的示例应用说明了如何使用此模式\\n\\n## 结果上下文\\n\\n这种模式的好处\\n\\n- 支持多个可扩展且高性能的非规范化视图\\n- 改进的关注点分离 = 更简单的命令和查询模型\\n- 在事件源架构中是必须的\\n\\n这种模式的弊端\\n\\n- 增加复杂度\\n- 潜在的代码重复\\n- 复制之后/最终一致的视图\\n\\n## 相关模式\\n\\n- 在每个服务一个数据库模式下需要这种模式\\n- API组合模型是一种替代解决方案\\n- 领域事件模式生成事件\\n- CQRS通常与事件溯源一起使用\\n\\n## 推荐阅读\\n \\n- [Eventuate](http://eventuate.io/), 一个用于开发事务性业务应用的平台\\n- 《微服务架构设计模式》\\n- [CQRS Pattern With Spring Boot](https://www.vinsguru.com/cqrs-pattern/)\\n- [Observations on using the CQRS Pattern in HMH](https://hmh.engineering/cqrs-pattern-94c27d4b9a68)\\n\\n> 原文：https://microservices.io/patterns/data/cqrs.html\\n\\n全文完\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><h1 id=\"%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E9%9A%94%E7%A6%BB%EF%BC%88cqrs%EF%BC%89\">命令查询职责隔离（CQRS）</h1>\n<h2 id=\"%E4%B8%8A%E4%B8%8B%E6%96%87\">上下文</h2>\n<p>我们已经使用了微服务架构模式和每个服务使用一个数据库模式。因此，实现连接来自多个服务的数据的查询不再简单。此外，如果我们使用了事件溯源模式，则不再容易查询数据。</p>\n<h2 id=\"%E9%97%AE%E9%A2%98\">问题</h2>\n<p>如何在微服务架构中实现多个服务中检索数据的查询？</p>\n<h2 id=\"%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\">解决方案</h2>\n<p>定义一个视图数据库，它是一个只读副本，目的在于支持查询。应用通过订阅拥有数据的服务发布的领域事件来保持副本与数据一致。</p>\n<p><img src=\"__GHOST_URL__/content/images/2022/03/QuerySideService.png\" alt=\"QuerySideService\" loading=\"lazy\"></p>\n<h2 id=\"%E4%BE%8B%E5%AD%90\">例子</h2>\n<ul>\n<li>\n<p>微服务架构设计模式书中的FTGO示例应用有<code>Order History Service</code>，它实现了这种模式</p>\n</li>\n<li>\n<p>几个基于Eventuate的示例应用说明了如何使用此模式</p>\n</li>\n</ul>\n<h2 id=\"%E7%BB%93%E6%9E%9C%E4%B8%8A%E4%B8%8B%E6%96%87\">结果上下文</h2>\n<p>这种模式的好处</p>\n<ul>\n<li>支持多个可扩展且高性能的非规范化视图</li>\n<li>改进的关注点分离 = 更简单的命令和查询模型</li>\n<li>在事件源架构中是必须的</li>\n</ul>\n<p>这种模式的弊端</p>\n<ul>\n<li>增加复杂度</li>\n<li>潜在的代码重复</li>\n<li>复制之后/最终一致的视图</li>\n</ul>\n<h2 id=\"%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%BC%8F\">相关模式</h2>\n<ul>\n<li>在每个服务一个数据库模式下需要这种模式</li>\n<li>API组合模型是一种替代解决方案</li>\n<li>领域事件模式生成事件</li>\n<li>CQRS通常与事件溯源一起使用</li>\n</ul>\n<h2 id=\"%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB\">推荐阅读</h2>\n<ul>\n<li><a href=\"http://eventuate.io/\">Eventuate</a>, 一个用于开发事务性业务应用的平台</li>\n<li>《微服务架构设计模式》</li>\n<li><a href=\"https://www.vinsguru.com/cqrs-pattern/\">CQRS Pattern With Spring Boot</a></li>\n<li><a href=\"https://hmh.engineering/cqrs-pattern-94c27d4b9a68\">Observations on using the CQRS Pattern in HMH</a></li>\n</ul>\n<blockquote>\n<p>原文：<a href=\"https://microservices.io/patterns/data/cqrs.html\">https://microservices.io/patterns/data/cqrs.html</a></p>\n</blockquote>\n<p>全文完</p>\n<!--kg-card-end: markdown-->","comment_id":"62372c67ce958b0001b30cec","plaintext":"命令查询职责隔离（CQRS）\n上下文\n我们已经使用了微服务架构模式和每个服务使用一个数据库模式。因此，实现连接来自多个服务的数据的查询不再简单。此外，如果我们使用了事件溯源模式，则不再容易查询数据。\n\n问题\n如何在微服务架构中实现多个服务中检索数据的查询？\n\n解决方案\n定义一个视图数据库，它是一个只读副本，目的在于支持查询。应用通过订阅拥有数据的服务发布的领域事件来保持副本与数据一致。\n\n\n\n例子\n * 微服务架构设计模式书中的FTGO示例应用有Order History Service，它实现了这种模式\n   \n   \n * 几个基于Eventuate的示例应用说明了如何使用此模式\n   \n   \n\n结果上下文\n这种模式的好处\n\n * 支持多个可扩展且高性能的非规范化视图\n * 改进的关注点分离 = 更简单的命令和查询模型\n * 在事件源架构中是必须的\n\n这种模式的弊端\n\n * 增加复杂度\n * 潜在的代码重复\n * 复制之后/最终一致的视图\n\n相关模式\n * 在每个服务一个数据库模式下需要这种模式\n * API组合模型是一种替代解决方案\n * 领域事件模式生成事件\n * CQRS通常与事件溯源一起使用\n\n推荐阅读\n * Eventuate [http://eventuate.io/], 一个用于开发事务性业务应用的平台\n * 《微服务架构设计模式》\n * CQRS Pattern With Spring Boot [https://www.vinsguru.com/cqrs-pattern/]\n * Observations on using the CQRS Pattern in HMH\n   [https://hmh.engineering/cqrs-pattern-94c27d4b9a68]\n\n> 原文：https://microservices.io/patterns/data/cqrs.html\n\n\n全文完","feature_image":"__GHOST_URL__/content/images/2022/03/cqrs.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2022-03-20 13:30:15","created_by":"1","updated_at":"2022-03-20 14:24:34","updated_by":"1","published_at":"2022-03-20 13:36:02","published_by":"1","custom_excerpt":"我们已经使用了微服务架构模式和每个服务使用一个数据库模式。因此，实现连接来自多个服务的数据的查询不再简单。此外，如果我们使用了事件溯源模式，则不再容易查询数据。","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"62487ed9c89ec800015caa41","uuid":"618d7dd5-cef7-473c-96fa-5465782616b8","title":"VMware 下 Ubuntu Server配置静态IP","slug":"vmware-ubuntu-server-static-ip-configuration","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> Ubuntu 版本为 21.10 \\n\\n\\n网络适配器设置为：NAT模式\\n![Snipaste_2022-04-03_00-41-46](__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-41-46.png)\\n\\n使用`ip a` 查看，此时IP为动态获取\\n\\n![dynamic-ens33](__GHOST_URL__/content/images/2022/04/dynamic-ens33.png)\\n\\n查看 `netplan`配置文件，此时`dhcp4`值为`true`\\n\\n```shell\\nless /etc/netplan/00-install-config.yaml\\n```\\n\\n![dynamic-ens33-config](__GHOST_URL__/content/images/2022/04/dynamic-ens33-config.png)\\n\\n查看网关地址：编辑->虚拟网络管理器->NAT设置->网关IP\\n\\n![449E7CC7-D1CA-4e33-8696-194FF93D80EB](__GHOST_URL__/content/images/2022/04/449E7CC7-D1CA-4e33-8696-194FF93D80EB.png)\\n\\n![Snipaste_2022-04-03_00-43-01](__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-43-01.png)\\n\\n![Snipaste_2022-04-03_00-43-41](__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-43-41.png)\\n\\n\\n修改 `netplan`配置文件\\n\\n```shell\\nsudo vim /etc/netplan/00-install-config.yaml\\n```\\n\\n```shell\\nnetwork:\\n  version: 2\\n  renderer: networkd\\n  ethernets:\\n    ens33:\\n     dhcp4: false\\n     addresses:\\n       - 192.168.133.10/24\\n     routes:\\n       - to: default\\n         via: 192.168.133.2\\n     nameservers:\\n       addresses: [192.168.133.2]\\n\\n```\\n![static-config](__GHOST_URL__/content/images/2022/04/static-config.png)\\n\\n使配置生效\\n\\n```shell\\nsudo netplan apply\\n```\\n\\n使用`ip a` 查看配置后的IP，可以看到`ens33`已经变成静态地址了\\n\\n![Snipaste_2022-04-03_00-44-45](__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-44-45.png)\\n\\n使用ssh工具可连接\\n\\n![Snipaste_2022-04-03_01-11-47](__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_01-11-47.png)\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>Ubuntu 版本为 21.10</p>\n</blockquote>\n<p>网络适配器设置为：NAT模式<br>\n<img src=\"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-41-46.png\" alt=\"Snipaste_2022-04-03_00-41-46\" loading=\"lazy\"></p>\n<p>使用<code>ip a</code> 查看，此时IP为动态获取</p>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/dynamic-ens33.png\" alt=\"dynamic-ens33\" loading=\"lazy\"></p>\n<p>查看 <code>netplan</code>配置文件，此时<code>dhcp4</code>值为<code>true</code></p>\n<pre><code class=\"language-shell\">less /etc/netplan/00-install-config.yaml\n</code></pre>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/dynamic-ens33-config.png\" alt=\"dynamic-ens33-config\" loading=\"lazy\"></p>\n<p>查看网关地址：编辑-&gt;虚拟网络管理器-&gt;NAT设置-&gt;网关IP</p>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/449E7CC7-D1CA-4e33-8696-194FF93D80EB.png\" alt=\"449E7CC7-D1CA-4e33-8696-194FF93D80EB\" loading=\"lazy\"></p>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-43-01.png\" alt=\"Snipaste_2022-04-03_00-43-01\" loading=\"lazy\"></p>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-43-41.png\" alt=\"Snipaste_2022-04-03_00-43-41\" loading=\"lazy\"></p>\n<p>修改 <code>netplan</code>配置文件</p>\n<pre><code class=\"language-shell\">sudo vim /etc/netplan/00-install-config.yaml\n</code></pre>\n<pre><code class=\"language-shell\">network:\n  version: 2\n  renderer: networkd\n  ethernets:\n    ens33:\n     dhcp4: false\n     addresses:\n       - 192.168.133.10/24\n     routes:\n       - to: default\n         via: 192.168.133.2\n     nameservers:\n       addresses: [192.168.133.2]\n\n</code></pre>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/static-config.png\" alt=\"static-config\" loading=\"lazy\"></p>\n<p>使配置生效</p>\n<pre><code class=\"language-shell\">sudo netplan apply\n</code></pre>\n<p>使用<code>ip a</code> 查看配置后的IP，可以看到<code>ens33</code>已经变成静态地址了</p>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_00-44-45.png\" alt=\"Snipaste_2022-04-03_00-44-45\" loading=\"lazy\"></p>\n<p>使用ssh工具可连接</p>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_01-11-47.png\" alt=\"Snipaste_2022-04-03_01-11-47\" loading=\"lazy\"></p>\n<!--kg-card-end: markdown-->","comment_id":"62487ed9c89ec800015caa41","plaintext":"> Ubuntu 版本为 21.10\n\n\n网络适配器设置为：NAT模式\n\n\n使用ip a 查看，此时IP为动态获取\n\n\n\n查看 netplan配置文件，此时dhcp4值为true\n\nless /etc/netplan/00-install-config.yaml\n\n\n\n\n查看网关地址：编辑->虚拟网络管理器->NAT设置->网关IP\n\n\n\n\n\n\n\n修改 netplan配置文件\n\nsudo vim /etc/netplan/00-install-config.yaml\n\n\nnetwork:\n  version: 2\n  renderer: networkd\n  ethernets:\n    ens33:\n     dhcp4: false\n     addresses:\n       - 192.168.133.10/24\n     routes:\n       - to: default\n         via: 192.168.133.2\n     nameservers:\n       addresses: [192.168.133.2]\n\n\n\n\n\n使配置生效\n\nsudo netplan apply\n\n\n使用ip a 查看配置后的IP，可以看到ens33已经变成静态地址了\n\n\n\n使用ssh工具可连接","feature_image":"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-03_01-17-04-1.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2022-04-02 16:50:33","created_by":"1","updated_at":"2022-04-02 17:18:05","updated_by":"1","published_at":"2022-04-02 17:14:54","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"624b3187c89ec800015caac5","uuid":"6d72540f-6e5b-4920-a0f7-5468454bd671","title":"VMware CentOS Hadoop环境准备","slug":"vmware-centos-hadoop","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"### 一、配置网络\\n\\n虚拟机网络使用`NAT`模式，网络配置为静态IP，方便节点间通信\\n\\n`vi /etc/sysconfig/network-scripts/ifcfg-ens33`\\n\\n``` shell\\n# 网络类型\\nTYPE=Ethernet\\nNAME=ens33\\nUUID=89e7972a-6f3e-4981-8cde-96cd005dfc46\\n# 网卡设备\\nDEVICE=ens33\\nONBOOT=yes\\nBOOTPROTO=static\\nIPADDR=192.168.133.101\\nGATEWAY=192.168.133.2\\nDNS1=192.168.133.2\\n```\\n\\n### 二、配置hostname和hosts\\n\\n> 为搭建Hadoop集群，计划准备3台虚拟机，为方便通信，使用统一的hostname命名规则，本次使用\\\"hadoop+IP地址末位\\\"的形式，hostname命名为\\\"hadoop101\\\"、\\\"hadoop102\\\"、\\\"hadoop103\\\"\\n\\n修改hostname\\n\\n`vi /etc/sysconfig/network`\\n\\n```shell\\nNETWORKING=yes\\nNETWORKING_IPV6=no\\nHOSTNAME=hadoop101\\n```\\n\\n修改hosts文件\\n\\n`vi /etc/hosts`\\n\\n```\\n192.168.133.101 hadoop101\\n192.168.133.102 hadoop102\\n192.168.133.103 hadoop103\\n```\\n\\n### 三、关闭防火墙\\n\\n查看防火墙状态\\n\\n```shell\\nfirewall-cmd --state\\n```\\n\\n停止firewall\\n\\n```shell\\nsystemctl stop firewalld.service\\n```\\n\\n禁止firewall开机启动\\n\\n```shell\\nsystemctl disable firewalld.service \\n```\\n\\n### 四、克隆虚拟机\\n\\n配置完成后，克隆虚拟机，修改IP\\n\\n### 五、ssh免密登录\\n\\n先从101通过ssh手动登录102、103\\n\\n```\\nssh root@hadoop102\\nssh root@hadoop102\\nssh root@hadoop102\\n```\\n\\n进入.ssh目录\\n\\n```shell\\ncd ~/.ssh\\n```\\n\\n生成公钥和私钥\\n\\n```shell\\nssh-keygen -t rsa\\n```\\n\\n把公钥复制到其它服务器上\\n\\n```shell\\nssh-copy-id hadoop102\\nssh-copy-id hadoop103\\n```\\n\\n### 六、服务器时间设置\\n\\n设置时区为中国标准时间\\n\\n```shell\\n[root@hadoop101 ~]# timedatectl set-timezone Asia/Shanghai\\n[root@hadoop101 ~]# timedatectl status\\n      Local time: Mon 2022-04-04 18:21:12 CST\\n  Universal time: Mon 2022-04-04 10:21:12 UTC\\n        RTC time: Mon 2022-04-04 10:21:13\\n       Time zone: Asia/Shanghai (CST, +0800)\\n     NTP enabled: yes\\nNTP synchronized: yes\\n RTC in local TZ: no\\n      DST active: n/a\\n```\\n\\n\\n\\n安装ntp，启动ntpd服务，设置ntpd自动启动\\n\\n> 注： 只需要在hadoop101上安装和配置ntp，指定向服务器自身进行时钟同步，其它节点通过定时任务定时从101同步时间\\n\\n```shell\\nyum install ntp -y\\nsystemctl start ntpd\\nsystemctl enable ntpd\\n```\\n\\n修改ntp配置文件 `vi /etc/ntp.conf`\\n\\n``` \\n# 指定接收192.168.133.0网段的客户端的同步请求\\nrestrict 192.168.133.0 mask 255.255.255.0 nomodify notrap\\n\\n\\n# Use public servers from the pool.ntp.org project.\\n# Please consider joining the pool (http://www.pool.ntp.org/join.html).\\n# 注释掉，不使用ntp服务器\\n#server 0.centos.pool.ntp.org iburst\\n#server 1.centos.pool.ntp.org iburst\\n#server 2.centos.pool.ntp.org iburst\\n#server 3.centos.pool.ntp.org iburst\\n\\n# 指定向服务器自身进行时钟同步\\nserver 127.127.1.0\\nfudge 127.127.1.0 stratum 10\\n```\\n\\n### 七、集群同步文件\\n\\n`rsync` 命令可以在服务器间同步数据，例如`rsync -rv /path/something root@hadoop102:/path/`，可以将something这个目录或文件同步到hadoop102节点。\\n\\n编写一个集群同步文件的脚本，实现循环复制文件到所有节点服务器的相同目录。\\n\\n在/root目录下新建bin目录，在bin目录下新建一个xsync文件，使用chmod +x xsync为其增加执行权限；脚本使用方法：`xsync 目录或文件名`。\\n\\n脚本内容如下：\\n\\n```shell\\n#!/bin/bash\\n\\n# 循环复制文件到所有节点服务器的相同目录\\n\\n# 判断输入参数的个数\\npcount=$#\\nif((pcount==0));then\\necho no args;\\nexit;\\nfi\\n\\n# 获取文件名\\np1=$1\\nfname=`basename $p1`\\necho fname=$fname\\n\\n# 获取文件所在路径\\npdir=`cd -P $(dirname $p1); pwd`\\n\\necho pdir=$pdir\\n\\n# 当前用户名\\nuser=`whoami`\\n\\n# 服务器的hostname命名为hadoop101、hadoop102、hadoop103\\n# 在循环中拼接hostname并使用rsync将同步文件\\nfor((host=102; host<104; host++)); do\\n        echo --------hadoop$host--------\\n        rsync -rvl $pdir/$fname $user@hadoop$host:$pdir\\ndone\\n```\\n\\n### 八、安装JDK和Hadoop\\n\\n在hadoop101上安装好`jdk1.8`和`hadoop2.10.1`，并在/etc/profile下配置好环境变量\\n\\n```shell\\nexport JAVA_HOME=/opt/module/jdk1.8.0_202\\nexport PATH=$PATH:$JAVA_HOME/bin\\n\\nexport HADOOP_HOME=/opt/module/hadoop-2.10.1\\nexport PATH=$PATH:$HADOOP_HOME/bin\\nexport PATH=$PATH:$HADOOP_HOME/sbin\\n\\n```\\n\\n然后使用xsync脚本同步到其它节点。\\n\\n```shell\\nxsync /opt/module/jdk1.8.0_202\\nxsync /opt/module/hadoop-2.10.1\\nxsync /etc/profile\\n```\\n\\n在各个服务器上执行`source /etc/profile`，使配置生效。\\n\\n### 九、Hadoop分布式集群部署\\n\\n- 集群部署规划\\n\\n|      | hadoop101             | hadoop102                       | hadoop103         |\\n| ---- | --------------------- | ------------------------------- | ----------------- |\\n| HDFS | NameNode<br/>DataNode | DataNode                        | SecondaryNameNode |\\n| YARN | NodeManager           | ResourceManager<br/>NodeManager | NodeManager       |\\n\\n\\n\\n- **配置hadoop核心配置文件**`vim /opt/module/hadoop-2.10.1/etc/hadoop/core-site.xml`\\n\\n```xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"configuration.xsl\\\"?>\\n<configuration>\\n        <property>\\n                <name>fs.defaultFS</name>\\n                <value>hdfs://hadoop101:9000</value>\\n        </property>\\n\\n        <property>\\n                <name>hadoop.tmp.dir</name>\\n                <value>/opt/module/hadoop-2.10.1/data/tmp</value>\\n        </property>\\n\\n</configuration>\\n\\n```\\n\\n- **配置HDFS** `vim /opt/module/hadoop-2.10.1/etc/hadoop/hdfs-site.xml`\\n\\n```xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"configuration.xsl\\\"?>\\n<!--\\n  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n  you may not use this file except in compliance with the License.\\n  You may obtain a copy of the License at\\n\\n    http://www.apache.org/licenses/LICENSE-2.0\\n\\n  Unless required by applicable law or agreed to in writing, software\\n  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n  See the License for the specific language governing permissions and\\n  limitations under the License. See accompanying LICENSE file.\\n-->\\n\\n<!-- Put site-specific property overrides in this file. -->\\n\\n<configuration>\\n        <property>\\n                <name>dfs.replication</name>\\n                <value>3</value>\\n        </property>\\n\\n        <property>\\n                <name>dfs.namenode.secondary.http-address</name>\\n                <value>hadoop103:50090</value>\\n        </property>\\n\\n\\n</configuration>\\n\\n```\\n\\n- **配置YARN**`vim /opt/module/hadoop-2.10.1/etc/hadoop/yarn-site.xml`\\n\\n```xml\\n<?xml version=\\\"1.0\\\"?>\\n\\n<configuration>\\n\\n<!-- Site specific YARN configuration properties -->\\n        <property>\\n                <name>yarn.nodemanager.aux-services</name>\\n                <value>mapreduce_shuffle</value>\\n        </property>\\n\\n        <property>\\n                <name>yarn.resourcemanager.hostname</name>\\n                <value>hadoop102</value>\\n        </property>\\n\\n\\n</configuration>\\n\\n```\\n\\n- **配置MapReduce**`vim /opt/module/hadoop-2.10.1/etc/hadoop/mapred-site.xml`\\n\\n```xml\\n<?xml version=\\\"1.0\\\"?>\\n<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"configuration.xsl\\\"?>\\n<configuration>\\n        <property>\\n                <name>mapreduce.framework.name</name>\\n                <value>yarn</value>\\n        </propterty>\\n\\n</configuration>\\n\\n```\\n\\n- **配置JAVA_HOME**，否则找不到报JAVA_HOME，在`hadoop-env.sh`、`yarn-env.sh`、`mapred-env.sh`这三个脚本中添加 `export JAVA_HOME=/opt/module/jdk1.8.0_202`\\n\\n- **配置slaves** \\n\\n  ```shell\\n  vim /opt/module/hadoop-2.10.1/etc/hadoop/slaves\\n  hadoop101\\n  hadoop102\\n  hadoop103\\n  ```\\n\\n- **创建数据目录** `cd /opt/module/hadoop-2.10.1/ &&  mkdir data && cd data && mkdir tmp`\\n\\n- **集群分发配置文件** `xsync /opt/module/hadoop-2.10.1/`\\n\\n- 初次启动集群，需要执行`hadoop namenode -format`\\n\\n- **启动HDFS**\\n\\n```shell\\n[root@hadoop101 hadoop-2.10.1]# sbin/start-dfs.sh\\nStarting namenodes on [hadop101]\\nhadop101: starting namenode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-namenode-hadoop101.out\\nhadoop102: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop102.out\\nhadoop103: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop103.out\\nhadoop101: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop101.out\\nStarting secondary namenodes [hadop103]\\nhadop103: starting secondarynamenode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-secondarynamenode-hadoop101.out\\n```\\n\\n- 启动YARN\\n\\n  去ResourceManager所在的服务器102上启动YARN\\n\\n  ```shell\\n  [root@hadoop102 hadoop-2.10.1]# sbin/start-yarn.sh\\n  starting yarn daemons\\n  starting resourcemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-resourcemanager-hadoop102.out\\n  hadoop101: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop101.out\\n  hadoop103: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop103.out\\n  hadoop102: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop102.out\\n  [root@hadoop102 hadoop-2.10.1]# jps\\n  14448 ResourceManager\\n  14592 Jps\\n  14552 NodeManager\\n  12956 DataNode\\n  ```\\n\\n- **访问HDFS** `http://hadoop101:50070/dfshealth.html#tab-overview`\\n\\n![hdfs](__GHOST_URL__/content/images/2022/04/hdfs.png)\\n\\n- **访问YARN ResourceManage**  `http://hadoop102:8088/cluster`\\n\\n![yarn](__GHOST_URL__/content/images/2022/04/yarn.png)\\n\\n- 运行PI实例，检查集群是否启动成功\\n\\n```shell\\n[root@hadoop101 mapreduce]# cd /opt/module/hadoop-2.10.1/share/hadoop/mapreduce\\n\\n[root@hadoop101 mapreduce]# ls\\nhadoop-mapreduce-client-app-2.10.1.jar         hadoop-mapreduce-client-jobclient-2.10.1.jar        lib\\nhadoop-mapreduce-client-common-2.10.1.jar      hadoop-mapreduce-client-jobclient-2.10.1-tests.jar  lib-examples\\nhadoop-mapreduce-client-core-2.10.1.jar        hadoop-mapreduce-client-shuffle-2.10.1.jar          sources\\nhadoop-mapreduce-client-hs-2.10.1.jar          hadoop-mapreduce-examples-2.10.1.jar\\nhadoop-mapreduce-client-hs-plugins-2.10.1.jar  jdiff\\n\\n[root@hadoop101 mapreduce]# hadoop jar hadoop-mapreduce-examples-2.10.1.jar pi 10 10\\nNumber of Maps  = 10\\nSamples per Map = 10\\nWrote input for Map #0\\nWrote input for Map #1\\nWrote input for Map #2\\nWrote input for Map #3\\nWrote input for Map #4\\nWrote input for Map #5\\nWrote input for Map #6\\nWrote input for Map #7\\nWrote input for Map #8\\nWrote input for Map #9\\nStarting Job\\n22/04/05 01:22:27 INFO client.RMProxy: Connecting to ResourceManager at hadoop102/192.168.133.102:8032\\n22/04/05 01:22:28 INFO input.FileInputFormat: Total input files to process : 10\\n22/04/05 01:22:28 INFO mapreduce.JobSubmitter: number of splits:10\\n22/04/05 01:22:28 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1649091969708_0002\\n22/04/05 01:22:28 INFO conf.Configuration: resource-types.xml not found\\n22/04/05 01:22:28 INFO resource.ResourceUtils: Unable to find 'resource-types.xml'.\\n22/04/05 01:22:28 INFO resource.ResourceUtils: Adding resource type - name = memory-mb, units = Mi, type = COUNTABLE\\n22/04/05 01:22:28 INFO resource.ResourceUtils: Adding resource type - name = vcores, units = , type = COUNTABLE\\n22/04/05 01:22:29 INFO impl.YarnClientImpl: Submitted application application_1649091969708_0002\\n22/04/05 01:22:29 INFO mapreduce.Job: The url to track the job: http://hadoop102:8088/proxy/application_1649091969708_0002/\\n22/04/05 01:22:29 INFO mapreduce.Job: Running job: job_1649091969708_0002\\n22/04/05 01:22:38 INFO mapreduce.Job: Job job_1649091969708_0002 running in uber mode : false\\n22/04/05 01:22:38 INFO mapreduce.Job:  map 0% reduce 0%\\n22/04/05 01:22:51 INFO mapreduce.Job:  map 20% reduce 0%\\n22/04/05 01:23:10 INFO mapreduce.Job:  map 20% reduce 7%\\n22/04/05 01:23:21 INFO mapreduce.Job:  map 50% reduce 7%\\n22/04/05 01:23:26 INFO mapreduce.Job:  map 70% reduce 7%\\n22/04/05 01:23:27 INFO mapreduce.Job:  map 100% reduce 7%\\n22/04/05 01:23:28 INFO mapreduce.Job:  map 100% reduce 100%\\n22/04/05 01:23:29 INFO mapreduce.Job: Job job_1649091969708_0002 completed successfully\\n22/04/05 01:23:29 INFO mapreduce.Job: Counters: 49\\n        File System Counters\\n                FILE: Number of bytes read=226\\n                FILE: Number of bytes written=2298230\\n                FILE: Number of read operations=0\\n                FILE: Number of large read operations=0\\n                FILE: Number of write operations=0\\n                HDFS: Number of bytes read=2630\\n                HDFS: Number of bytes written=215\\n                HDFS: Number of read operations=43\\n                HDFS: Number of large read operations=0\\n                HDFS: Number of write operations=3\\n        Job Counters\\n                Launched map tasks=10\\n                Launched reduce tasks=1\\n                Data-local map tasks=10\\n                Total time spent by all maps in occupied slots (ms)=373219\\n                Total time spent by all reduces in occupied slots (ms)=34501\\n                Total time spent by all map tasks (ms)=373219\\n                Total time spent by all reduce tasks (ms)=34501\\n                Total vcore-milliseconds taken by all map tasks=373219\\n                Total vcore-milliseconds taken by all reduce tasks=34501\\n                Total megabyte-milliseconds taken by all map tasks=382176256\\n                Total megabyte-milliseconds taken by all reduce tasks=35329024\\n        Map-Reduce Framework\\n                Map input records=10\\n                Map output records=20\\n                Map output bytes=180\\n                Map output materialized bytes=280\\n                Input split bytes=1450\\n                Combine input records=0\\n                Combine output records=0\\n                Reduce input groups=2\\n                Reduce shuffle bytes=280\\n                Reduce input records=20\\n                Reduce output records=0\\n                Spilled Records=40\\n                Shuffled Maps =10\\n                Failed Shuffles=0\\n                Merged Map outputs=10\\n                GC time elapsed (ms)=7721\\n                CPU time spent (ms)=13550\\n                Physical memory (bytes) snapshot=2082910208\\n                Virtual memory (bytes) snapshot=22879621120\\n                Total committed heap usage (bytes)=1383833600\\n        Shuffle Errors\\n                BAD_ID=0\\n                CONNECTION=0\\n                IO_ERROR=0\\n                WRONG_LENGTH=0\\n                WRONG_MAP=0\\n                WRONG_REDUCE=0\\n        File Input Format Counters\\n                Bytes Read=1180\\n        File Output Format Counters\\n                Bytes Written=97\\nJob Finished in 62.362 seconds\\nEstimated value of Pi is 3.20000000000000000000\\n```\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><h3 id=\"%E4%B8%80%E3%80%81%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C\">一、配置网络</h3>\n<p>虚拟机网络使用<code>NAT</code>模式，网络配置为静态IP，方便节点间通信</p>\n<p><code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>\n<pre><code class=\"language-shell\"># 网络类型\nTYPE=Ethernet\nNAME=ens33\nUUID=89e7972a-6f3e-4981-8cde-96cd005dfc46\n# 网卡设备\nDEVICE=ens33\nONBOOT=yes\nBOOTPROTO=static\nIPADDR=192.168.133.101\nGATEWAY=192.168.133.2\nDNS1=192.168.133.2\n</code></pre>\n<h3 id=\"%E4%BA%8C%E3%80%81%E9%85%8D%E7%BD%AEhostname%E5%92%8Chosts\">二、配置hostname和hosts</h3>\n<blockquote>\n<p>为搭建Hadoop集群，计划准备3台虚拟机，为方便通信，使用统一的hostname命名规则，本次使用&quot;hadoop+IP地址末位&quot;的形式，hostname命名为&quot;hadoop101&quot;、&quot;hadoop102&quot;、&quot;hadoop103&quot;</p>\n</blockquote>\n<p>修改hostname</p>\n<p><code>vi /etc/sysconfig/network</code></p>\n<pre><code class=\"language-shell\">NETWORKING=yes\nNETWORKING_IPV6=no\nHOSTNAME=hadoop101\n</code></pre>\n<p>修改hosts文件</p>\n<p><code>vi /etc/hosts</code></p>\n<pre><code>192.168.133.101 hadoop101\n192.168.133.102 hadoop102\n192.168.133.103 hadoop103\n</code></pre>\n<h3 id=\"%E4%B8%89%E3%80%81%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99\">三、关闭防火墙</h3>\n<p>查看防火墙状态</p>\n<pre><code class=\"language-shell\">firewall-cmd --state\n</code></pre>\n<p>停止firewall</p>\n<pre><code class=\"language-shell\">systemctl stop firewalld.service\n</code></pre>\n<p>禁止firewall开机启动</p>\n<pre><code class=\"language-shell\">systemctl disable firewalld.service \n</code></pre>\n<h3 id=\"%E5%9B%9B%E3%80%81%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA\">四、克隆虚拟机</h3>\n<p>配置完成后，克隆虚拟机，修改IP</p>\n<h3 id=\"%E4%BA%94%E3%80%81ssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95\">五、ssh免密登录</h3>\n<p>先从101通过ssh手动登录102、103</p>\n<pre><code>ssh root@hadoop102\nssh root@hadoop102\nssh root@hadoop102\n</code></pre>\n<p>进入.ssh目录</p>\n<pre><code class=\"language-shell\">cd ~/.ssh\n</code></pre>\n<p>生成公钥和私钥</p>\n<pre><code class=\"language-shell\">ssh-keygen -t rsa\n</code></pre>\n<p>把公钥复制到其它服务器上</p>\n<pre><code class=\"language-shell\">ssh-copy-id hadoop102\nssh-copy-id hadoop103\n</code></pre>\n<h3 id=\"%E5%85%AD%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE\">六、服务器时间设置</h3>\n<p>设置时区为中国标准时间</p>\n<pre><code class=\"language-shell\">[root@hadoop101 ~]# timedatectl set-timezone Asia/Shanghai\n[root@hadoop101 ~]# timedatectl status\n      Local time: Mon 2022-04-04 18:21:12 CST\n  Universal time: Mon 2022-04-04 10:21:12 UTC\n        RTC time: Mon 2022-04-04 10:21:13\n       Time zone: Asia/Shanghai (CST, +0800)\n     NTP enabled: yes\nNTP synchronized: yes\n RTC in local TZ: no\n      DST active: n/a\n</code></pre>\n<p>安装ntp，启动ntpd服务，设置ntpd自动启动</p>\n<blockquote>\n<p>注： 只需要在hadoop101上安装和配置ntp，指定向服务器自身进行时钟同步，其它节点通过定时任务定时从101同步时间</p>\n</blockquote>\n<pre><code class=\"language-shell\">yum install ntp -y\nsystemctl start ntpd\nsystemctl enable ntpd\n</code></pre>\n<p>修改ntp配置文件 <code>vi /etc/ntp.conf</code></p>\n<pre><code># 指定接收192.168.133.0网段的客户端的同步请求\nrestrict 192.168.133.0 mask 255.255.255.0 nomodify notrap\n\n\n# Use public servers from the pool.ntp.org project.\n# Please consider joining the pool (http://www.pool.ntp.org/join.html).\n# 注释掉，不使用ntp服务器\n#server 0.centos.pool.ntp.org iburst\n#server 1.centos.pool.ntp.org iburst\n#server 2.centos.pool.ntp.org iburst\n#server 3.centos.pool.ntp.org iburst\n\n# 指定向服务器自身进行时钟同步\nserver 127.127.1.0\nfudge 127.127.1.0 stratum 10\n</code></pre>\n<h3 id=\"%E4%B8%83%E3%80%81%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6\">七、集群同步文件</h3>\n<p><code>rsync</code> 命令可以在服务器间同步数据，例如<code>rsync -rv /path/something root@hadoop102:/path/</code>，可以将something这个目录或文件同步到hadoop102节点。</p>\n<p>编写一个集群同步文件的脚本，实现循环复制文件到所有节点服务器的相同目录。</p>\n<p>在/root目录下新建bin目录，在bin目录下新建一个xsync文件，使用chmod +x xsync为其增加执行权限；脚本使用方法：<code>xsync 目录或文件名</code>。</p>\n<p>脚本内容如下：</p>\n<pre><code class=\"language-shell\">#!/bin/bash\n\n# 循环复制文件到所有节点服务器的相同目录\n\n# 判断输入参数的个数\npcount=$#\nif((pcount==0));then\necho no args;\nexit;\nfi\n\n# 获取文件名\np1=$1\nfname=`basename $p1`\necho fname=$fname\n\n# 获取文件所在路径\npdir=`cd -P $(dirname $p1); pwd`\n\necho pdir=$pdir\n\n# 当前用户名\nuser=`whoami`\n\n# 服务器的hostname命名为hadoop101、hadoop102、hadoop103\n# 在循环中拼接hostname并使用rsync将同步文件\nfor((host=102; host&lt;104; host++)); do\n        echo --------hadoop$host--------\n        rsync -rvl $pdir/$fname $user@hadoop$host:$pdir\ndone\n</code></pre>\n<h3 id=\"%E5%85%AB%E3%80%81%E5%AE%89%E8%A3%85jdk%E5%92%8Chadoop\">八、安装JDK和Hadoop</h3>\n<p>在hadoop101上安装好<code>jdk1.8</code>和<code>hadoop2.10.1</code>，并在/etc/profile下配置好环境变量</p>\n<pre><code class=\"language-shell\">export JAVA_HOME=/opt/module/jdk1.8.0_202\nexport PATH=$PATH:$JAVA_HOME/bin\n\nexport HADOOP_HOME=/opt/module/hadoop-2.10.1\nexport PATH=$PATH:$HADOOP_HOME/bin\nexport PATH=$PATH:$HADOOP_HOME/sbin\n\n</code></pre>\n<p>然后使用xsync脚本同步到其它节点。</p>\n<pre><code class=\"language-shell\">xsync /opt/module/jdk1.8.0_202\nxsync /opt/module/hadoop-2.10.1\nxsync /etc/profile\n</code></pre>\n<p>在各个服务器上执行<code>source /etc/profile</code>，使配置生效。</p>\n<h3 id=\"%E4%B9%9D%E3%80%81hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2\">九、Hadoop分布式集群部署</h3>\n<ul>\n<li>集群部署规划</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>hadoop101</th>\n<th>hadoop102</th>\n<th>hadoop103</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HDFS</td>\n<td>NameNode<br/>DataNode</td>\n<td>DataNode</td>\n<td>SecondaryNameNode</td>\n</tr>\n<tr>\n<td>YARN</td>\n<td>NodeManager</td>\n<td>ResourceManager<br/>NodeManager</td>\n<td>NodeManager</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>配置hadoop核心配置文件</strong><code>vim /opt/module/hadoop-2.10.1/etc/hadoop/core-site.xml</code></li>\n</ul>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;\n&lt;configuration&gt;\n        &lt;property&gt;\n                &lt;name&gt;fs.defaultFS&lt;/name&gt;\n                &lt;value&gt;hdfs://hadoop101:9000&lt;/value&gt;\n        &lt;/property&gt;\n\n        &lt;property&gt;\n                &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;\n                &lt;value&gt;/opt/module/hadoop-2.10.1/data/tmp&lt;/value&gt;\n        &lt;/property&gt;\n\n&lt;/configuration&gt;\n\n</code></pre>\n<ul>\n<li><strong>配置HDFS</strong> <code>vim /opt/module/hadoop-2.10.1/etc/hadoop/hdfs-site.xml</code></li>\n</ul>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;\n&lt;!--\n  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License. See accompanying LICENSE file.\n--&gt;\n\n&lt;!-- Put site-specific property overrides in this file. --&gt;\n\n&lt;configuration&gt;\n        &lt;property&gt;\n                &lt;name&gt;dfs.replication&lt;/name&gt;\n                &lt;value&gt;3&lt;/value&gt;\n        &lt;/property&gt;\n\n        &lt;property&gt;\n                &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;\n                &lt;value&gt;hadoop103:50090&lt;/value&gt;\n        &lt;/property&gt;\n\n\n&lt;/configuration&gt;\n\n</code></pre>\n<ul>\n<li><strong>配置YARN</strong><code>vim /opt/module/hadoop-2.10.1/etc/hadoop/yarn-site.xml</code></li>\n</ul>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot;?&gt;\n\n&lt;configuration&gt;\n\n&lt;!-- Site specific YARN configuration properties --&gt;\n        &lt;property&gt;\n                &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;\n                &lt;value&gt;mapreduce_shuffle&lt;/value&gt;\n        &lt;/property&gt;\n\n        &lt;property&gt;\n                &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;\n                &lt;value&gt;hadoop102&lt;/value&gt;\n        &lt;/property&gt;\n\n\n&lt;/configuration&gt;\n\n</code></pre>\n<ul>\n<li><strong>配置MapReduce</strong><code>vim /opt/module/hadoop-2.10.1/etc/hadoop/mapred-site.xml</code></li>\n</ul>\n<pre><code class=\"language-xml\">&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;\n&lt;configuration&gt;\n        &lt;property&gt;\n                &lt;name&gt;mapreduce.framework.name&lt;/name&gt;\n                &lt;value&gt;yarn&lt;/value&gt;\n        &lt;/propterty&gt;\n\n&lt;/configuration&gt;\n\n</code></pre>\n<ul>\n<li>\n<p><strong>配置JAVA_HOME</strong>，否则找不到报JAVA_HOME，在<code>hadoop-env.sh</code>、<code>yarn-env.sh</code>、<code>mapred-env.sh</code>这三个脚本中添加 <code>export JAVA_HOME=/opt/module/jdk1.8.0_202</code></p>\n</li>\n<li>\n<p><strong>配置slaves</strong></p>\n<pre><code class=\"language-shell\">vim /opt/module/hadoop-2.10.1/etc/hadoop/slaves\nhadoop101\nhadoop102\nhadoop103\n</code></pre>\n</li>\n<li>\n<p><strong>创建数据目录</strong> <code>cd /opt/module/hadoop-2.10.1/ &amp;&amp;  mkdir data &amp;&amp; cd data &amp;&amp; mkdir tmp</code></p>\n</li>\n<li>\n<p><strong>集群分发配置文件</strong> <code>xsync /opt/module/hadoop-2.10.1/</code></p>\n</li>\n<li>\n<p>初次启动集群，需要执行<code>hadoop namenode -format</code></p>\n</li>\n<li>\n<p><strong>启动HDFS</strong></p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">[root@hadoop101 hadoop-2.10.1]# sbin/start-dfs.sh\nStarting namenodes on [hadop101]\nhadop101: starting namenode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-namenode-hadoop101.out\nhadoop102: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop102.out\nhadoop103: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop103.out\nhadoop101: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop101.out\nStarting secondary namenodes [hadop103]\nhadop103: starting secondarynamenode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-secondarynamenode-hadoop101.out\n</code></pre>\n<ul>\n<li>\n<p>启动YARN</p>\n<p>去ResourceManager所在的服务器102上启动YARN</p>\n<pre><code class=\"language-shell\">[root@hadoop102 hadoop-2.10.1]# sbin/start-yarn.sh\nstarting yarn daemons\nstarting resourcemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-resourcemanager-hadoop102.out\nhadoop101: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop101.out\nhadoop103: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop103.out\nhadoop102: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop102.out\n[root@hadoop102 hadoop-2.10.1]# jps\n14448 ResourceManager\n14592 Jps\n14552 NodeManager\n12956 DataNode\n</code></pre>\n</li>\n<li>\n<p><strong>访问HDFS</strong> <code>http://hadoop101:50070/dfshealth.html#tab-overview</code></p>\n</li>\n</ul>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/hdfs.png\" alt=\"hdfs\" loading=\"lazy\"></p>\n<ul>\n<li><strong>访问YARN ResourceManage</strong>  <code>http://hadoop102:8088/cluster</code></li>\n</ul>\n<p><img src=\"__GHOST_URL__/content/images/2022/04/yarn.png\" alt=\"yarn\" loading=\"lazy\"></p>\n<ul>\n<li>运行PI实例，检查集群是否启动成功</li>\n</ul>\n<pre><code class=\"language-shell\">[root@hadoop101 mapreduce]# cd /opt/module/hadoop-2.10.1/share/hadoop/mapreduce\n\n[root@hadoop101 mapreduce]# ls\nhadoop-mapreduce-client-app-2.10.1.jar         hadoop-mapreduce-client-jobclient-2.10.1.jar        lib\nhadoop-mapreduce-client-common-2.10.1.jar      hadoop-mapreduce-client-jobclient-2.10.1-tests.jar  lib-examples\nhadoop-mapreduce-client-core-2.10.1.jar        hadoop-mapreduce-client-shuffle-2.10.1.jar          sources\nhadoop-mapreduce-client-hs-2.10.1.jar          hadoop-mapreduce-examples-2.10.1.jar\nhadoop-mapreduce-client-hs-plugins-2.10.1.jar  jdiff\n\n[root@hadoop101 mapreduce]# hadoop jar hadoop-mapreduce-examples-2.10.1.jar pi 10 10\nNumber of Maps  = 10\nSamples per Map = 10\nWrote input for Map #0\nWrote input for Map #1\nWrote input for Map #2\nWrote input for Map #3\nWrote input for Map #4\nWrote input for Map #5\nWrote input for Map #6\nWrote input for Map #7\nWrote input for Map #8\nWrote input for Map #9\nStarting Job\n22/04/05 01:22:27 INFO client.RMProxy: Connecting to ResourceManager at hadoop102/192.168.133.102:8032\n22/04/05 01:22:28 INFO input.FileInputFormat: Total input files to process : 10\n22/04/05 01:22:28 INFO mapreduce.JobSubmitter: number of splits:10\n22/04/05 01:22:28 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1649091969708_0002\n22/04/05 01:22:28 INFO conf.Configuration: resource-types.xml not found\n22/04/05 01:22:28 INFO resource.ResourceUtils: Unable to find 'resource-types.xml'.\n22/04/05 01:22:28 INFO resource.ResourceUtils: Adding resource type - name = memory-mb, units = Mi, type = COUNTABLE\n22/04/05 01:22:28 INFO resource.ResourceUtils: Adding resource type - name = vcores, units = , type = COUNTABLE\n22/04/05 01:22:29 INFO impl.YarnClientImpl: Submitted application application_1649091969708_0002\n22/04/05 01:22:29 INFO mapreduce.Job: The url to track the job: http://hadoop102:8088/proxy/application_1649091969708_0002/\n22/04/05 01:22:29 INFO mapreduce.Job: Running job: job_1649091969708_0002\n22/04/05 01:22:38 INFO mapreduce.Job: Job job_1649091969708_0002 running in uber mode : false\n22/04/05 01:22:38 INFO mapreduce.Job:  map 0% reduce 0%\n22/04/05 01:22:51 INFO mapreduce.Job:  map 20% reduce 0%\n22/04/05 01:23:10 INFO mapreduce.Job:  map 20% reduce 7%\n22/04/05 01:23:21 INFO mapreduce.Job:  map 50% reduce 7%\n22/04/05 01:23:26 INFO mapreduce.Job:  map 70% reduce 7%\n22/04/05 01:23:27 INFO mapreduce.Job:  map 100% reduce 7%\n22/04/05 01:23:28 INFO mapreduce.Job:  map 100% reduce 100%\n22/04/05 01:23:29 INFO mapreduce.Job: Job job_1649091969708_0002 completed successfully\n22/04/05 01:23:29 INFO mapreduce.Job: Counters: 49\n        File System Counters\n                FILE: Number of bytes read=226\n                FILE: Number of bytes written=2298230\n                FILE: Number of read operations=0\n                FILE: Number of large read operations=0\n                FILE: Number of write operations=0\n                HDFS: Number of bytes read=2630\n                HDFS: Number of bytes written=215\n                HDFS: Number of read operations=43\n                HDFS: Number of large read operations=0\n                HDFS: Number of write operations=3\n        Job Counters\n                Launched map tasks=10\n                Launched reduce tasks=1\n                Data-local map tasks=10\n                Total time spent by all maps in occupied slots (ms)=373219\n                Total time spent by all reduces in occupied slots (ms)=34501\n                Total time spent by all map tasks (ms)=373219\n                Total time spent by all reduce tasks (ms)=34501\n                Total vcore-milliseconds taken by all map tasks=373219\n                Total vcore-milliseconds taken by all reduce tasks=34501\n                Total megabyte-milliseconds taken by all map tasks=382176256\n                Total megabyte-milliseconds taken by all reduce tasks=35329024\n        Map-Reduce Framework\n                Map input records=10\n                Map output records=20\n                Map output bytes=180\n                Map output materialized bytes=280\n                Input split bytes=1450\n                Combine input records=0\n                Combine output records=0\n                Reduce input groups=2\n                Reduce shuffle bytes=280\n                Reduce input records=20\n                Reduce output records=0\n                Spilled Records=40\n                Shuffled Maps =10\n                Failed Shuffles=0\n                Merged Map outputs=10\n                GC time elapsed (ms)=7721\n                CPU time spent (ms)=13550\n                Physical memory (bytes) snapshot=2082910208\n                Virtual memory (bytes) snapshot=22879621120\n                Total committed heap usage (bytes)=1383833600\n        Shuffle Errors\n                BAD_ID=0\n                CONNECTION=0\n                IO_ERROR=0\n                WRONG_LENGTH=0\n                WRONG_MAP=0\n                WRONG_REDUCE=0\n        File Input Format Counters\n                Bytes Read=1180\n        File Output Format Counters\n                Bytes Written=97\nJob Finished in 62.362 seconds\nEstimated value of Pi is 3.20000000000000000000\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"624b3187c89ec800015caac5","plaintext":"一、配置网络\n虚拟机网络使用NAT模式，网络配置为静态IP，方便节点间通信\n\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n\n# 网络类型\nTYPE=Ethernet\nNAME=ens33\nUUID=89e7972a-6f3e-4981-8cde-96cd005dfc46\n# 网卡设备\nDEVICE=ens33\nONBOOT=yes\nBOOTPROTO=static\nIPADDR=192.168.133.101\nGATEWAY=192.168.133.2\nDNS1=192.168.133.2\n\n\n二、配置hostname和hosts\n> 为搭建Hadoop集群，计划准备3台虚拟机，为方便通信，使用统一的hostname命名规则，本次使用\"hadoop+IP地址末位\"的形式，hostname命名为\"hadoop101\"、\"hadoop102\"、\"hadoop103\"\n\n\n修改hostname\n\nvi /etc/sysconfig/network\n\nNETWORKING=yes\nNETWORKING_IPV6=no\nHOSTNAME=hadoop101\n\n\n修改hosts文件\n\nvi /etc/hosts\n\n192.168.133.101 hadoop101\n192.168.133.102 hadoop102\n192.168.133.103 hadoop103\n\n\n三、关闭防火墙\n查看防火墙状态\n\nfirewall-cmd --state\n\n\n停止firewall\n\nsystemctl stop firewalld.service\n\n\n禁止firewall开机启动\n\nsystemctl disable firewalld.service \n\n\n四、克隆虚拟机\n配置完成后，克隆虚拟机，修改IP\n\n五、ssh免密登录\n先从101通过ssh手动登录102、103\n\nssh root@hadoop102\nssh root@hadoop102\nssh root@hadoop102\n\n\n进入.ssh目录\n\ncd ~/.ssh\n\n\n生成公钥和私钥\n\nssh-keygen -t rsa\n\n\n把公钥复制到其它服务器上\n\nssh-copy-id hadoop102\nssh-copy-id hadoop103\n\n\n六、服务器时间设置\n设置时区为中国标准时间\n\n[root@hadoop101 ~]# timedatectl set-timezone Asia/Shanghai\n[root@hadoop101 ~]# timedatectl status\n      Local time: Mon 2022-04-04 18:21:12 CST\n  Universal time: Mon 2022-04-04 10:21:12 UTC\n        RTC time: Mon 2022-04-04 10:21:13\n       Time zone: Asia/Shanghai (CST, +0800)\n     NTP enabled: yes\nNTP synchronized: yes\n RTC in local TZ: no\n      DST active: n/a\n\n\n安装ntp，启动ntpd服务，设置ntpd自动启动\n\n> 注： 只需要在hadoop101上安装和配置ntp，指定向服务器自身进行时钟同步，其它节点通过定时任务定时从101同步时间\n\n\nyum install ntp -y\nsystemctl start ntpd\nsystemctl enable ntpd\n\n\n修改ntp配置文件 vi /etc/ntp.conf\n\n# 指定接收192.168.133.0网段的客户端的同步请求\nrestrict 192.168.133.0 mask 255.255.255.0 nomodify notrap\n\n\n# Use public servers from the pool.ntp.org project.\n# Please consider joining the pool (http://www.pool.ntp.org/join.html).\n# 注释掉，不使用ntp服务器\n#server 0.centos.pool.ntp.org iburst\n#server 1.centos.pool.ntp.org iburst\n#server 2.centos.pool.ntp.org iburst\n#server 3.centos.pool.ntp.org iburst\n\n# 指定向服务器自身进行时钟同步\nserver 127.127.1.0\nfudge 127.127.1.0 stratum 10\n\n\n七、集群同步文件\nrsync 命令可以在服务器间同步数据，例如rsync -rv /path/something root@hadoop102:/path/\n，可以将something这个目录或文件同步到hadoop102节点。\n\n编写一个集群同步文件的脚本，实现循环复制文件到所有节点服务器的相同目录。\n\n在/root目录下新建bin目录，在bin目录下新建一个xsync文件，使用chmod +x xsync为其增加执行权限；脚本使用方法：xsync 目录或文件名\n。\n\n脚本内容如下：\n\n#!/bin/bash\n\n# 循环复制文件到所有节点服务器的相同目录\n\n# 判断输入参数的个数\npcount=$#\nif((pcount==0));then\necho no args;\nexit;\nfi\n\n# 获取文件名\np1=$1\nfname=`basename $p1`\necho fname=$fname\n\n# 获取文件所在路径\npdir=`cd -P $(dirname $p1); pwd`\n\necho pdir=$pdir\n\n# 当前用户名\nuser=`whoami`\n\n# 服务器的hostname命名为hadoop101、hadoop102、hadoop103\n# 在循环中拼接hostname并使用rsync将同步文件\nfor((host=102; host<104; host++)); do\n        echo --------hadoop$host--------\n        rsync -rvl $pdir/$fname $user@hadoop$host:$pdir\ndone\n\n\n八、安装JDK和Hadoop\n在hadoop101上安装好jdk1.8和hadoop2.10.1，并在/etc/profile下配置好环境变量\n\nexport JAVA_HOME=/opt/module/jdk1.8.0_202\nexport PATH=$PATH:$JAVA_HOME/bin\n\nexport HADOOP_HOME=/opt/module/hadoop-2.10.1\nexport PATH=$PATH:$HADOOP_HOME/bin\nexport PATH=$PATH:$HADOOP_HOME/sbin\n\n\n\n然后使用xsync脚本同步到其它节点。\n\nxsync /opt/module/jdk1.8.0_202\nxsync /opt/module/hadoop-2.10.1\nxsync /etc/profile\n\n\n在各个服务器上执行source /etc/profile，使配置生效。\n\n九、Hadoop分布式集群部署\n * 集群部署规划\n\nhadoop101hadoop102hadoop103HDFSNameNode\nDataNodeDataNodeSecondaryNameNodeYARNNodeManagerResourceManager\nNodeManagerNodeManager * 配置hadoop核心配置文件vim /opt/module/hadoop-2.10.1/etc/hadoop/core-site.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n        <property>\n                <name>fs.defaultFS</name>\n                <value>hdfs://hadoop101:9000</value>\n        </property>\n\n        <property>\n                <name>hadoop.tmp.dir</name>\n                <value>/opt/module/hadoop-2.10.1/data/tmp</value>\n        </property>\n\n</configuration>\n\n\n\n * 配置HDFS vim /opt/module/hadoop-2.10.1/etc/hadoop/hdfs-site.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<!--\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License. See accompanying LICENSE file.\n-->\n\n<!-- Put site-specific property overrides in this file. -->\n\n<configuration>\n        <property>\n                <name>dfs.replication</name>\n                <value>3</value>\n        </property>\n\n        <property>\n                <name>dfs.namenode.secondary.http-address</name>\n                <value>hadoop103:50090</value>\n        </property>\n\n\n</configuration>\n\n\n\n * 配置YARNvim /opt/module/hadoop-2.10.1/etc/hadoop/yarn-site.xml\n\n<?xml version=\"1.0\"?>\n\n<configuration>\n\n<!-- Site specific YARN configuration properties -->\n        <property>\n                <name>yarn.nodemanager.aux-services</name>\n                <value>mapreduce_shuffle</value>\n        </property>\n\n        <property>\n                <name>yarn.resourcemanager.hostname</name>\n                <value>hadoop102</value>\n        </property>\n\n\n</configuration>\n\n\n\n * 配置MapReducevim /opt/module/hadoop-2.10.1/etc/hadoop/mapred-site.xml\n\n<?xml version=\"1.0\"?>\n<?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?>\n<configuration>\n        <property>\n                <name>mapreduce.framework.name</name>\n                <value>yarn</value>\n        </propterty>\n\n</configuration>\n\n\n\n * 配置JAVA_HOME，否则找不到报JAVA_HOME，在hadoop-env.sh、yarn-env.sh、mapred-env.sh这三个脚本中添加 \n   export JAVA_HOME=/opt/module/jdk1.8.0_202\n   \n   \n * 配置slaves\n   \n   vim /opt/module/hadoop-2.10.1/etc/hadoop/slaves\n   hadoop101\n   hadoop102\n   hadoop103\n   \n   \n   \n * 创建数据目录 cd /opt/module/hadoop-2.10.1/ && mkdir data && cd data && mkdir tmp\n   \n   \n * 集群分发配置文件 xsync /opt/module/hadoop-2.10.1/\n   \n   \n * 初次启动集群，需要执行hadoop namenode -format\n   \n   \n * 启动HDFS\n   \n   \n\n[root@hadoop101 hadoop-2.10.1]# sbin/start-dfs.sh\nStarting namenodes on [hadop101]\nhadop101: starting namenode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-namenode-hadoop101.out\nhadoop102: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop102.out\nhadoop103: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop103.out\nhadoop101: starting datanode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-datanode-hadoop101.out\nStarting secondary namenodes [hadop103]\nhadop103: starting secondarynamenode, logging to /opt/module/hadoop-2.10.1/logs/hadoop-root-secondarynamenode-hadoop101.out\n\n\n * 启动YARN\n   \n   去ResourceManager所在的服务器102上启动YARN\n   \n   [root@hadoop102 hadoop-2.10.1]# sbin/start-yarn.sh\n   starting yarn daemons\n   starting resourcemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-resourcemanager-hadoop102.out\n   hadoop101: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop101.out\n   hadoop103: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop103.out\n   hadoop102: starting nodemanager, logging to /opt/module/hadoop-2.10.1/logs/yarn-root-nodemanager-hadoop102.out\n   [root@hadoop102 hadoop-2.10.1]# jps\n   14448 ResourceManager\n   14592 Jps\n   14552 NodeManager\n   12956 DataNode\n   \n   \n   \n * 访问HDFS http://hadoop101:50070/dfshealth.html#tab-overview\n   \n   \n\n\n\n * 访问YARN ResourceManage http://hadoop102:8088/cluster\n\n\n\n * 运行PI实例，检查集群是否启动成功\n\n[root@hadoop101 mapreduce]# cd /opt/module/hadoop-2.10.1/share/hadoop/mapreduce\n\n[root@hadoop101 mapreduce]# ls\nhadoop-mapreduce-client-app-2.10.1.jar         hadoop-mapreduce-client-jobclient-2.10.1.jar        lib\nhadoop-mapreduce-client-common-2.10.1.jar      hadoop-mapreduce-client-jobclient-2.10.1-tests.jar  lib-examples\nhadoop-mapreduce-client-core-2.10.1.jar        hadoop-mapreduce-client-shuffle-2.10.1.jar          sources\nhadoop-mapreduce-client-hs-2.10.1.jar          hadoop-mapreduce-examples-2.10.1.jar\nhadoop-mapreduce-client-hs-plugins-2.10.1.jar  jdiff\n\n[root@hadoop101 mapreduce]# hadoop jar hadoop-mapreduce-examples-2.10.1.jar pi 10 10\nNumber of Maps  = 10\nSamples per Map = 10\nWrote input for Map #0\nWrote input for Map #1\nWrote input for Map #2\nWrote input for Map #3\nWrote input for Map #4\nWrote input for Map #5\nWrote input for Map #6\nWrote input for Map #7\nWrote input for Map #8\nWrote input for Map #9\nStarting Job\n22/04/05 01:22:27 INFO client.RMProxy: Connecting to ResourceManager at hadoop102/192.168.133.102:8032\n22/04/05 01:22:28 INFO input.FileInputFormat: Total input files to process : 10\n22/04/05 01:22:28 INFO mapreduce.JobSubmitter: number of splits:10\n22/04/05 01:22:28 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1649091969708_0002\n22/04/05 01:22:28 INFO conf.Configuration: resource-types.xml not found\n22/04/05 01:22:28 INFO resource.ResourceUtils: Unable to find 'resource-types.xml'.\n22/04/05 01:22:28 INFO resource.ResourceUtils: Adding resource type - name = memory-mb, units = Mi, type = COUNTABLE\n22/04/05 01:22:28 INFO resource.ResourceUtils: Adding resource type - name = vcores, units = , type = COUNTABLE\n22/04/05 01:22:29 INFO impl.YarnClientImpl: Submitted application application_1649091969708_0002\n22/04/05 01:22:29 INFO mapreduce.Job: The url to track the job: http://hadoop102:8088/proxy/application_1649091969708_0002/\n22/04/05 01:22:29 INFO mapreduce.Job: Running job: job_1649091969708_0002\n22/04/05 01:22:38 INFO mapreduce.Job: Job job_1649091969708_0002 running in uber mode : false\n22/04/05 01:22:38 INFO mapreduce.Job:  map 0% reduce 0%\n22/04/05 01:22:51 INFO mapreduce.Job:  map 20% reduce 0%\n22/04/05 01:23:10 INFO mapreduce.Job:  map 20% reduce 7%\n22/04/05 01:23:21 INFO mapreduce.Job:  map 50% reduce 7%\n22/04/05 01:23:26 INFO mapreduce.Job:  map 70% reduce 7%\n22/04/05 01:23:27 INFO mapreduce.Job:  map 100% reduce 7%\n22/04/05 01:23:28 INFO mapreduce.Job:  map 100% reduce 100%\n22/04/05 01:23:29 INFO mapreduce.Job: Job job_1649091969708_0002 completed successfully\n22/04/05 01:23:29 INFO mapreduce.Job: Counters: 49\n        File System Counters\n                FILE: Number of bytes read=226\n                FILE: Number of bytes written=2298230\n                FILE: Number of read operations=0\n                FILE: Number of large read operations=0\n                FILE: Number of write operations=0\n                HDFS: Number of bytes read=2630\n                HDFS: Number of bytes written=215\n                HDFS: Number of read operations=43\n                HDFS: Number of large read operations=0\n                HDFS: Number of write operations=3\n        Job Counters\n                Launched map tasks=10\n                Launched reduce tasks=1\n                Data-local map tasks=10\n                Total time spent by all maps in occupied slots (ms)=373219\n                Total time spent by all reduces in occupied slots (ms)=34501\n                Total time spent by all map tasks (ms)=373219\n                Total time spent by all reduce tasks (ms)=34501\n                Total vcore-milliseconds taken by all map tasks=373219\n                Total vcore-milliseconds taken by all reduce tasks=34501\n                Total megabyte-milliseconds taken by all map tasks=382176256\n                Total megabyte-milliseconds taken by all reduce tasks=35329024\n        Map-Reduce Framework\n                Map input records=10\n                Map output records=20\n                Map output bytes=180\n                Map output materialized bytes=280\n                Input split bytes=1450\n                Combine input records=0\n                Combine output records=0\n                Reduce input groups=2\n                Reduce shuffle bytes=280\n                Reduce input records=20\n                Reduce output records=0\n                Spilled Records=40\n                Shuffled Maps =10\n                Failed Shuffles=0\n                Merged Map outputs=10\n                GC time elapsed (ms)=7721\n                CPU time spent (ms)=13550\n                Physical memory (bytes) snapshot=2082910208\n                Virtual memory (bytes) snapshot=22879621120\n                Total committed heap usage (bytes)=1383833600\n        Shuffle Errors\n                BAD_ID=0\n                CONNECTION=0\n                IO_ERROR=0\n                WRONG_LENGTH=0\n                WRONG_MAP=0\n                WRONG_REDUCE=0\n        File Input Format Counters\n                Bytes Read=1180\n        File Output Format Counters\n                Bytes Written=97\nJob Finished in 62.362 seconds\nEstimated value of Pi is 3.20000000000000000000","feature_image":"__GHOST_URL__/content/images/2022/04/Snipaste_2022-04-05_02-07-24.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2022-04-04 17:57:27","created_by":"1","updated_at":"2022-04-04 18:07:59","updated_by":"1","published_at":"2022-04-04 18:02:18","published_by":"1","custom_excerpt":"VMware CentOS Hadoop环境准备","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"629262fd8b6a1d0001b86ca8","uuid":"844c2a43-6e27-49d3-9b36-af79dc3e1dc5","title":"Java 监控工具","slug":"java-jian-kong-gong-ju","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"- `jcmd`  打印Java进程所涉及的基本类，线程和vm信息。\\n    - 查看jvm运行的时长\\n```shell\\njcmd process_id VM.uptime\\njcmd 42392 VM.uptime\\n42392:\\n150.868 s\\n```\\n- 显示system.getproperties()条目\\n`jcmd processid VM.system_properties` 或者 `jinfo -sysprops process_id`\\n- 获取Jvm版本\\n```shell\\njcmd process_id VM.version\\njcmd 42392 VM.version\\n42392:\\nJava HotSpot(TM) 64-Bit Server VM version 25.201-b09\\nJDK 8.0_201\\n```\\n- jvm 命令行\\n\\n`jcmd process_id VM_command_line`\\n\\n- jvm调优标志\\n\\n`jcmd process_id VM.flags`\\n\\n- jconsole\\n    - 提供jvm活动的图形化视图。包括线程的使用，类的使用和gc活动\\n- jhat\\n    - 读取内存堆转储\\n    - 事后使用的工具\\n- jmap\\n    - 提供堆转储和其它jvm内存使用的信息\\n    - 堆转储必须在事后分析工具中使用\\n- jinfo\\n    - 查看jvm的系统属性，可以动态设置一些系统属性。\\n    - jinfo的好处在于，允许程序在执行时更改某个标志的值\\n    - 获取进程中所有标志的值`jinfo -flags process_id`\\n    - 检查单个标志的值`jinfo -flag PrintGCDetails process_id - XX:+PrintGCDetails`\\n- jstack\\n    - 转储Java进程的栈信息\\n- jstate\\n    - 提供gc和类装载活动的信息\\n- jvisualvm\\n    - 监控jvm的gui工具，可以剖析运行的应用，分析jvm堆转储\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><ul>\n<li><code>jcmd</code>  打印Java进程所涉及的基本类，线程和vm信息。\n<ul>\n<li>查看jvm运行的时长</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-shell\">jcmd process_id VM.uptime\njcmd 42392 VM.uptime\n42392:\n150.868 s\n</code></pre>\n<ul>\n<li>显示system.getproperties()条目<br>\n<code>jcmd processid VM.system_properties</code> 或者 <code>jinfo -sysprops process_id</code></li>\n<li>获取Jvm版本</li>\n</ul>\n<pre><code class=\"language-shell\">jcmd process_id VM.version\njcmd 42392 VM.version\n42392:\nJava HotSpot(TM) 64-Bit Server VM version 25.201-b09\nJDK 8.0_201\n</code></pre>\n<ul>\n<li>jvm 命令行</li>\n</ul>\n<p><code>jcmd process_id VM_command_line</code></p>\n<ul>\n<li>jvm调优标志</li>\n</ul>\n<p><code>jcmd process_id VM.flags</code></p>\n<ul>\n<li>jconsole\n<ul>\n<li>提供jvm活动的图形化视图。包括线程的使用，类的使用和gc活动</li>\n</ul>\n</li>\n<li>jhat\n<ul>\n<li>读取内存堆转储</li>\n<li>事后使用的工具</li>\n</ul>\n</li>\n<li>jmap\n<ul>\n<li>提供堆转储和其它jvm内存使用的信息</li>\n<li>堆转储必须在事后分析工具中使用</li>\n</ul>\n</li>\n<li>jinfo\n<ul>\n<li>查看jvm的系统属性，可以动态设置一些系统属性。</li>\n<li>jinfo的好处在于，允许程序在执行时更改某个标志的值</li>\n<li>获取进程中所有标志的值<code>jinfo -flags process_id</code></li>\n<li>检查单个标志的值<code>jinfo -flag PrintGCDetails process_id - XX:+PrintGCDetails</code></li>\n</ul>\n</li>\n<li>jstack\n<ul>\n<li>转储Java进程的栈信息</li>\n</ul>\n</li>\n<li>jstate\n<ul>\n<li>提供gc和类装载活动的信息</li>\n</ul>\n</li>\n<li>jvisualvm\n<ul>\n<li>监控jvm的gui工具，可以剖析运行的应用，分析jvm堆转储</li>\n</ul>\n</li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"629262fd8b6a1d0001b86ca8","plaintext":" * jcmd 打印Java进程所涉及的基本类，线程和vm信息。 * 查看jvm运行的时长\n   \n   \n\njcmd process_id VM.uptime\njcmd 42392 VM.uptime\n42392:\n150.868 s\n\n\n * 显示system.getproperties()条目\n   jcmd processid VM.system_properties 或者 jinfo -sysprops process_id\n * 获取Jvm版本\n\njcmd process_id VM.version\njcmd 42392 VM.version\n42392:\nJava HotSpot(TM) 64-Bit Server VM version 25.201-b09\nJDK 8.0_201\n\n\n * jvm 命令行\n\njcmd process_id VM_command_line\n\n * jvm调优标志\n\njcmd process_id VM.flags\n\n * jconsole * 提供jvm活动的图形化视图。包括线程的使用，类的使用和gc活动\n   \n   \n * jhat * 读取内存堆转储\n    * 事后使用的工具\n   \n   \n * jmap * 提供堆转储和其它jvm内存使用的信息\n    * 堆转储必须在事后分析工具中使用\n   \n   \n * jinfo * 查看jvm的系统属性，可以动态设置一些系统属性。\n    * jinfo的好处在于，允许程序在执行时更改某个标志的值\n    * 获取进程中所有标志的值jinfo -flags process_id\n    * 检查单个标志的值jinfo -flag PrintGCDetails process_id - XX:+PrintGCDetails\n   \n   \n * jstack * 转储Java进程的栈信息\n   \n   \n * jstate * 提供gc和类装载活动的信息\n   \n   \n * jvisualvm * 监控jvm的gui工具，可以剖析运行的应用，分析jvm堆转储","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2022-05-28 17:59:25","created_by":"1","updated_at":"2022-05-28 18:04:58","updated_by":"1","published_at":"2022-05-28 18:04:58","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null}],"posts_meta":[],"users":[{"id":"1","name":"Jason Yang","slug":"jason","password":"$2a$10$Tpx1vvOP/.0fyUBpoV20pOIZfhwMLoDHCStstGvIfWMyDH0UAl8M6","email":"yangjinlong86@126.com","profile_image":"__GHOST_URL__/content/images/2021/10/----_20211009112710.jpg","cover_image":null,"bio":null,"website":"http://nocoder.org","location":null,"facebook":null,"twitter":"@yangjinlong86","accessibility":"{\"nightShift\":true,\"launchComplete\":true,\"whatsNew\":{\"lastSeenDate\":\"2021-12-13T19:57:59.000+00:00\"},\"navigation\":{\"expanded\":{\"posts\":true}}}","status":"active","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"tour":null,"last_seen":"2022-05-30 01:24:07","created_at":"2021-10-08 16:37:13","created_by":"1","updated_at":"2022-05-30 01:24:07","updated_by":"1"}],"posts_authors":[{"id":"6160769067f6c50001275528","post_id":"6160769067f6c50001275527","author_id":"1","sort_order":0},{"id":"61607b040af28a00012bf0df","post_id":"61607b040af28a00012bf0de","author_id":"1","sort_order":0},{"id":"61607f310af28a00012bf106","post_id":"61607f310af28a00012bf105","author_id":"1","sort_order":0},{"id":"6164fc580af28a00012bf12c","post_id":"6164fc580af28a00012bf12b","author_id":"1","sort_order":0},{"id":"616562600af28a00012bf138","post_id":"616562600af28a00012bf137","author_id":"1","sort_order":0},{"id":"616564710af28a00012bf14b","post_id":"616564710af28a00012bf14a","author_id":"1","sort_order":0},{"id":"6165652f0af28a00012bf158","post_id":"6165652f0af28a00012bf157","author_id":"1","sort_order":0},{"id":"616566140af28a00012bf165","post_id":"616566140af28a00012bf164","author_id":"1","sort_order":0},{"id":"6165670a0af28a00012bf172","post_id":"6165670a0af28a00012bf171","author_id":"1","sort_order":0},{"id":"618eba1d0af28a00012bf1bc","post_id":"618eba1c0af28a00012bf1bb","author_id":"1","sort_order":0},{"id":"6196fc3a0af28a00012bf1fd","post_id":"6196fc3a0af28a00012bf1fc","author_id":"1","sort_order":0},{"id":"6196ffd50af28a00012bf216","post_id":"6196ffd50af28a00012bf215","author_id":"1","sort_order":0},{"id":"619700590af28a00012bf223","post_id":"619700590af28a00012bf222","author_id":"1","sort_order":0},{"id":"619a6a1ceff3f40001c5e930","post_id":"619a6a1ceff3f40001c5e92f","author_id":"1","sort_order":0},{"id":"619a6ad5eff3f40001c5e946","post_id":"619a6ad5eff3f40001c5e945","author_id":"1","sort_order":0},{"id":"619b491feff3f40001c5e962","post_id":"619b491feff3f40001c5e961","author_id":"1","sort_order":0},{"id":"61a7a09d5f5de50001a50788","post_id":"61a7a09c5f5de50001a50787","author_id":"1","sort_order":0},{"id":"61aceebe1fb64e0001fdd027","post_id":"61aceebe1fb64e0001fdd026","author_id":"1","sort_order":0},{"id":"61b8b017eb664800012e4fcc","post_id":"61b8b017eb664800012e4fcb","author_id":"1","sort_order":0},{"id":"61b8b44feb664800012e5008","post_id":"61b8b44feb664800012e5007","author_id":"1","sort_order":0},{"id":"61b8b4ddeb664800012e501a","post_id":"61b8b4ddeb664800012e5019","author_id":"1","sort_order":0},{"id":"61b8b55ceb664800012e5029","post_id":"61b8b55ceb664800012e5028","author_id":"1","sort_order":0},{"id":"61b8b5a6eb664800012e5037","post_id":"61b8b5a6eb664800012e5036","author_id":"1","sort_order":0},{"id":"61b8b5feeb664800012e5041","post_id":"61b8b5feeb664800012e5040","author_id":"1","sort_order":0},{"id":"61b8b64aeb664800012e504d","post_id":"61b8b64aeb664800012e504c","author_id":"1","sort_order":0},{"id":"61b8b6b0eb664800012e505a","post_id":"61b8b6b0eb664800012e5059","author_id":"1","sort_order":0},{"id":"61b8b6fceb664800012e5068","post_id":"61b8b6fceb664800012e5067","author_id":"1","sort_order":0},{"id":"61b8b75beb664800012e5074","post_id":"61b8b75beb664800012e5073","author_id":"1","sort_order":0},{"id":"61b8b859eb664800012e5081","post_id":"61b8b859eb664800012e5080","author_id":"1","sort_order":0},{"id":"61d1c564ce958b0001b30bbf","post_id":"61d1c563ce958b0001b30bbe","author_id":"1","sort_order":0},{"id":"62372731ce958b0001b30cac","post_id":"62372731ce958b0001b30cab","author_id":"1","sort_order":0},{"id":"62372c67ce958b0001b30ced","post_id":"62372c67ce958b0001b30cec","author_id":"1","sort_order":0},{"id":"62487ed9c89ec800015caa42","post_id":"62487ed9c89ec800015caa41","author_id":"1","sort_order":0},{"id":"624b3187c89ec800015caac6","post_id":"624b3187c89ec800015caac5","author_id":"1","sort_order":0},{"id":"629262fe8b6a1d0001b86ca9","post_id":"629262fd8b6a1d0001b86ca8","author_id":"1","sort_order":0}],"roles":[{"id":"616073b867f6c50001275352","name":"Administrator","description":"Administrators","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275353","name":"Editor","description":"Editors","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275354","name":"Author","description":"Authors","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275355","name":"Contributor","description":"Contributors","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275356","name":"Owner","description":"Blog Owner","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275357","name":"Admin Integration","description":"External Apps","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275358","name":"DB Backup Integration","description":"Internal DB Backup Client","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275359","name":"Scheduler Integration","description":"Internal Scheduler Client","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"}],"roles_users":[{"id":"616073bc67f6c500012754c8","role_id":"616073b867f6c50001275356","user_id":"1"}],"settings":[{"id":"616073bd67f6c500012754c9","group":"core","key":"db_hash","value":"decdf869-cfc3-4b51-8669-4e68d62417a6","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073bd67f6c500012754ca","group":"core","key":"routes_hash","value":"3d180d52c663d173a6be791ef411ed01","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:22","updated_by":"1"},{"id":"616073bd67f6c500012754cb","group":"core","key":"next_update_check","value":"1653960246","type":"number","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2022-05-30 01:24:05","updated_by":"1"},{"id":"616073bd67f6c500012754cc","group":"core","key":"notifications","value":"[{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"340634d0-cbd4-11ec-9a95-53e6cc43071a\",\"createdAtVersion\":\"4.41.3\",\"custom\":false,\"createdAt\":\"2022-05-04T17:01:20.000Z\",\"type\":\"info\",\"top\":false,\"message\":\"Ghost <a href=\\\"https://github.com/TryGhost/Ghost/releases\\\">4.47.0</a> has been released, <a href=\\\"https://ghost.org/update/?v=4.41.3\\\">click here</a> to upgrade.\",\"seen\":false,\"addedAt\":\"2022-05-07T18:06:46.509Z\"},{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"130f7c24-113a-4768-a698-12a8b3422e81\",\"createdAtVersion\":\"4.41.3\",\"custom\":true,\"createdAt\":\"2022-05-26T17:12:51.000Z\",\"type\":\"info\",\"top\":true,\"message\":\"<strong>Ghost 5.0 is now available</strong> - You are using an old version of Ghost, which means you don't have access to the latest features. <a href=\\\"https://ghost.org/changelog/5/\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">Read more!</a>\",\"seen\":false,\"addedAt\":\"2022-05-28T17:59:03.152Z\"}]","type":"array","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2022-05-28 17:59:03","updated_by":"1"},{"id":"616073bd67f6c500012754cd","group":"core","key":"session_secret","value":"f5e741290cf5a5f285cfb7032ea99040083c8edaa03ad77114dcffe1bbf939bf","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073bd67f6c500012754ce","group":"core","key":"theme_session_secret","value":"a2283caa624546e5996fb4730b3d20231a43317861e47980ba4a8e14594abdbe","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754cf","group":"core","key":"ghost_public_key","value":"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAKIyVOwnRy/UC6Xoqsgw5nIIsOFfjMyYmRyrEO3GpbVHnThagSA+xjVqqsmJaq0p\n2NDoGTnyRX56vvYcL7tzIWzRFgXrkOIsBwOy5RONHoFDLSpuz53VASV7vp003uKsSy2VJhXj\nQY/2UfazuTPEI2w65PItPhhoFGW7ei6XgB7nAgMBAAE=\n-----END RSA PUBLIC KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d0","group":"core","key":"ghost_private_key","value":"-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCiMlTsJ0cv1Aul6KrIMOZyCLDhX4zMmJkcqxDtxqW1R504WoEgPsY1aqrJ\niWqtKdjQ6Bk58kV+er72HC+7cyFs0RYF65DiLAcDsuUTjR6BQy0qbs+d1QEle76dNN7irEst\nlSYV40GP9lH2s7kzxCNsOuTyLT4YaBRlu3oul4Ae5wIDAQABAoGATtUhu2nXyqJISwoLv6Ms\nzi31MoULXQGqIWnvn3HWZoZ5HsO2UOLR2XKPscatZ56YN+knIafkKPYlzF6kwHnTu1TX4eSk\nsZGjjaLw+JnQhPsuOvK6r2hiwDYLHafpDeiuE8fL3N28pRFSpzH/c8D8AgbZeI7lRu8uYDrM\nShCa/5kCQQDqdn8IaIgLnrOJtmom6BYKa1WLvXwWmf6XyedNg+mAW3rxR+U3DCt1iCCvgLO1\nOt/wPGtAX5P633wAcPeV1N4dAkEAsRh15q5dsTtWGJ8PzKRjv/HJb0kvAQ1FLunjIqNUx1Bv\nPEhu0T8iiUsxsDrNAAzPfU2P2fGO4QIXnrnNnHex0wJARKveOx06s4SQ+0XFQ434XqbfUGV4\nQbpq2hRVvdtj+adRk/fFx+C1nd/4Cs88U1liG5/mnd0gn3rze8GaknTddQJBAK8ww3GwjH8H\nc+Rndfm7pfH7/olYnGct+YKvXUKm0PdbWq8H+JiHHGM1P7JWePXTtm7+i4/OpslwiG084Won\n/oECQCYnPpKRdyBtL3Dd1AgUf2wgKYSkvu/CeYjqHIBX2/cnyBvwPa1l8tnC5e0B0BukVwj5\nRnOzyAEvfQvgF/TI2LY=\n-----END RSA PRIVATE KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d1","group":"core","key":"members_public_key","value":"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAJL8tw0Uv7XFLq8s+vr6l1bXCLlzuu0zI5zSxd4REhdbwpFb2hX+7KdXsXsUJce4\nlgVMBilwKQRPXR9ldN+jM8WAinpSkMWaJJ/T+TD1LANFoVbpQvFws+Ep/iubuN/w9oQ6FBb0\napUwIce4QCs3ZnjHmCEIYd+fH2hW3tUlYq5xAgMBAAE=\n-----END RSA PUBLIC KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d2","group":"core","key":"members_private_key","value":"-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCS/LcNFL+1xS6vLPr6+pdW1wi5c7rtMyOc0sXeERIXW8KRW9oV/uynV7F7\nFCXHuJYFTAYpcCkET10fZXTfozPFgIp6UpDFmiSf0/kw9SwDRaFW6ULxcLPhKf4rm7jf8PaE\nOhQW9GqVMCHHuEArN2Z4x5ghCGHfnx9oVt7VJWKucQIDAQABAoGATyGCIqay9taq5V/f1lIm\nO3gUmFJ3pc9MMtc98ulZxf1+Z+b9J65QFV8ei1YzaKw1B7D/+DsLuehIB+kE3IjuC2riZyV2\nfNrs7BFJlVYRWFP5lXZ4JOGVbw3rlrjxt5u9VW/fvI1O1t+C+g/Rqa7qcHU4U5+12IOGiGUZ\nKrNLUIkCQQDD6bMKowMiXw+QZ2fWRSA1wf8+B7BWBgZW9r9KaL+VJX8I09bPV/zwh4XzusGD\nYKJcLsuy3FhXNCaUUPPi2QiXAkEAwBGQEKvJkXzs7w5gzIsZEJWKUGugWJzQQAG+kNeAZpPJ\nf0k+pH1EvvGBCF13SCvc1hD+q5Rbk4+Dymh/1wGaNwJBAK0mJSlnfWOpZJYZ7joACkG43Z+z\nJ/Q/iubdWZ+oCHsHEsl4gMfsWg8zl/4btuAoThbu/PVtrV4VJ2u6SHLboq0CQEvoZQSBsDck\npUtRZmZQbwaD41cnQgbjatZxGgyKbv+bVt5MZ0qBC6NfNPzGW7cVRsD/lHbhOlQWOyLKrAOg\naX8CQEtGLdXkf30PY/SspMBuMu4oos9x5MJ0x4I6x6Nj2eiRLk8gBv0Lkk731sx4lHI3MHLx\npC/8oK8uqvFh2o5djes=\n-----END RSA PRIVATE KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d3","group":"core","key":"members_email_auth_secret","value":"4db94a26d45df2ab838e3b3d30e44bc75028f741ba295845fd5df49893e0f78838aeb31ca6ba42950dff89314c8b760868a216bf202b310b5d3a3c668944da1f","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d6","group":"site","key":"title","value":"Nocoder.org","type":"string","flags":"PUBLIC","created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-12-01 17:20:35","updated_by":"1"},{"id":"616073be67f6c500012754d7","group":"site","key":"description","value":"Standing on the shoulders of giants","type":"string","flags":"PUBLIC","created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-12 19:23:31","updated_by":"1"},{"id":"616073be67f6c500012754d8","group":"site","key":"logo","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d9","group":"site","key":"cover_image","value":"__GHOST_URL__/content/images/2021/10/binlog-1.jpg","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-09 01:18:23","updated_by":"1"},{"id":"616073be67f6c500012754da","group":"site","key":"icon","value":"__GHOST_URL__/content/images/2021/10/20-terminal-1.png","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-09 01:18:23","updated_by":"1"},{"id":"616073be67f6c500012754db","group":"site","key":"accent_color","value":"#4292ea","type":"string","flags":"PUBLIC","created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-09 01:18:23","updated_by":"1"},{"id":"616073be67f6c500012754dc","group":"site","key":"lang","value":"cn","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-19 16:19:32","updated_by":"1"},{"id":"616073be67f6c500012754dd","group":"site","key":"timezone","value":"Asia/Hong_Kong","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:52:26","updated_by":"1"},{"id":"616073be67f6c500012754de","group":"site","key":"codeinjection_head","value":"<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai-sublime.min.css\"/>","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-12-05 15:51:39","updated_by":"1"},{"id":"616073be67f6c500012754df","group":"site","key":"codeinjection_foot","value":"<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js\"></script>\n\n<script>hljs.initHighlightingOnLoad();</script>\n\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2022-05-30 01:32:10","updated_by":"1"},{"id":"616073be67f6c500012754e0","group":"site","key":"facebook","value":"profile.php?id=100023141842030","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-12 19:22:47","updated_by":"1"},{"id":"616073be67f6c500012754e1","group":"site","key":"twitter","value":"@yangjinlong86","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-12 19:22:47","updated_by":"1"},{"id":"616073be67f6c500012754e2","group":"site","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"http://nocoder.org\"},{\"label\":\"About\",\"url\":\"/about/\"},{\"label\":\"Github\",\"url\":\"https://github.com/nocdr/\"}]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2022-04-05 04:43:19","updated_by":"1"},{"id":"616073be67f6c500012754e3","group":"site","key":"secondary_navigation","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-19 16:21:05","updated_by":"1"},{"id":"616073be67f6c500012754e4","group":"site","key":"meta_title","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e5","group":"site","key":"meta_description","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e6","group":"site","key":"og_image","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e7","group":"site","key":"og_title","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e8","group":"site","key":"og_description","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e9","group":"site","key":"twitter_image","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ea","group":"site","key":"twitter_title","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754eb","group":"site","key":"twitter_description","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ec","group":"theme","key":"active_theme","value":"ruby-nocoder","type":"string","flags":"RO","created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2022-04-02 17:44:26","updated_by":"1"},{"id":"616073be67f6c500012754ed","group":"private","key":"is_private","value":"false","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ee","group":"private","key":"password","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ef","group":"private","key":"public_hash","value":"b6353c851c0e2e42064f98d9d09e5f","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f0","group":"members","key":"default_content_visibility","value":"public","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f1","group":"members","key":"members_signup_access","value":"none","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-09 01:20:22","updated_by":"1"},{"id":"616073be67f6c500012754f2","group":"members","key":"members_from_address","value":"noreply","type":"string","flags":"RO","created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f3","group":"members","key":"members_support_address","value":"noreply","type":"string","flags":"PUBLIC,RO","created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f4","group":"members","key":"members_reply_address","value":"newsletter","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f5","group":"members","key":"members_free_signup_redirect","value":"/","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f6","group":"members","key":"members_paid_signup_redirect","value":"/","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f7","group":"members","key":"stripe_product_name","value":"Ghost Subscription","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754fa","group":"members","key":"stripe_plans","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754fd","group":"members","key":"stripe_connect_livemode","value":null,"type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754fe","group":"members","key":"stripe_connect_display_name","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275500","group":"members","key":"members_free_price_name","value":"Free","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275501","group":"members","key":"members_free_price_description","value":"Free preview","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275502","group":"members","key":"members_monthly_price_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275503","group":"members","key":"members_yearly_price_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275504","group":"portal","key":"portal_name","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275505","group":"portal","key":"portal_button","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275506","group":"portal","key":"portal_plans","value":"[\"free\"]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275507","group":"portal","key":"portal_products","value":"[\"616073b867f6c50001275350\"]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2022-04-05 07:31:05","updated_by":"1"},{"id":"616073be67f6c50001275508","group":"portal","key":"portal_button_style","value":"icon-and-text","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275509","group":"portal","key":"portal_button_icon","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550a","group":"portal","key":"portal_button_signup_text","value":"Subscribe","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550b","group":"email","key":"mailgun_domain","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550c","group":"email","key":"mailgun_api_key","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550d","group":"email","key":"mailgun_base_url","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550e","group":"email","key":"email_track_opens","value":"false","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-21 17:33:13","updated_by":"1"},{"id":"616073be67f6c50001275510","group":"amp","key":"amp","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275511","group":"amp","key":"amp_gtag_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275512","group":"firstpromoter","key":"firstpromoter","value":"false","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275513","group":"firstpromoter","key":"firstpromoter_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275514","group":"labs","key":"labs","value":"{}","type":"object","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275515","group":"slack","key":"slack_url","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2022-05-30 01:32:10","updated_by":"1"},{"id":"616073be67f6c50001275516","group":"slack","key":"slack_username","value":"Ghost","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2022-05-30 01:32:10","updated_by":"1"},{"id":"616073be67f6c50001275517","group":"unsplash","key":"unsplash","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275518","group":"views","key":"shared_views","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275519","group":"newsletter","key":"newsletter_show_badge","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551a","group":"newsletter","key":"newsletter_header_image","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551b","group":"newsletter","key":"newsletter_show_header_icon","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551c","group":"newsletter","key":"newsletter_show_header_title","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551d","group":"newsletter","key":"newsletter_title_alignment","value":"center","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551e","group":"newsletter","key":"newsletter_title_font_category","value":"sans_serif","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551f","group":"newsletter","key":"newsletter_show_feature_image","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275520","group":"newsletter","key":"newsletter_body_font_category","value":"sans_serif","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275521","group":"newsletter","key":"newsletter_footer_content","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275522","group":"oauth","key":"oauth_client_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275523","group":"oauth","key":"oauth_client_secret","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275524","group":"editor","key":"editor_default_email_recipients","value":"visibility","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275525","group":"editor","key":"editor_default_email_recipients_filter","value":"all","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"6197067beff3f40001c5e8db","group":"editor","key":"editor_is_launch_complete","value":"true","type":"boolean","flags":null,"created_at":"2021-11-19 02:05:47","created_by":"1","updated_at":"2021-11-19 02:05:47","updated_by":"1"},{"id":"624bf0398b6a1d0001b86c9c","group":"members","key":"default_content_visibility_tiers","value":"[]","type":"array","flags":null,"created_at":"2022-04-05 07:31:05","created_by":"1","updated_at":"2022-04-05 07:31:05","updated_by":"1"}],"tags":[{"id":"616073b867f6c50001275351","name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"617c03e30af28a00012bf19b","name":"ARTS","slug":"arts","description":null,"feature_image":"__GHOST_URL__/content/images/2021/10/unnamed-1.png","parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":"#99bfdb","created_at":"2021-10-29 14:23:31","created_by":"1","updated_at":"2021-10-29 14:35:07","updated_by":"1"},{"id":"617c06ed0af28a00012bf1aa","name":"Spring","slug":"spring","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-29 14:36:29","created_by":"1","updated_at":"2021-10-29 14:36:29","updated_by":"1"},{"id":"617c07160af28a00012bf1ae","name":"Java","slug":"java","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-29 14:37:10","created_by":"1","updated_at":"2021-10-29 14:37:10","updated_by":"1"},{"id":"617c075a0af28a00012bf1b4","name":"Algorithm","slug":"algorithm","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-29 14:38:18","created_by":"1","updated_at":"2021-11-19 16:07:00","updated_by":"1"},{"id":"6196fd5f0af28a00012bf20d","name":"Architecture","slug":"architecture","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":"#8ebeec","created_at":"2021-11-19 01:26:55","created_by":"1","updated_at":"2021-11-19 16:06:09","updated_by":"1"},{"id":"6197001e0af28a00012bf21e","name":"Python","slug":"python","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 01:38:38","created_by":"1","updated_at":"2021-11-19 01:38:38","updated_by":"1"},{"id":"61970b74eff3f40001c5e8f5","name":"ReactJS","slug":"reactjs","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 02:27:00","created_by":"1","updated_at":"2021-11-19 02:27:00","updated_by":"1"},{"id":"61970b74eff3f40001c5e8f6","name":"SpringBoot","slug":"springboot","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 02:27:00","created_by":"1","updated_at":"2021-11-19 02:27:00","updated_by":"1"},{"id":"6197ca78eff3f40001c5e911","name":"Management","slug":"management","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 16:02:00","created_by":"1","updated_at":"2021-11-19 16:02:00","updated_by":"1"},{"id":"6197cb33eff3f40001c5e917","name":"Design Pattern","slug":"design-pattern","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 16:05:07","created_by":"1","updated_at":"2021-11-19 16:05:07","updated_by":"1"},{"id":"6197cc38eff3f40001c5e923","name":"Log","slug":"log","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 16:09:28","created_by":"1","updated_at":"2021-11-19 16:09:28","updated_by":"1"},{"id":"61b8b2dceb664800012e5003","name":"Nginx","slug":"nginx","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-12-14 15:06:04","created_by":"1","updated_at":"2021-12-14 15:06:04","updated_by":"1"},{"id":"61b8b505eb664800012e5022","name":"Database","slug":"database","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-12-14 15:15:17","created_by":"1","updated_at":"2021-12-14 15:15:17","updated_by":"1"},{"id":"61d1cdfdce958b0001b30c77","name":"Linux","slug":"linux","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2022-01-02 16:08:29","created_by":"1","updated_at":"2022-01-02 16:08:29","updated_by":"1"}],"posts_tags":[{"id":"617c06ed0af28a00012bf1ab","post_id":"616564710af28a00012bf14a","tag_id":"617c06ed0af28a00012bf1aa","sort_order":0},{"id":"617c07290af28a00012bf1b0","post_id":"61607f310af28a00012bf105","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"617c073c0af28a00012bf1b2","post_id":"616564710af28a00012bf14a","tag_id":"617c07160af28a00012bf1ae","sort_order":1},{"id":"617c075a0af28a00012bf1b5","post_id":"61607b040af28a00012bf0de","tag_id":"617c075a0af28a00012bf1b4","sort_order":0},{"id":"6196fd5f0af28a00012bf20e","post_id":"6196fc3a0af28a00012bf1fc","tag_id":"6196fd5f0af28a00012bf20d","sort_order":0},{"id":"6197001e0af28a00012bf21f","post_id":"6196ffd50af28a00012bf215","tag_id":"6197001e0af28a00012bf21e","sort_order":0},{"id":"619700bb0af28a00012bf234","post_id":"619700590af28a00012bf222","tag_id":"6197001e0af28a00012bf21e","sort_order":0},{"id":"61970b74eff3f40001c5e8f7","post_id":"618eba1c0af28a00012bf1bb","tag_id":"61970b74eff3f40001c5e8f5","sort_order":0},{"id":"61970b74eff3f40001c5e8f9","post_id":"618eba1c0af28a00012bf1bb","tag_id":"61970b74eff3f40001c5e8f6","sort_order":1},{"id":"6197ca78eff3f40001c5e912","post_id":"616562600af28a00012bf137","tag_id":"6197ca78eff3f40001c5e911","sort_order":0},{"id":"6197cae3eff3f40001c5e915","post_id":"6165670a0af28a00012bf171","tag_id":"6197ca78eff3f40001c5e911","sort_order":0},{"id":"6197cb33eff3f40001c5e918","post_id":"6164fc580af28a00012bf12b","tag_id":"6197cb33eff3f40001c5e917","sort_order":0},{"id":"6197cbe7eff3f40001c5e920","post_id":"61607f310af28a00012bf105","tag_id":"617c06ed0af28a00012bf1aa","sort_order":1},{"id":"6197cbe7eff3f40001c5e921","post_id":"61607f310af28a00012bf105","tag_id":"6197cb33eff3f40001c5e917","sort_order":2},{"id":"6197cc38eff3f40001c5e924","post_id":"6160769067f6c50001275527","tag_id":"6197cc38eff3f40001c5e923","sort_order":0},{"id":"6197cc50eff3f40001c5e927","post_id":"6165652f0af28a00012bf157","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"6197cd5aeff3f40001c5e929","post_id":"616566140af28a00012bf164","tag_id":"617c075a0af28a00012bf1b4","sort_order":0},{"id":"619a6aa0eff3f40001c5e940","post_id":"619a6a1ceff3f40001c5e92f","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"619a6aa0eff3f40001c5e941","post_id":"619a6a1ceff3f40001c5e92f","tag_id":"617c06ed0af28a00012bf1aa","sort_order":1},{"id":"619a6c28eff3f40001c5e94e","post_id":"619a6ad5eff3f40001c5e945","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"619b4996eff3f40001c5e973","post_id":"619b491feff3f40001c5e961","tag_id":"61970b74eff3f40001c5e8f6","sort_order":0},{"id":"61a7ab195f5de50001a507ba","post_id":"61a7a09c5f5de50001a50787","tag_id":"61970b74eff3f40001c5e8f6","sort_order":0},{"id":"61b8b2dceb664800012e5004","post_id":"61b8b017eb664800012e4fcb","tag_id":"61b8b2dceb664800012e5003","sort_order":0},{"id":"61b8b498eb664800012e5013","post_id":"61b8b44feb664800012e5007","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"61b8b505eb664800012e5023","post_id":"61b8b4ddeb664800012e5019","tag_id":"61b8b505eb664800012e5022","sort_order":0},{"id":"61b8b670eb664800012e5057","post_id":"61b8b64aeb664800012e504c","tag_id":"6197cb33eff3f40001c5e917","sort_order":0},{"id":"61b8b780eb664800012e507e","post_id":"61b8b75beb664800012e5073","tag_id":"61b8b2dceb664800012e5003","sort_order":0},{"id":"61b8b9feeb664800012e508c","post_id":"61b8b859eb664800012e5080","tag_id":"61b8b505eb664800012e5022","sort_order":0},{"id":"61d1cdfdce958b0001b30c78","post_id":"61d1c563ce958b0001b30bbe","tag_id":"61d1cdfdce958b0001b30c77","sort_order":0},{"id":"6248848fc89ec800015caab5","post_id":"62487ed9c89ec800015caa41","tag_id":"61d1cdfdce958b0001b30c77","sort_order":0},{"id":"624b3329c89ec800015caaef","post_id":"624b3187c89ec800015caac5","tag_id":"6196fd5f0af28a00012bf20d","sort_order":1},{"id":"624b3329c89ec800015caaf0","post_id":"624b3187c89ec800015caac5","tag_id":"617c07160af28a00012bf1ae","sort_order":2},{"id":"624b3329c89ec800015caaf1","post_id":"624b3187c89ec800015caac5","tag_id":"61d1cdfdce958b0001b30c77","sort_order":0},{"id":"624b334bc89ec800015caaf3","post_id":"62372c67ce958b0001b30cec","tag_id":"6196fd5f0af28a00012bf20d","sort_order":0},{"id":"624b3363c89ec800015caaf5","post_id":"62372731ce958b0001b30cab","tag_id":"6196fd5f0af28a00012bf20d","sort_order":0},{"id":"6292644a8b6a1d0001b86ce0","post_id":"629262fd8b6a1d0001b86ca8","tag_id":"617c07160af28a00012bf1ae","sort_order":0}],"products":[{"id":"616073b867f6c50001275350","name":"Nocoder Blog","slug":"default-product","monthly_price_id":null,"yearly_price_id":null,"description":null,"created_at":"2021-10-08 16:37:12","updated_at":"2021-10-08 16:48:24","type":"paid","active":1,"welcome_page_url":"/","visibility":"public"},{"id":"624bf0398b6a1d0001b86c9b","name":"Free","slug":"624bf0398b6a1d0001b86c9b","monthly_price_id":null,"yearly_price_id":null,"description":null,"created_at":"2022-04-05 07:31:05","updated_at":null,"type":"free","active":1,"welcome_page_url":"/","visibility":"public"}],"benefits":[],"products_benefits":[],"stripe_products":[],"stripe_prices":[],"snippets":[],"custom_theme_settings":[{"id":"6197067deff3f40001c5e8dc","theme":"casper","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"6197067deff3f40001c5e8dd","theme":"casper","key":"body_font","type":"select","value":"Elegant serif"},{"id":"6197067deff3f40001c5e8de","theme":"casper","key":"publication_cover_style","type":"select","value":"Medium"},{"id":"6197067deff3f40001c5e8df","theme":"casper","key":"feed_layout","type":"select","value":"Dynamic grid"},{"id":"6197067deff3f40001c5e8e0","theme":"casper","key":"color_scheme","type":"select","value":"Light"},{"id":"6197067deff3f40001c5e8e1","theme":"casper","key":"header_button_background","type":"color","value":"#ffffff"},{"id":"6197067deff3f40001c5e8e2","theme":"casper","key":"header_button_text_color","type":"select","value":"Dark"},{"id":"6197067deff3f40001c5e8e3","theme":"casper","key":"post_image_width","type":"select","value":"Wide"},{"id":"6197067deff3f40001c5e8e4","theme":"casper","key":"email_signup_for_logged_out_visitors","type":"select","value":"Footer"},{"id":"6197067deff3f40001c5e8e5","theme":"casper","key":"email_signup_text","type":"text","value":"Sign up for more like this."},{"id":"6197067deff3f40001c5e8e6","theme":"casper","key":"show_recent_posts","type":"boolean","value":"true"},{"id":"619709b8eff3f40001c5e8e8","theme":"journal","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"619709b8eff3f40001c5e8e9","theme":"journal","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61970a5aeff3f40001c5e8eb","theme":"dawn","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"61970a5aeff3f40001c5e8ec","theme":"dawn","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61970a5aeff3f40001c5e8ed","theme":"dawn","key":"content_api_key_for_search","type":"text","value":null},{"id":"61970a5aeff3f40001c5e8ee","theme":"dawn","key":"show_featured_posts","type":"boolean","value":"true"},{"id":"61970a5aeff3f40001c5e8ef","theme":"dawn","key":"featured_title","type":"text","value":"Featured articles"},{"id":"61970a5aeff3f40001c5e8f0","theme":"dawn","key":"show_share_links","type":"boolean","value":"true"},{"id":"61970a5aeff3f40001c5e8f1","theme":"dawn","key":"show_author","type":"boolean","value":"true"},{"id":"61970a5aeff3f40001c5e8f2","theme":"dawn","key":"show_related_posts","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e8fe","theme":"alto","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"61973a8aeff3f40001c5e8ff","theme":"alto","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61973a8aeff3f40001c5e900","theme":"alto","key":"show_featured_posts","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e901","theme":"alto","key":"show_share_links","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e902","theme":"alto","key":"show_author","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e903","theme":"alto","key":"show_related_posts","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90a","theme":"ruby","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"6197c9c0eff3f40001c5e90b","theme":"ruby","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"6197c9c0eff3f40001c5e90c","theme":"ruby","key":"show_sidebar_on_homepage","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90d","theme":"ruby","key":"show_related_posts","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90e","theme":"ruby","key":"show_sidebar_on_post","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90f","theme":"ruby","key":"show_share_links","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e910","theme":"ruby","key":"show_author","type":"boolean","value":"true"},{"id":"61acd4341fb64e0001fdd019","theme":"ruby-nocoder","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"61acd4341fb64e0001fdd01a","theme":"ruby-nocoder","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61acd4341fb64e0001fdd01b","theme":"ruby-nocoder","key":"show_sidebar_on_homepage","type":"boolean","value":"true"},{"id":"61acd4341fb64e0001fdd01c","theme":"ruby-nocoder","key":"show_related_posts","type":"boolean","value":"true"},{"id":"61acd4341fb64e0001fdd01d","theme":"ruby-nocoder","key":"show_sidebar_on_post","type":"boolean","value":"true"},{"id":"61acd4341fb64e0001fdd01e","theme":"ruby-nocoder","key":"show_share_links","type":"boolean","value":"true"},{"id":"61acd4341fb64e0001fdd01f","theme":"ruby-nocoder","key":"show_author","type":"boolean","value":"true"},{"id":"62488af2c89ec800015caac0","theme":"digest","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"62488af2c89ec800015caac1","theme":"digest","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"62488af2c89ec800015caac2","theme":"digest","key":"feature_image_width","type":"select","value":"Small"}],"offer_redemptions":[],"offers":[],"posts_products":[{"id":"629263058b6a1d0001b86cac","post_id":"629262fd8b6a1d0001b86ca8","product_id":"616073b867f6c50001275350","sort_order":0},{"id":"629263058b6a1d0001b86cad","post_id":"629262fd8b6a1d0001b86ca8","product_id":"624bf0398b6a1d0001b86c9b","sort_order":1}]}}