{"meta":{"exported_on":1638374166537,"version":"4.24.0"},"data":{"posts":[{"id":"6160769067f6c50001275527","uuid":"795bf84f-3b1a-436a-9dc3-d8a523b886f4","title":"关于日志的那些事儿","slug":"guan-yu-ri-zhi-de-na-xie-shi-er","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 这篇短文整理了关于日志的一些内容，皓哥要求的目标是一篇“引经据典“的，“全面系统“的对日志的介绍。结合以往的经验和一些参考链接，对软件开发过程中日志相关的知识进行梳理和学习。\\n\\n## 日志的定义\\n\\n先说说咱们日常生活中的日志，就是日记的另一种说法。\\n\\n> [日记](https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0)是以日期为排列顺序的笔记。人们用日记来记录天气、事件一直到个人的心理感受、思想深处。日记可以是记录将要做的事情的，也可以记录已经发生的事情和心情。\\n\\n在计算机领域，日志文件的定义如下：\\n\\n> [日志文件](https://zh.wikipedia.org/zh-hans/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6)(logfile)是一个记录了发生在运行中的操作系统或其他软件中的事件的文件，或者记录了在网络聊天软件的用户之间发送的消息。日志记录(Logging)是指保存日志的行为。\\n\\n\\n## 日志的意义\\n\\n记录日志是软件开发中很重要的一部分。编写良好的日志代码能为软件提供快速的诊断信息和良好的存储结构。我们可以通过对记录的日志进行分析来支撑一些其他的功能，例如解析mysql的binary log来同步数据，通过日志分析用户行为，系统某功能的访问频率，通过日志排查程序的BUG等等。\\n\\n- 开发人员调试程序\\n  - 开发阶段的debug日志，通过输出重要参数来调试跟踪程序的正确性\\n- 记录用户行为\\n  - 记录用户的操作，访问，一般用于数据分析，操作留痕 \\n- 记录程序的运行情况\\n  - 记录程序的运行情况，尤其是异常情况，是排查问题的重要线索\\n- 记录系统的状态\\n  - 记录网络请求、IO等，便于监控和排查问题\\n\\n## 日志的类型\\n\\n- 行为日志\\n  - 分析用户的行为日志内容来实现数据分析等功能 \\n- 访问日志\\n  - 访问来源、功能的访问频率 \\n- 错误日志\\n  - 记录程序运行错误的现场，解决问题的重要线索\\n- 数据库日志\\n  - 记录SQL记录，可以分析慢SQL，生成报告 \\n- ...\\n\\n## 日志的格式\\n\\n每条日志都要记录发生的时间、级别、日志内容、错误码、以及对应代码的位置，存储在文本文件或者数据库中。\\n\\t\\n\\n- JSON\\n\\n  ```\\n  {\\n  \\t\\t\\\"@timestamp\\\": \\\"2017-07025 17:02:12\\\",\\n  \\t\\t\\\"level\\\": \\\"error\\\",\\n  \\t\\t\\\"message\\\": \\\"connection refused\\\",\\n  \\t\\t\\\"service\\\": \\\"listener\\\",\\n  \\t\\t\\\"thread\\\": \\\"125\\\",\\n  \\t\\t\\\"customerid\\\": \\\"776622\\\",\\n  \\t\\t\\\"ip\\\": \\\"34.124.233.12\\\",\\n  \\t\\t\\\"queryid\\\": \\\"45\\\"\\n  \\t}\\n  ```\\n\\n- 键值对\\n\\n  ```\\n  \\t2017-07025 17:02:12 level=error message=\\\"connection refused\\\"\\n  service=\\\"listener\\\" thread=125 customerid=776622 ip=34.124.233.12\\n  queryid=45\\n  ```\\n\\n## 日志的级别\\n\\n不同的日志框架对日志的分类略有差异，通常来说，日志可以被分为以下六个级别，通过配置来输出对应级别的日志\\n\\n- FATAL\\n  - 导致程序提前结束的严重错误。\\n- ERROR\\n  - 运行时异常以及预期之外的错误。\\n- WARN\\n  - 预期之外的运行时状况，不一定是错误的情况。\\n- INFO\\n  - 运行时产生的事件。\\n- DEBUG\\n  - 与程序运行时的流程相关的详细信息。\\n- TRACE\\n  - 更加具体的详细信息。\\n\\n## 日志归档\\n\\n根据天数或者文件大小产生新的文件，对日志进行滚动归档，压缩保存。\\n\\n\\n## 日志的性能\\n\\n记录日志是软件开发必不可少的环节，必须考虑日志的性能带来的问题，举两个例子：\\n\\n- 使用占位符而不是字符串连接\\n\\n```\\nlogger.debug(\\\"Entry number: \\\" + i + \\\" is \\\" +  String.valueOf(entry[i])); \\nlogger.debug(\\\"Entry number: {} is {}\\\", i, entry[i]);\\n```\\n\\n上面两个语句输出的效果是一样的，但是性能却相差两个数量级，在关闭DEBUG日志时，它们的开销就不一样了，主要的影响在于字符串转换和字符串拼接上，无论是否生效，前者都会将变量转换为字符串并进行拼接，而后者则只会在需要时执行这些操作。\\n\\n- 避免无用的日志\\n  - 无用的日志占用磁盘空间，增加系统IO，影响系统性能 \\n\\n## 日志框架\\n\\n列举一些 Java 程序里常用的日志框架\\n\\n- Java Util Logger\\n  - Jdk 自带的 Logger， 从1.4版本开始就有了，使用起来非常方便，一般用于测试，不支持占位符\\n- Log4j\\n  - Log4j 应该是最常用的日志框架了，其高度可配置，在运行期使用外部的配置文件对其进行配置。它按照优先级别记录日志，并可将日志信息定向输出到各种介质，比如数据库、文件、控制台、Unix Syslog等。\\n  - loggers：负责采集日志信息。\\n  - appenders：负责将日志信息发布到不同地方。\\n  - layouts：负责以各种风格格式化日志信息。 \\t\\n- Slf4j\\n  - Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。\\n\\n- Logback\\n  - LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。 \\n  - LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。\\n  - logback-core提供了LogBack的核心功能，是另外两个组件的基础。\\n  - logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。\\n  - logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。\\n- ...\\n\\n## 最佳实践\\n\\n- 定义记录日志的目标\\n  - 记录日志的意义何在，用于数据分析，还是同步数据，或者其他 \\n- 记录什么内容\\n  - 记录有用的日志内容，考虑提高日志可读性，提高系统性能 \\n- 使用日志框架\\n  - 日志框架更专业，功能全面，标准化，易配置\\n- 标准化日志格式\\n  - 统一日志格式 \\n- 提供上下文\\n  - 尽可能的提供完整信息，提高可读性，如果记录不完整，对于数据分析、排查错误起不到作用，记日志的意义就不大了 \\n- 使用日志标识，异常码\\n  - 使用异常码，例如`30001`代表用户模块，`30002`代表XX模块，这样在看到日志的时候就可以清楚快速的定位到对应的功能。 \\n\\n## 参考文献\\n\\n- [日志文件wiki](https://zh.wikipedia.org/wiki/日志文件)\\n- [30 best practices for logging at scale](https://www.loggly.com/blog/30-best-practices-logging-scale/)\\n- [How to Log a Log: Application Logging Best Practices](https://logz.io/blog/logging-best-practices/)\\n- [Java Best Practices for Smarter Application Logging & Exception Handling](https://stackify.com/java-logging-best-practices/)\\n- [10 Best Practices for Log Management and Analytics](https://dzone.com/articles/10-best-practices-for-log-management-and-analytics-1)\\n- [程序那些事：日志记录的作用和方法](https://www.infoq.cn/article/why-and-how-log)\\n- [日志的五个级别](https://www.infoq.cn/article/five-levels-of-logging)\\n- [你的Java日志，有没有用这些改进办法？](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=207451012&idx=1&sn=de9fba4eda0f221363b6d5ae54243416&scene=27#wechat_redirect)\\n- [Java 日志管理最佳实践](https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/index.html)\\n- [日志最佳实践](http://blog.jobbole.com/56574/)\\n- [Ultimate log4j Tutorial for Java Logging – Best Practices, Resources and Tips](https://stackify.com/log4j-guide-dotnet-logging/)\\n\\n\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>这篇短文整理了关于日志的一些内容，皓哥要求的目标是一篇“引经据典“的，“全面系统“的对日志的介绍。结合以往的经验和一些参考链接，对软件开发过程中日志相关的知识进行梳理和学习。</p>\n</blockquote>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9A%E4%B9%89\">日志的定义</h2>\n<p>先说说咱们日常生活中的日志，就是日记的另一种说法。</p>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0\">日记</a>是以日期为排列顺序的笔记。人们用日记来记录天气、事件一直到个人的心理感受、思想深处。日记可以是记录将要做的事情的，也可以记录已经发生的事情和心情。</p>\n</blockquote>\n<p>在计算机领域，日志文件的定义如下：</p>\n<blockquote>\n<p><a href=\"https://zh.wikipedia.org/zh-hans/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6\">日志文件</a>(logfile)是一个记录了发生在运行中的操作系统或其他软件中的事件的文件，或者记录了在网络聊天软件的用户之间发送的消息。日志记录(Logging)是指保存日志的行为。</p>\n</blockquote>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E6%84%8F%E4%B9%89\">日志的意义</h2>\n<p>记录日志是软件开发中很重要的一部分。编写良好的日志代码能为软件提供快速的诊断信息和良好的存储结构。我们可以通过对记录的日志进行分析来支撑一些其他的功能，例如解析mysql的binary log来同步数据，通过日志分析用户行为，系统某功能的访问频率，通过日志排查程序的BUG等等。</p>\n<ul>\n<li>开发人员调试程序\n<ul>\n<li>开发阶段的debug日志，通过输出重要参数来调试跟踪程序的正确性</li>\n</ul>\n</li>\n<li>记录用户行为\n<ul>\n<li>记录用户的操作，访问，一般用于数据分析，操作留痕</li>\n</ul>\n</li>\n<li>记录程序的运行情况\n<ul>\n<li>记录程序的运行情况，尤其是异常情况，是排查问题的重要线索</li>\n</ul>\n</li>\n<li>记录系统的状态\n<ul>\n<li>记录网络请求、IO等，便于监控和排查问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E7%B1%BB%E5%9E%8B\">日志的类型</h2>\n<ul>\n<li>行为日志\n<ul>\n<li>分析用户的行为日志内容来实现数据分析等功能</li>\n</ul>\n</li>\n<li>访问日志\n<ul>\n<li>访问来源、功能的访问频率</li>\n</ul>\n</li>\n<li>错误日志\n<ul>\n<li>记录程序运行错误的现场，解决问题的重要线索</li>\n</ul>\n</li>\n<li>数据库日志\n<ul>\n<li>记录SQL记录，可以分析慢SQL，生成报告</li>\n</ul>\n</li>\n<li>...</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%BC%E5%BC%8F\">日志的格式</h2>\n<p>每条日志都要记录发生的时间、级别、日志内容、错误码、以及对应代码的位置，存储在文本文件或者数据库中。</p>\n<ul>\n<li>\n<p>JSON</p>\n<pre><code>{\n\t\t&quot;@timestamp&quot;: &quot;2017-07025 17:02:12&quot;,\n\t\t&quot;level&quot;: &quot;error&quot;,\n\t\t&quot;message&quot;: &quot;connection refused&quot;,\n\t\t&quot;service&quot;: &quot;listener&quot;,\n\t\t&quot;thread&quot;: &quot;125&quot;,\n\t\t&quot;customerid&quot;: &quot;776622&quot;,\n\t\t&quot;ip&quot;: &quot;34.124.233.12&quot;,\n\t\t&quot;queryid&quot;: &quot;45&quot;\n\t}\n</code></pre>\n</li>\n<li>\n<p>键值对</p>\n<pre><code>\t2017-07025 17:02:12 level=error message=&quot;connection refused&quot;\nservice=&quot;listener&quot; thread=125 customerid=776622 ip=34.124.233.12\nqueryid=45\n</code></pre>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E7%BA%A7%E5%88%AB\">日志的级别</h2>\n<p>不同的日志框架对日志的分类略有差异，通常来说，日志可以被分为以下六个级别，通过配置来输出对应级别的日志</p>\n<ul>\n<li>FATAL\n<ul>\n<li>导致程序提前结束的严重错误。</li>\n</ul>\n</li>\n<li>ERROR\n<ul>\n<li>运行时异常以及预期之外的错误。</li>\n</ul>\n</li>\n<li>WARN\n<ul>\n<li>预期之外的运行时状况，不一定是错误的情况。</li>\n</ul>\n</li>\n<li>INFO\n<ul>\n<li>运行时产生的事件。</li>\n</ul>\n</li>\n<li>DEBUG\n<ul>\n<li>与程序运行时的流程相关的详细信息。</li>\n</ul>\n</li>\n<li>TRACE\n<ul>\n<li>更加具体的详细信息。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3\">日志归档</h2>\n<p>根据天数或者文件大小产生新的文件，对日志进行滚动归档，压缩保存。</p>\n<h2 id=\"%E6%97%A5%E5%BF%97%E7%9A%84%E6%80%A7%E8%83%BD\">日志的性能</h2>\n<p>记录日志是软件开发必不可少的环节，必须考虑日志的性能带来的问题，举两个例子：</p>\n<ul>\n<li>使用占位符而不是字符串连接</li>\n</ul>\n<pre><code>logger.debug(&quot;Entry number: &quot; + i + &quot; is &quot; +  String.valueOf(entry[i])); \nlogger.debug(&quot;Entry number: {} is {}&quot;, i, entry[i]);\n</code></pre>\n<p>上面两个语句输出的效果是一样的，但是性能却相差两个数量级，在关闭DEBUG日志时，它们的开销就不一样了，主要的影响在于字符串转换和字符串拼接上，无论是否生效，前者都会将变量转换为字符串并进行拼接，而后者则只会在需要时执行这些操作。</p>\n<ul>\n<li>避免无用的日志\n<ul>\n<li>无用的日志占用磁盘空间，增加系统IO，影响系统性能</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6\">日志框架</h2>\n<p>列举一些 Java 程序里常用的日志框架</p>\n<ul>\n<li>\n<p>Java Util Logger</p>\n<ul>\n<li>Jdk 自带的 Logger， 从1.4版本开始就有了，使用起来非常方便，一般用于测试，不支持占位符</li>\n</ul>\n</li>\n<li>\n<p>Log4j</p>\n<ul>\n<li>Log4j 应该是最常用的日志框架了，其高度可配置，在运行期使用外部的配置文件对其进行配置。它按照优先级别记录日志，并可将日志信息定向输出到各种介质，比如数据库、文件、控制台、Unix Syslog等。</li>\n<li>loggers：负责采集日志信息。</li>\n<li>appenders：负责将日志信息发布到不同地方。</li>\n<li>layouts：负责以各种风格格式化日志信息。</li>\n</ul>\n</li>\n<li>\n<p>Slf4j</p>\n<ul>\n<li>Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。</li>\n</ul>\n</li>\n<li>\n<p>Logback</p>\n<ul>\n<li>LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。</li>\n<li>LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。</li>\n<li>logback-core提供了LogBack的核心功能，是另外两个组件的基础。</li>\n<li>logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。</li>\n<li>logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。</li>\n</ul>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n<h2 id=\"%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</h2>\n<ul>\n<li>定义记录日志的目标\n<ul>\n<li>记录日志的意义何在，用于数据分析，还是同步数据，或者其他</li>\n</ul>\n</li>\n<li>记录什么内容\n<ul>\n<li>记录有用的日志内容，考虑提高日志可读性，提高系统性能</li>\n</ul>\n</li>\n<li>使用日志框架\n<ul>\n<li>日志框架更专业，功能全面，标准化，易配置</li>\n</ul>\n</li>\n<li>标准化日志格式\n<ul>\n<li>统一日志格式</li>\n</ul>\n</li>\n<li>提供上下文\n<ul>\n<li>尽可能的提供完整信息，提高可读性，如果记录不完整，对于数据分析、排查错误起不到作用，记日志的意义就不大了</li>\n</ul>\n</li>\n<li>使用日志标识，异常码\n<ul>\n<li>使用异常码，例如<code>30001</code>代表用户模块，<code>30002</code>代表XX模块，这样在看到日志的时候就可以清楚快速的定位到对应的功能。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h2>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6\">日志文件wiki</a></li>\n<li><a href=\"https://www.loggly.com/blog/30-best-practices-logging-scale/\">30 best practices for logging at scale</a></li>\n<li><a href=\"https://logz.io/blog/logging-best-practices/\">How to Log a Log: Application Logging Best Practices</a></li>\n<li><a href=\"https://stackify.com/java-logging-best-practices/\">Java Best Practices for Smarter Application Logging &amp; Exception Handling</a></li>\n<li><a href=\"https://dzone.com/articles/10-best-practices-for-log-management-and-analytics-1\">10 Best Practices for Log Management and Analytics</a></li>\n<li><a href=\"https://www.infoq.cn/article/why-and-how-log\">程序那些事：日志记录的作用和方法</a></li>\n<li><a href=\"https://www.infoq.cn/article/five-levels-of-logging\">日志的五个级别</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=207451012&amp;idx=1&amp;sn=de9fba4eda0f221363b6d5ae54243416&amp;scene=27#wechat_redirect\">你的Java日志，有没有用这些改进办法？</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/index.html\">Java 日志管理最佳实践</a></li>\n<li><a href=\"http://blog.jobbole.com/56574/\">日志最佳实践</a></li>\n<li><a href=\"https://stackify.com/log4j-guide-dotnet-logging/\">Ultimate log4j Tutorial for Java Logging – Best Practices, Resources and Tips</a></li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"6160769067f6c50001275527","plaintext":"> 这篇短文整理了关于日志的一些内容，皓哥要求的目标是一篇“引经据典“的，“全面系统“的对日志的介绍。结合以往的经验和一些参考链接，对软件开发过程中日志相关的知识进行梳理和学习。\n\n\n日志的定义\n先说说咱们日常生活中的日志，就是日记的另一种说法。\n\n> 日记 [https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AE%B0]\n是以日期为排列顺序的笔记。人们用日记来记录天气、事件一直到个人的心理感受、思想深处。日记可以是记录将要做的事情的，也可以记录已经发生的事情和心情。\n\n\n在计算机领域，日志文件的定义如下：\n\n> 日志文件 [https://zh.wikipedia.org/zh-hans/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6]\n(logfile)是一个记录了发生在运行中的操作系统或其他软件中的事件的文件，或者记录了在网络聊天软件的用户之间发送的消息。日志记录(Logging)是指保存日志的行为。\n\n\n日志的意义\n记录日志是软件开发中很重要的一部分。编写良好的日志代码能为软件提供快速的诊断信息和良好的存储结构。我们可以通过对记录的日志进行分析来支撑一些其他的功能，例如解析mysql的binary\nlog来同步数据，通过日志分析用户行为，系统某功能的访问频率，通过日志排查程序的BUG等等。\n\n * 开发人员调试程序 * 开发阶段的debug日志，通过输出重要参数来调试跟踪程序的正确性\n   \n   \n * 记录用户行为 * 记录用户的操作，访问，一般用于数据分析，操作留痕\n   \n   \n * 记录程序的运行情况 * 记录程序的运行情况，尤其是异常情况，是排查问题的重要线索\n   \n   \n * 记录系统的状态 * 记录网络请求、IO等，便于监控和排查问题\n   \n   \n\n日志的类型\n * 行为日志 * 分析用户的行为日志内容来实现数据分析等功能\n   \n   \n * 访问日志 * 访问来源、功能的访问频率\n   \n   \n * 错误日志 * 记录程序运行错误的现场，解决问题的重要线索\n   \n   \n * 数据库日志 * 记录SQL记录，可以分析慢SQL，生成报告\n   \n   \n * ...\n\n日志的格式\n每条日志都要记录发生的时间、级别、日志内容、错误码、以及对应代码的位置，存储在文本文件或者数据库中。\n\n * JSON\n   \n   {\n   \t\t\"@timestamp\": \"2017-07025 17:02:12\",\n   \t\t\"level\": \"error\",\n   \t\t\"message\": \"connection refused\",\n   \t\t\"service\": \"listener\",\n   \t\t\"thread\": \"125\",\n   \t\t\"customerid\": \"776622\",\n   \t\t\"ip\": \"34.124.233.12\",\n   \t\t\"queryid\": \"45\"\n   \t}\n   \n   \n   \n * 键值对\n   \n   \t2017-07025 17:02:12 level=error message=\"connection refused\"\n   service=\"listener\" thread=125 customerid=776622 ip=34.124.233.12\n   queryid=45\n   \n   \n   \n\n日志的级别\n不同的日志框架对日志的分类略有差异，通常来说，日志可以被分为以下六个级别，通过配置来输出对应级别的日志\n\n * FATAL * 导致程序提前结束的严重错误。\n   \n   \n * ERROR * 运行时异常以及预期之外的错误。\n   \n   \n * WARN * 预期之外的运行时状况，不一定是错误的情况。\n   \n   \n * INFO * 运行时产生的事件。\n   \n   \n * DEBUG * 与程序运行时的流程相关的详细信息。\n   \n   \n * TRACE * 更加具体的详细信息。\n   \n   \n\n日志归档\n根据天数或者文件大小产生新的文件，对日志进行滚动归档，压缩保存。\n\n日志的性能\n记录日志是软件开发必不可少的环节，必须考虑日志的性能带来的问题，举两个例子：\n\n * 使用占位符而不是字符串连接\n\nlogger.debug(\"Entry number: \" + i + \" is \" +  String.valueOf(entry[i])); \nlogger.debug(\"Entry number: {} is {}\", i, entry[i]);\n\n\n上面两个语句输出的效果是一样的，但是性能却相差两个数量级，在关闭DEBUG日志时，它们的开销就不一样了，主要的影响在于字符串转换和字符串拼接上，无论是否生效，前者都会将变量转换为字符串并进行拼接，而后者则只会在需要时执行这些操作。\n\n * 避免无用的日志 * 无用的日志占用磁盘空间，增加系统IO，影响系统性能\n   \n   \n\n日志框架\n列举一些 Java 程序里常用的日志框架\n\n * Java Util Logger\n   \n    * Jdk 自带的 Logger， 从1.4版本开始就有了，使用起来非常方便，一般用于测试，不支持占位符\n   \n   \n * Log4j\n   \n    * Log4j\n      应该是最常用的日志框架了，其高度可配置，在运行期使用外部的配置文件对其进行配置。它按照优先级别记录日志，并可将日志信息定向输出到各种介质，比如数据库、文件、控制台、Unix\n      Syslog等。\n    * loggers：负责采集日志信息。\n    * appenders：负责将日志信息发布到不同地方。\n    * layouts：负责以各种风格格式化日志信息。\n   \n   \n * Slf4j\n   \n    * Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade\n      API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。\n   \n   \n * Logback\n   \n    * LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。\n    * LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。\n    * logback-core提供了LogBack的核心功能，是另外两个组件的基础。\n    * logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。\n    * logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。\n   \n   \n * ...\n   \n   \n\n最佳实践\n * 定义记录日志的目标 * 记录日志的意义何在，用于数据分析，还是同步数据，或者其他\n   \n   \n * 记录什么内容 * 记录有用的日志内容，考虑提高日志可读性，提高系统性能\n   \n   \n * 使用日志框架 * 日志框架更专业，功能全面，标准化，易配置\n   \n   \n * 标准化日志格式 * 统一日志格式\n   \n   \n * 提供上下文 * 尽可能的提供完整信息，提高可读性，如果记录不完整，对于数据分析、排查错误起不到作用，记日志的意义就不大了\n   \n   \n * 使用日志标识，异常码 * 使用异常码，例如30001代表用户模块，30002代表XX模块，这样在看到日志的时候就可以清楚快速的定位到对应的功能。\n   \n   \n\n参考文献\n * 日志文件wiki [https://zh.wikipedia.org/wiki/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6]\n * 30 best practices for logging at scale\n   [https://www.loggly.com/blog/30-best-practices-logging-scale/]\n * How to Log a Log: Application Logging Best Practices\n   [https://logz.io/blog/logging-best-practices/]\n * Java Best Practices for Smarter Application Logging & Exception Handling\n   [https://stackify.com/java-logging-best-practices/]\n * 10 Best Practices for Log Management and Analytics\n   [https://dzone.com/articles/10-best-practices-for-log-management-and-analytics-1]\n * 程序那些事：日志记录的作用和方法 [https://www.infoq.cn/article/why-and-how-log]\n * 日志的五个级别 [https://www.infoq.cn/article/five-levels-of-logging]\n * 你的Java日志，有没有用这些改进办法？\n   [https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=207451012&idx=1&sn=de9fba4eda0f221363b6d5ae54243416&scene=27#wechat_redirect]\n * Java 日志管理最佳实践\n   [https://www.ibm.com/developerworks/cn/java/j-lo-practicelog/index.html]\n * 日志最佳实践 [http://blog.jobbole.com/56574/]\n * Ultimate log4j Tutorial for Java Logging – Best Practices, Resources and Tips\n   [https://stackify.com/log4j-guide-dotnet-logging/]","feature_image":"__GHOST_URL__/content/images/2021/10/v2-0baa2161ee18982a3184ce4e9dea019c_r.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-08 16:49:20","created_by":"1","updated_at":"2021-11-19 06:49:23","updated_by":"1","published_at":"2018-11-12 16:50:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61607b040af28a00012bf0de","uuid":"d64adfc1-5244-443d-8532-0ae771abfce9","title":"常用的图算法","slug":"chang-yong-de-tu-suan-fa","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 最近做了一些涉及到图的算法题，特此归纳总结一下图的基础、广度优先搜索、深度优先搜索、迪克斯特拉算法以及贝尔曼福德算法。\\n\\n## 什么是图\\n\\n![basic-graph](./basic-graph.png)\\n\\n[图](https://zh.wikipedia.org/wiki/图_(数学))是由节点（node）和边（edge）组成的一种数据结构。上图中，A 和 B 是该图的节点，连接线是图的一条边。\\n\\n图模拟了一组连接，一个节点可能与很多节点直接相连，这些节点称为**邻居节点**，需要注意的是，在上面的图中，A指向B，说明B是A的邻居节点，但B没有指向A，说明A不是B的邻居节点。\\n\\n## 图的分类\\n\\n### 有向图\\n\\n如果给图的每条边都规定一个方向，那么该图就称为有向图，有向图所有的连接关系都是单向的。\\n\\n![directed-graph](./directed-graph.png)\\n\\n### 无向图\\n\\n边没有方向的图称为无向图，无向图其实意味着图的**两个节点彼此指向对方**，其实就是环。\\n\\n![undirected-graph](./undirected-graph.png)\\n\\n### 加权图\\n\\n图的每条边都有关联的数字，这些数字称为**权重**，带权重的图称为**加权图**。\\n\\n![directed-wieghted-graph](./directed-weighted-graph.png)\\n\\n### 非加权图\\n\\n不带权重的图称为非加权图。\\n\\n## 广度优先搜索(Breadth-First-Search)\\n\\n> **广度优先搜索算法**（英语：Breadth-First-Search，缩写为BFS），又译作**宽度优先搜索**，或**横向优先搜索**，是一种[图形搜索算法](https://zh.wikipedia.org/w/index.php?title=圖形搜索演算法&action=edit&redlink=1)。简单的说，BFS是从[根节点](https://zh.wikipedia.org/w/index.php?title=根節點&action=edit&redlink=1)开始，沿着树的宽度遍历树的[节点](https://zh.wikipedia.org/wiki/节点)。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表\\n\\n[广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)解决两类问题：\\n\\n1. 从节点A出发，有没有前往节点B的路径\\n2. 从节点A出发，前往节点B的那条路径最短，或者说哪条路径的段数最少？\\n\\n广度优先搜索中，起点的邻居称为一度关系，其邻居的邻居称为二度关系，搜索顺序是先一度关系，再二度关系，以此类推。在代码实现时，需要使用**双端队列**来保证搜索顺序。\\n\\n广度优先搜索的步骤：\\n\\n1. 创建一个队列，将起点的所有邻居节点压入到队列中；\\n2. 从队列弹出一个节点，检查这个节点是否终点，如果是，则完成搜索；\\n3. 如果该节点不是终点，则将该节点的所有邻居节点压入上述队列中；\\n4. 回到第2步，继续检查；\\n5. 如果队列为空，说明终点不可达，找不到该路径。\\n\\n## 狄克斯特拉算法(Dijkstra)\\n\\n> **戴克斯特拉算法**（英语：Dijkstra's algorithm，又译**迪杰斯特拉算法**）由荷兰计算机科学家[艾兹赫尔·戴克斯特拉](https://zh.wikipedia.org/wiki/艾兹赫尔·戴克斯特拉)在1956年提出。戴克斯特拉算法使用了[广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)解决赋权有向图的单源[最短路径问题](https://zh.wikipedia.org/wiki/最短路径问题)。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个[最短路径树](https://zh.wikipedia.org/wiki/最短路径树)。该算法常用于[路由](https://zh.wikipedia.org/wiki/路由)算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。\\n\\n广度优先搜索可以找到段数最少的路径，但是无法找到**开销**最小的路径，[狄克斯特拉算法](https://zh.wikipedia.org/wiki/戴克斯特拉算法)就是用来解决这类问题的。什么是**开销**，可以理解为总权重，假设从起点出发到节点B需要2小时，那么可以称起点到节点B的**开销**为2。当然，开销也可以是其他的计量单位，例如从起点出发到节点B距离3公里，可以计作起点到节点B的**开销**为3。\\n\\n狄克斯特拉算法的步骤：\\n\\n1. 找出开销最小的节点，即可以在最短的时间内到达的节点；\\n2. 更新该节点的邻居的开销；\\n3. 重复这个过程，直到图中所有的节点都处理完；\\n4. 计算开销最小的路径。\\n\\n注：狄克斯特拉算法仅适用于**有向无环图**\\n\\n## 深度优先搜索(Depth-First-Search)\\n\\n> **深度优先搜索算法**（英语：Depth-First-Search，DFS）是一种用于遍历或搜索[树](https://zh.wikipedia.org/wiki/树_(数据结构))或[图](https://zh.wikipedia.org/wiki/图_(数学))的[算法](https://zh.wikipedia.org/wiki/算法)。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\\n\\n从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。\\n\\n深度优先搜索的步骤：\\n\\n1. 首先将起点放入到队列中；\\n2. 从队列弹出一个节点，并检查它是否为终点，如果是，则完成搜索，返回结果；\\n3. 如果不是终点，则将它某一个没有检查过的邻居节点加入到队列中；\\n4. 回到第2步；\\n5. 如果不存在未检查过的邻居节点，则将其父节点加入队列中，回到第2步；\\n6. 重复第5步；\\n7. 如果队列为空，表示所有的节点都检查过了，完成搜索，返回找不到终点\\n\\n### 参考文献\\n\\n- 《算法图解》\\n- 《算法（第4版）》\\n- [维基百科-图](https://zh.wikipedia.org/wiki/图_(数学))\\n- [维基百科-广度优先搜索](https://zh.wikipedia.org/wiki/广度优先搜索)\\n- [维基百科-戴克斯特拉算法](https://zh.wikipedia.org/wiki/戴克斯特拉算法)\\n- [维基百科-深度优先搜索](https://zh.wikipedia.org/wiki/深度优先搜索)\\n- [wikipedia-Backtracking](https://en.wikipedia.org/wiki/Backtracking)\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>最近做了一些涉及到图的算法题，特此归纳总结一下图的基础、广度优先搜索、深度优先搜索、迪克斯特拉算法以及贝尔曼福德算法。</p>\n</blockquote>\n<h2 id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE\">什么是图</h2>\n<p><img src=\"./basic-graph.png\" alt=\"basic-graph\" loading=\"lazy\"></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\">图</a>是由节点（node）和边（edge）组成的一种数据结构。上图中，A 和 B 是该图的节点，连接线是图的一条边。</p>\n<p>图模拟了一组连接，一个节点可能与很多节点直接相连，这些节点称为<strong>邻居节点</strong>，需要注意的是，在上面的图中，A指向B，说明B是A的邻居节点，但B没有指向A，说明A不是B的邻居节点。</p>\n<h2 id=\"%E5%9B%BE%E7%9A%84%E5%88%86%E7%B1%BB\">图的分类</h2>\n<h3 id=\"%E6%9C%89%E5%90%91%E5%9B%BE\">有向图</h3>\n<p>如果给图的每条边都规定一个方向，那么该图就称为有向图，有向图所有的连接关系都是单向的。</p>\n<p><img src=\"./directed-graph.png\" alt=\"directed-graph\" loading=\"lazy\"></p>\n<h3 id=\"%E6%97%A0%E5%90%91%E5%9B%BE\">无向图</h3>\n<p>边没有方向的图称为无向图，无向图其实意味着图的<strong>两个节点彼此指向对方</strong>，其实就是环。</p>\n<p><img src=\"./undirected-graph.png\" alt=\"undirected-graph\" loading=\"lazy\"></p>\n<h3 id=\"%E5%8A%A0%E6%9D%83%E5%9B%BE\">加权图</h3>\n<p>图的每条边都有关联的数字，这些数字称为<strong>权重</strong>，带权重的图称为<strong>加权图</strong>。</p>\n<p><img src=\"./directed-weighted-graph.png\" alt=\"directed-wieghted-graph\" loading=\"lazy\"></p>\n<h3 id=\"%E9%9D%9E%E5%8A%A0%E6%9D%83%E5%9B%BE\">非加权图</h3>\n<p>不带权重的图称为非加权图。</p>\n<h2 id=\"%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2breadth-first-search\">广度优先搜索(Breadth-First-Search)</h2>\n<blockquote>\n<p><strong>广度优先搜索算法</strong>（英语：Breadth-First-Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种<a href=\"https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1\">图形搜索算法</a>。简单的说，BFS是从<a href=\"https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&amp;action=edit&amp;redlink=1\">根节点</a>开始，沿着树的宽度遍历树的<a href=\"https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9\">节点</a>。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表</p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">广度优先搜索</a>解决两类问题：</p>\n<ol>\n<li>从节点A出发，有没有前往节点B的路径</li>\n<li>从节点A出发，前往节点B的那条路径最短，或者说哪条路径的段数最少？</li>\n</ol>\n<p>广度优先搜索中，起点的邻居称为一度关系，其邻居的邻居称为二度关系，搜索顺序是先一度关系，再二度关系，以此类推。在代码实现时，需要使用<strong>双端队列</strong>来保证搜索顺序。</p>\n<p>广度优先搜索的步骤：</p>\n<ol>\n<li>创建一个队列，将起点的所有邻居节点压入到队列中；</li>\n<li>从队列弹出一个节点，检查这个节点是否终点，如果是，则完成搜索；</li>\n<li>如果该节点不是终点，则将该节点的所有邻居节点压入上述队列中；</li>\n<li>回到第2步，继续检查；</li>\n<li>如果队列为空，说明终点不可达，找不到该路径。</li>\n</ol>\n<h2 id=\"%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95dijkstra\">狄克斯特拉算法(Dijkstra)</h2>\n<blockquote>\n<p><strong>戴克斯特拉算法</strong>（英语：Dijkstra's algorithm，又译<strong>迪杰斯特拉算法</strong>）由荷兰计算机科学家<a href=\"https://zh.wikipedia.org/wiki/%E8%89%BE%E5%85%B9%E8%B5%AB%E5%B0%94%C2%B7%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89\">艾兹赫尔·戴克斯特拉</a>在1956年提出。戴克斯特拉算法使用了<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">广度优先搜索</a>解决赋权有向图的单源<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98\">最短路径问题</a>。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个<a href=\"https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91\">最短路径树</a>。该算法常用于<a href=\"https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1\">路由</a>算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。</p>\n</blockquote>\n<p>广度优先搜索可以找到段数最少的路径，但是无法找到<strong>开销</strong>最小的路径，<a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\">狄克斯特拉算法</a>就是用来解决这类问题的。什么是<strong>开销</strong>，可以理解为总权重，假设从起点出发到节点B需要2小时，那么可以称起点到节点B的<strong>开销</strong>为2。当然，开销也可以是其他的计量单位，例如从起点出发到节点B距离3公里，可以计作起点到节点B的<strong>开销</strong>为3。</p>\n<p>狄克斯特拉算法的步骤：</p>\n<ol>\n<li>找出开销最小的节点，即可以在最短的时间内到达的节点；</li>\n<li>更新该节点的邻居的开销；</li>\n<li>重复这个过程，直到图中所有的节点都处理完；</li>\n<li>计算开销最小的路径。</li>\n</ol>\n<p>注：狄克斯特拉算法仅适用于<strong>有向无环图</strong></p>\n<h2 id=\"%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2depth-first-search\">深度优先搜索(Depth-First-Search)</h2>\n<blockquote>\n<p><strong>深度优先搜索算法</strong>（英语：Depth-First-Search，DFS）是一种用于遍历或搜索<a href=\"https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)\">树</a>或<a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\">图</a>的<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95\">算法</a>。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>\n</blockquote>\n<p>从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。</p>\n<p>深度优先搜索的步骤：</p>\n<ol>\n<li>首先将起点放入到队列中；</li>\n<li>从队列弹出一个节点，并检查它是否为终点，如果是，则完成搜索，返回结果；</li>\n<li>如果不是终点，则将它某一个没有检查过的邻居节点加入到队列中；</li>\n<li>回到第2步；</li>\n<li>如果不存在未检查过的邻居节点，则将其父节点加入队列中，回到第2步；</li>\n<li>重复第5步；</li>\n<li>如果队列为空，表示所有的节点都检查过了，完成搜索，返回找不到终点</li>\n</ol>\n<h3 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h3>\n<ul>\n<li>《算法图解》</li>\n<li>《算法（第4版）》</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)\">维基百科-图</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">维基百科-广度优先搜索</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\">维基百科-戴克斯特拉算法</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">维基百科-深度优先搜索</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Backtracking\">wikipedia-Backtracking</a></li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"61607b040af28a00012bf0de","plaintext":"> 最近做了一些涉及到图的算法题，特此归纳总结一下图的基础、广度优先搜索、深度优先搜索、迪克斯特拉算法以及贝尔曼福德算法。\n\n\n什么是图\n\n\n图 [https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]\n是由节点（node）和边（edge）组成的一种数据结构。上图中，A 和 B 是该图的节点，连接线是图的一条边。\n\n图模拟了一组连接，一个节点可能与很多节点直接相连，这些节点称为邻居节点\n，需要注意的是，在上面的图中，A指向B，说明B是A的邻居节点，但B没有指向A，说明A不是B的邻居节点。\n\n图的分类\n有向图\n如果给图的每条边都规定一个方向，那么该图就称为有向图，有向图所有的连接关系都是单向的。\n\n\n\n无向图\n边没有方向的图称为无向图，无向图其实意味着图的两个节点彼此指向对方，其实就是环。\n\n\n\n加权图\n图的每条边都有关联的数字，这些数字称为权重，带权重的图称为加权图。\n\n\n\n非加权图\n不带权重的图称为非加权图。\n\n广度优先搜索(Breadth-First-Search)\n> 广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法\n[https://zh.wikipedia.org/w/index.php?title=%E5%9C%96%E5%BD%A2%E6%90%9C%E7%B4%A2%E6%BC%94%E7%AE%97%E6%B3%95&action=edit&redlink=1]\n。简单的说，BFS是从根节点\n[https://zh.wikipedia.org/w/index.php?title=%E6%A0%B9%E7%AF%80%E9%BB%9E&action=edit&redlink=1]\n开始，沿着树的宽度遍历树的节点 [https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9]\n。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表\n\n\n广度优先搜索\n[https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n解决两类问题：\n\n 1. 从节点A出发，有没有前往节点B的路径\n 2. 从节点A出发，前往节点B的那条路径最短，或者说哪条路径的段数最少？\n\n广度优先搜索中，起点的邻居称为一度关系，其邻居的邻居称为二度关系，搜索顺序是先一度关系，再二度关系，以此类推。在代码实现时，需要使用双端队列来保证搜索顺序。\n\n广度优先搜索的步骤：\n\n 1. 创建一个队列，将起点的所有邻居节点压入到队列中；\n 2. 从队列弹出一个节点，检查这个节点是否终点，如果是，则完成搜索；\n 3. 如果该节点不是终点，则将该节点的所有邻居节点压入上述队列中；\n 4. 回到第2步，继续检查；\n 5. 如果队列为空，说明终点不可达，找不到该路径。\n\n狄克斯特拉算法(Dijkstra)\n> 戴克斯特拉算法（英语：Dijkstra's algorithm，又译迪杰斯特拉算法）由荷兰计算机科学家艾兹赫尔·戴克斯特拉\n[https://zh.wikipedia.org/wiki/%E8%89%BE%E5%85%B9%E8%B5%AB%E5%B0%94%C2%B7%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89]\n在1956年提出。戴克斯特拉算法使用了广度优先搜索\n[https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n解决赋权有向图的单源最短路径问题\n[https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98]\n。该算法存在很多变体；戴克斯特拉的原始版本找到两个顶点之间的最短路径，但是更常见的变体固定了一个顶点作为源节点然后找到该顶点到图中所有其它节点的最短路径，产生一个\n最短路径树\n[https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91]\n。该算法常用于路由 [https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1]\n算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。\n\n\n广度优先搜索可以找到段数最少的路径，但是无法找到开销最小的路径，狄克斯特拉算法\n[https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95]\n就是用来解决这类问题的。什么是开销，可以理解为总权重，假设从起点出发到节点B需要2小时，那么可以称起点到节点B的开销\n为2。当然，开销也可以是其他的计量单位，例如从起点出发到节点B距离3公里，可以计作起点到节点B的开销为3。\n\n狄克斯特拉算法的步骤：\n\n 1. 找出开销最小的节点，即可以在最短的时间内到达的节点；\n 2. 更新该节点的邻居的开销；\n 3. 重复这个过程，直到图中所有的节点都处理完；\n 4. 计算开销最小的路径。\n\n注：狄克斯特拉算法仅适用于有向无环图\n\n深度优先搜索(Depth-First-Search)\n> 深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树\n[https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)]\n或图 [https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]的算法\n[https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95]\n。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n\n\n从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。\n\n深度优先搜索的步骤：\n\n 1. 首先将起点放入到队列中；\n 2. 从队列弹出一个节点，并检查它是否为终点，如果是，则完成搜索，返回结果；\n 3. 如果不是终点，则将它某一个没有检查过的邻居节点加入到队列中；\n 4. 回到第2步；\n 5. 如果不存在未检查过的邻居节点，则将其父节点加入队列中，回到第2步；\n 6. 重复第5步；\n 7. 如果队列为空，表示所有的节点都检查过了，完成搜索，返回找不到终点\n\n参考文献\n * 《算法图解》\n * 《算法（第4版）》\n * 维基百科-图 [https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)]\n * 维基百科-广度优先搜索\n   [https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n * 维基百科-戴克斯特拉算法\n   [https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95]\n * 维基百科-深度优先搜索\n   [https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2]\n * wikipedia-Backtracking [https://en.wikipedia.org/wiki/Backtracking]","feature_image":"__GHOST_URL__/content/images/2021/10/v2-dc1e337068536c7b5b1f400852863b37_1440w.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-08 17:08:20","created_by":"1","updated_at":"2021-10-08 17:11:59","updated_by":"1","published_at":"2019-05-28 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"61607f310af28a00012bf105","uuid":"ea33468c-b227-4722-97a0-a7d9ea18c0df","title":"面向切面编程","slug":"mian-xiang-qie-mian-bian-cheng","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> AOP 被认为是对 OOP 的一个强大的补充，有了 AOP，我们可以把之前分散在应用各处的行为放在可重用的模块中，可以有效减少冗余代码，并让我们的类只关注自身的主要功能。\\n\\n\\n## AOP 概述\\n\\n面向切面编程（aspect-oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，而不是分散在多处代码中。这样使我们的服务模块更加简洁，因为它们只包含了主要关注点的代码，而次要的功能或者说辅助的功能被转移到切面中了。\\n\\n![aop1](__GHOST_URL__/content/images/2021/11/aop1.png)\\n\\n上图表示划分为三个服务模块的应用，每个模块提供相应的服务，而且这些模块都需要类似的辅助功能，例如日志、安全、事务等等。我们并不想在各个模块中写重复的日志、安全、事务的代码，那么就可以使用选用切面这个方案，来解决这个问题。\\n\\n## AOP 术语\\n\\n![aop2](__GHOST_URL__/content/images/2021/11/aop2.png)\\n\\n- `advice` - 通知\\n\\n  - > 切面的具体行为，即要切入执行的代码\\n\\n- `pointcut` - 切点\\n\\n  - > 通知被应用的具体位置\\n\\n- `join point` - 连接点\\n\\n  - > 程序运行时，能够应用通知的所有点\\n\\n- `aspect` - 切面\\n\\n  - > 什么时候在什么地方做什么事情，是切点和通知的结合\\n\\n- `target` - 目标对象\\n\\n  - > 被切入功能的目标对象\\n\\n- `introduction` - 引入\\n\\n  - > 将新的方法或属性引入到现有的类中\\n\\n- `weaving` - 织入\\n\\n  - > 把切面应用到目标对象并创建新的代理对象的过程\\n\\n## 代理模式\\n\\n代理模式是使用代理对象完成用户请求，屏蔽用户对真实对象访问的一种设计模式。现实生活中，代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。\\n\\nAOP 就是使用代理模式实现的，其中的代理类就相当于AOP中的切面。\\n\\n![aop3](__GHOST_URL__/content/images/2021/11/aop3.png)\\n\\n### 静态代理\\n\\n之所以称为静态代理，是因为在程序运行前，代理类就已经存在了。\\n\\n**举个例子**\\n\\n一般艺人都需要助理，来帮他跑腿，演出前谈价格，演出后收钱，只有表演的时候艺人才亲自出马。\\n\\n1. 定义一个艺人接口\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * 艺人接口\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public interface Artist {\\n       /**\\n        * 表演\\n        */\\n       void perform();\\n   }\\n   ```\\n\\n2. 定义艺人实现类刘德华\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * 艺人刘德华\\n    *\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class LiuDehua implements Artist {\\n   \\n       private LiuDehua() {\\n       }\\n   \\n       public static LiuDehua getInstance() {\\n           return new LiuDehua();\\n       }\\n   \\n       public void perform() {\\n           System.out.println(\\\"刘德华出场演唱笨小孩...\\\");\\n       }\\n   }\\n   ```\\n\\n3. 编写代理类\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * 艺人助理（代理类）\\n    *\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class ArtistProxy implements Artist {\\n   \\n       private LiuDehua liuDehua;\\n   \\n       private ArtistProxy() {\\n       }\\n   \\n       public ArtistProxy(LiuDehua liuDehua) {\\n           this.liuDehua = liuDehua;\\n       }\\n   \\n   \\n       public void perform() {\\n           System.out.println(\\\"助理出面谈价格，签合同...\\\");\\n           liuDehua.perform();\\n           System.out.println(\\\"助理出面收钱...\\\");\\n       }\\n   }\\n   ```\\n\\n4. 运行`main`方法，将艺人实例传入代理类的构造方法，然后调用代理类的`perform()`\\n\\n   ```java\\n   package org.nocoder.proxy.staticproxy;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class StaticProxyDemo {\\n   \\n       public static void main(String[] args) {\\n           LiuDehua liuDehua = LiuDehua.getInstance();\\n           ArtistProxy proxy = new ArtistProxy(liuDehua);\\n           proxy.perform();\\n       }\\n   }\\n   ```\\n\\n5. 运行结果\\n\\n   ```java\\n   助理出面谈价格，签合同...\\n   刘德华出场演唱笨小孩...\\n   助理出面收钱...\\n   \\n   Process finished with exit code 0\\n   ```\\n\\n**静态代理的缺点**\\n\\n假设主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；\\n\\n### 动态代理\\n\\n动态代理是在程序运行时，利用Java反射机制动态的生成代理类的代理模式。\\n\\n#### Jdk动态代理\\n\\n- JDK的动态代理依靠接口实现\\n- 如果类并没有实现接口，则不能使用Jdk的动态代理\\n\\n\\n\\n1. 定义图书服务接口\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   /**\\n    * 图书服务接口\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public interface BookService {\\n       /**\\n        * 新增图书接口\\n        */\\n       void addBook();\\n   }\\n   ```\\n\\n   \\n\\n2. 编写图书服务实现类\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   /**\\n    * 图书服务实现类\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookServiceImpl implements BookService {\\n       @Override\\n       public void addBook() {\\n           System.out.println(\\\"新增图书\\\");\\n       }\\n   }\\n   ```\\n\\n3. 编写InvocationHandler实现类\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   import java.lang.reflect.InvocationHandler;\\n   import java.lang.reflect.Method;\\n   \\n   /**\\n    * JDK 动态代理\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookServiceInvocationHandler implements InvocationHandler {\\n   \\n       private Object target;\\n   \\n   \\n       public BookServiceInvocationHandler(Object target){\\n           this.target = target;\\n       }\\n   \\n       @Override\\n       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\\n           System.out.println(\\\"事务开始\\\");\\n           Object result = method.invoke(target, args);\\n           System.out.println(\\\"事务结束\\\");\\n           return result;\\n       }\\n   }\\t\\n   ```\\n\\n4. 运行测试程序\\n\\n   ```java\\n   package org.nocoder.proxy.jdkproxy;\\n   \\n   import java.lang.reflect.Proxy;\\n   \\n   /**\\n    * JDK动态代理演示\\n    *\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class JdkProxyDemo {\\n       public static void main(String[] args) {\\n           BookServiceInvocationHandler invocationHandler = new BookServiceInvocationHandler(new BookServiceImpl());\\n   \\n           // JDK 动态代理只支持接口\\n           BookService bookServiceProxy = (BookService) Proxy.newProxyInstance(\\n                   BookServiceImpl.class.getClassLoader(),\\n                   BookServiceImpl.class.getInterfaces(),\\n                   invocationHandler);\\n   \\n           bookServiceProxy.addBook();\\n       }\\n   }\\n   ```\\n\\n5. 运行结果\\n\\n   ```java\\n   事务开始\\n   新增图书\\n   事务结束\\n   \\n   Process finished with exit code 0\\n   ```\\n\\n   \\n\\n#### CGLIB动态代理\\n\\nJDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这时就要使用cglib动态代理了。使用cglib需要依赖`cglib`的jar，使用maven为例\\n\\n```xml\\n<dependency>\\n  <groupId>cglib</groupId>\\n  <artifactId>cglib-nodep</artifactId>\\n  <version>3.2.4</version>\\n</dependency>\\n```\\n\\n1. 定义图书服务类\\n\\n   ```java\\n   package org.nocoder.proxy.cglibproxy;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookService {\\n       public void addBook() {\\n           System.out.println(\\\"新增图书\\\");\\n       }\\n   }\\n   ```\\n\\n   \\n\\n2. 编写MethodInterceptor实现类\\n\\n   ```java\\n   package org.nocoder.proxy.cglibproxy;\\n   \\n   import net.sf.cglib.proxy.MethodInterceptor;\\n   import net.sf.cglib.proxy.MethodProxy;\\n   import java.lang.reflect.Method;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class BookServiceMethodInterceptor implements MethodInterceptor {\\n   \\n       @Override\\n       public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\\n           System.out.println(\\\"事务开始\\\");\\n           methodProxy.invokeSuper(o, objects);\\n           System.out.println(\\\"事务结束\\\");\\n           return null;\\n       }\\n   }\\n   ```\\n\\n   \\n\\n3. 运行测试程序\\n\\n   ```java\\n   package org.nocoder.proxy.cglibproxy;\\n   \\n   import net.sf.cglib.proxy.Enhancer;\\n   \\n   /**\\n    * @author jason\\n    * @date 2019/2/14.\\n    */\\n   public class CglibProxyDemo {\\n       public static void main(String[] args) {\\n           BookServiceMethodInterceptor cglibInterceptor = new BookServiceMethodInterceptor();\\n           //cglib 强化剂\\n           Enhancer enhancer = new Enhancer();\\n           enhancer.setSuperclass(BookService.class);\\n           // 创建代理对象\\n           enhancer.setCallback(cglibInterceptor);\\n           BookService bookServiceProxy = (BookService)enhancer.create();\\n           bookServiceProxy.addBook();\\n       }\\n   }\\n   ```\\n\\n   \\n\\n4. 运行结果\\n\\n   ```shell\\n   事务开始\\n   新增图书\\n   事务结束\\n   \\n   Process finished with exit code 0\\n   ```\\n\\n## Spring AOP\\n\\nSpring 提供了4中 aop 的支持，基于代理的经典SpringAOP，纯POJO切面，@Aspect注解驱动的切面，注入式AspectJ切面。前三种都是SpringAOP实现的变体，SpringAOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。第四种实际是使用AspectJ的解决方案。提供了SpringAOP所不能支持的许多类型的切点。我们可以借助Spring的依赖注入把bean装配进AspectJ切面中。Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP。\\n\\n#### 使用`@Aspect`创建切面类\\n\\nAudience类使用`@Aspect`注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。\\n\\n![aop4](__GHOST_URL__/content/images/2021/11/aop4.png)\\n\\n![aop5](__GHOST_URL__/content/images/2021/11/aop5.png)\\n\\n#### Advice的5种注解\\n\\n| **注解**        | **通知**                               |\\n| --------------- | :------------------------------------- |\\n| @After          | 通知方法会在目标方法返回或抛异常后调用 |\\n| @AfterReturning | 通知方法会在目标方法返回后调用         |\\n| @AfterThrowing  | 通知方法会在目标方法抛异常后调用       |\\n| @Around         | 通知方法会将目标方法封装起来           |\\n| @Before         | 通知方法会在目标方法调用之前执行       |\\n\\n#### 使用`@Pointcut`声明切点表达式\\n\\n@Pointcut 声明使用频繁的切点表达式后，在通知注解中引用即可\\n\\n![aop6](__GHOST_URL__/content/images/2021/11/aop6.png)\\n\\n## 总结\\n\\n- 面向切面编程是面向对象编程的一个强大的补充\\n- 通过切面可以把分散在应用各处的行为放入可重用的模块中\\n- 通过注解显示的声明在什么地方应用该行为\\n- 有效减少冗余代码，让我们的类关注自身的主要功能\\n- 动态代理模式和静态代理模式\\n- 通过使用@Aspect注解和简单的配置，可以很简单的在Spring中装配advice和pointcut\\n\\n## 参考文献\\n\\n- Spring 实战（第4版）\\n\\n  ![book1](__GHOST_URL__/content/images/2021/11/book1.png)\\n\\n- Head First 设计模式\\n\\n  ![book2](__GHOST_URL__/content/images/2021/11/book2.png)\\n\\n- https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E4%BE%A7%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\\n\\n- https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9\\n\\n- https://juejin.im/post/5b06bf2df265da0de2574ee1\\n\\n- http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821\\n\\n- http://blog.didispace.com/springbootaoplog/\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>AOP 被认为是对 OOP 的一个强大的补充，有了 AOP，我们可以把之前分散在应用各处的行为放在可重用的模块中，可以有效减少冗余代码，并让我们的类只关注自身的主要功能。</p>\n</blockquote>\n<h2 id=\"aop-%E6%A6%82%E8%BF%B0\">AOP 概述</h2>\n<p>面向切面编程（aspect-oriented programming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，而不是分散在多处代码中。这样使我们的服务模块更加简洁，因为它们只包含了主要关注点的代码，而次要的功能或者说辅助的功能被转移到切面中了。</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop1.png\" alt=\"aop1\" loading=\"lazy\"></p>\n<p>上图表示划分为三个服务模块的应用，每个模块提供相应的服务，而且这些模块都需要类似的辅助功能，例如日志、安全、事务等等。我们并不想在各个模块中写重复的日志、安全、事务的代码，那么就可以使用选用切面这个方案，来解决这个问题。</p>\n<h2 id=\"aop-%E6%9C%AF%E8%AF%AD\">AOP 术语</h2>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop2.png\" alt=\"aop2\" loading=\"lazy\"></p>\n<ul>\n<li>\n<p><code>advice</code> - 通知</p>\n<ul>\n<li>\n<blockquote>\n<p>切面的具体行为，即要切入执行的代码</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>pointcut</code> - 切点</p>\n<ul>\n<li>\n<blockquote>\n<p>通知被应用的具体位置</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>join point</code> - 连接点</p>\n<ul>\n<li>\n<blockquote>\n<p>程序运行时，能够应用通知的所有点</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>aspect</code> - 切面</p>\n<ul>\n<li>\n<blockquote>\n<p>什么时候在什么地方做什么事情，是切点和通知的结合</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>target</code> - 目标对象</p>\n<ul>\n<li>\n<blockquote>\n<p>被切入功能的目标对象</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>introduction</code> - 引入</p>\n<ul>\n<li>\n<blockquote>\n<p>将新的方法或属性引入到现有的类中</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p><code>weaving</code> - 织入</p>\n<ul>\n<li>\n<blockquote>\n<p>把切面应用到目标对象并创建新的代理对象的过程</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\">代理模式</h2>\n<p>代理模式是使用代理对象完成用户请求，屏蔽用户对真实对象访问的一种设计模式。现实生活中，代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。</p>\n<p>AOP 就是使用代理模式实现的，其中的代理类就相当于AOP中的切面。</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop3.png\" alt=\"aop3\" loading=\"lazy\"></p>\n<h3 id=\"%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\">静态代理</h3>\n<p>之所以称为静态代理，是因为在程序运行前，代理类就已经存在了。</p>\n<p><strong>举个例子</strong></p>\n<p>一般艺人都需要助理，来帮他跑腿，演出前谈价格，演出后收钱，只有表演的时候艺人才亲自出马。</p>\n<ol>\n<li>\n<p>定义一个艺人接口</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * 艺人接口\n * @author jason\n * @date 2019/2/14.\n */\npublic interface Artist {\n    /**\n     * 表演\n     */\n    void perform();\n}\n</code></pre>\n</li>\n<li>\n<p>定义艺人实现类刘德华</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * 艺人刘德华\n *\n * @author jason\n * @date 2019/2/14.\n */\npublic class LiuDehua implements Artist {\n\n    private LiuDehua() {\n    }\n\n    public static LiuDehua getInstance() {\n        return new LiuDehua();\n    }\n\n    public void perform() {\n        System.out.println(&quot;刘德华出场演唱笨小孩...&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>编写代理类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * 艺人助理（代理类）\n *\n * @author jason\n * @date 2019/2/14.\n */\npublic class ArtistProxy implements Artist {\n\n    private LiuDehua liuDehua;\n\n    private ArtistProxy() {\n    }\n\n    public ArtistProxy(LiuDehua liuDehua) {\n        this.liuDehua = liuDehua;\n    }\n\n\n    public void perform() {\n        System.out.println(&quot;助理出面谈价格，签合同...&quot;);\n        liuDehua.perform();\n        System.out.println(&quot;助理出面收钱...&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行<code>main</code>方法，将艺人实例传入代理类的构造方法，然后调用代理类的<code>perform()</code></p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.staticproxy;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class StaticProxyDemo {\n\n    public static void main(String[] args) {\n        LiuDehua liuDehua = LiuDehua.getInstance();\n        ArtistProxy proxy = new ArtistProxy(liuDehua);\n        proxy.perform();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行结果</p>\n<pre><code class=\"language-java\">助理出面谈价格，签合同...\n刘德华出场演唱笨小孩...\n助理出面收钱...\n\nProcess finished with exit code 0\n</code></pre>\n</li>\n</ol>\n<p><strong>静态代理的缺点</strong></p>\n<p>假设主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；</p>\n<h3 id=\"%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">动态代理</h3>\n<p>动态代理是在程序运行时，利用Java反射机制动态的生成代理类的代理模式。</p>\n<h4 id=\"jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">Jdk动态代理</h4>\n<ul>\n<li>JDK的动态代理依靠接口实现</li>\n<li>如果类并没有实现接口，则不能使用Jdk的动态代理</li>\n</ul>\n<ol>\n<li>\n<p>定义图书服务接口</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\n/**\n * 图书服务接口\n * @author jason\n * @date 2019/2/14.\n */\npublic interface BookService {\n    /**\n     * 新增图书接口\n     */\n    void addBook();\n}\n</code></pre>\n</li>\n<li>\n<p>编写图书服务实现类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\n/**\n * 图书服务实现类\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookServiceImpl implements BookService {\n    @Override\n    public void addBook() {\n        System.out.println(&quot;新增图书&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>编写InvocationHandler实现类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\n/**\n * JDK 动态代理\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookServiceInvocationHandler implements InvocationHandler {\n\n    private Object target;\n\n\n    public BookServiceInvocationHandler(Object target){\n        this.target = target;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(&quot;事务开始&quot;);\n        Object result = method.invoke(target, args);\n        System.out.println(&quot;事务结束&quot;);\n        return result;\n    }\n}\t\n</code></pre>\n</li>\n<li>\n<p>运行测试程序</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.jdkproxy;\n\nimport java.lang.reflect.Proxy;\n\n/**\n * JDK动态代理演示\n *\n * @author jason\n * @date 2019/2/14.\n */\npublic class JdkProxyDemo {\n    public static void main(String[] args) {\n        BookServiceInvocationHandler invocationHandler = new BookServiceInvocationHandler(new BookServiceImpl());\n\n        // JDK 动态代理只支持接口\n        BookService bookServiceProxy = (BookService) Proxy.newProxyInstance(\n                BookServiceImpl.class.getClassLoader(),\n                BookServiceImpl.class.getInterfaces(),\n                invocationHandler);\n\n        bookServiceProxy.addBook();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行结果</p>\n<pre><code class=\"language-java\">事务开始\n新增图书\n事务结束\n\nProcess finished with exit code 0\n</code></pre>\n</li>\n</ol>\n<h4 id=\"cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\">CGLIB动态代理</h4>\n<p>JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这时就要使用cglib动态代理了。使用cglib需要依赖<code>cglib</code>的jar，使用maven为例</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n  &lt;groupId&gt;cglib&lt;/groupId&gt;\n  &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;\n  &lt;version&gt;3.2.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol>\n<li>\n<p>定义图书服务类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.cglibproxy;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookService {\n    public void addBook() {\n        System.out.println(&quot;新增图书&quot;);\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>编写MethodInterceptor实现类</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.cglibproxy;\n\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport java.lang.reflect.Method;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class BookServiceMethodInterceptor implements MethodInterceptor {\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(&quot;事务开始&quot;);\n        methodProxy.invokeSuper(o, objects);\n        System.out.println(&quot;事务结束&quot;);\n        return null;\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行测试程序</p>\n<pre><code class=\"language-java\">package org.nocoder.proxy.cglibproxy;\n\nimport net.sf.cglib.proxy.Enhancer;\n\n/**\n * @author jason\n * @date 2019/2/14.\n */\npublic class CglibProxyDemo {\n    public static void main(String[] args) {\n        BookServiceMethodInterceptor cglibInterceptor = new BookServiceMethodInterceptor();\n        //cglib 强化剂\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(BookService.class);\n        // 创建代理对象\n        enhancer.setCallback(cglibInterceptor);\n        BookService bookServiceProxy = (BookService)enhancer.create();\n        bookServiceProxy.addBook();\n    }\n}\n</code></pre>\n</li>\n<li>\n<p>运行结果</p>\n<pre><code class=\"language-shell\">事务开始\n新增图书\n事务结束\n\nProcess finished with exit code 0\n</code></pre>\n</li>\n</ol>\n<h2 id=\"spring-aop\">Spring AOP</h2>\n<p>Spring 提供了4中 aop 的支持，基于代理的经典SpringAOP，纯POJO切面，@Aspect注解驱动的切面，注入式AspectJ切面。前三种都是SpringAOP实现的变体，SpringAOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。第四种实际是使用AspectJ的解决方案。提供了SpringAOP所不能支持的许多类型的切点。我们可以借助Spring的依赖注入把bean装配进AspectJ切面中。Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP。</p>\n<h4 id=\"%E4%BD%BF%E7%94%A8aspect%E5%88%9B%E5%BB%BA%E5%88%87%E9%9D%A2%E7%B1%BB\">使用<code>@Aspect</code>创建切面类</h4>\n<p>Audience类使用<code>@Aspect</code>注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop4.png\" alt=\"aop4\" loading=\"lazy\"></p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop5.png\" alt=\"aop5\" loading=\"lazy\"></p>\n<h4 id=\"advice%E7%9A%845%E7%A7%8D%E6%B3%A8%E8%A7%A3\">Advice的5种注解</h4>\n<table>\n<thead>\n<tr>\n<th><strong>注解</strong></th>\n<th style=\"text-align:left\"><strong>通知</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@After</td>\n<td style=\"text-align:left\">通知方法会在目标方法返回或抛异常后调用</td>\n</tr>\n<tr>\n<td>@AfterReturning</td>\n<td style=\"text-align:left\">通知方法会在目标方法返回后调用</td>\n</tr>\n<tr>\n<td>@AfterThrowing</td>\n<td style=\"text-align:left\">通知方法会在目标方法抛异常后调用</td>\n</tr>\n<tr>\n<td>@Around</td>\n<td style=\"text-align:left\">通知方法会将目标方法封装起来</td>\n</tr>\n<tr>\n<td>@Before</td>\n<td style=\"text-align:left\">通知方法会在目标方法调用之前执行</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"%E4%BD%BF%E7%94%A8pointcut%E5%A3%B0%E6%98%8E%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F\">使用<code>@Pointcut</code>声明切点表达式</h4>\n<p>@Pointcut 声明使用频繁的切点表达式后，在通知注解中引用即可</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/aop6.png\" alt=\"aop6\" loading=\"lazy\"></p>\n<h2 id=\"%E6%80%BB%E7%BB%93\">总结</h2>\n<ul>\n<li>面向切面编程是面向对象编程的一个强大的补充</li>\n<li>通过切面可以把分散在应用各处的行为放入可重用的模块中</li>\n<li>通过注解显示的声明在什么地方应用该行为</li>\n<li>有效减少冗余代码，让我们的类关注自身的主要功能</li>\n<li>动态代理模式和静态代理模式</li>\n<li>通过使用@Aspect注解和简单的配置，可以很简单的在Spring中装配advice和pointcut</li>\n</ul>\n<h2 id=\"%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</h2>\n<ul>\n<li>\n<p>Spring 实战（第4版）</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/book1.png\" alt=\"book1\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>Head First 设计模式</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/book2.png\" alt=\"book2\" loading=\"lazy\"></p>\n</li>\n<li>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E4%BE%A7%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\">https://zh.wikipedia.org/wiki/面向侧面的程序设计</a></p>\n</li>\n<li>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9\">https://zh.wikipedia.org/wiki/横切关注点</a></p>\n</li>\n<li>\n<p><a href=\"https://juejin.im/post/5b06bf2df265da0de2574ee1\">https://juejin.im/post/5b06bf2df265da0de2574ee1</a></p>\n</li>\n<li>\n<p><a href=\"http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821\">http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821</a></p>\n</li>\n<li>\n<p><a href=\"http://blog.didispace.com/springbootaoplog/\">http://blog.didispace.com/springbootaoplog/</a></p>\n</li>\n</ul>\n<!--kg-card-end: markdown-->","comment_id":"61607f310af28a00012bf105","plaintext":"> AOP 被认为是对 OOP 的一个强大的补充，有了\nAOP，我们可以把之前分散在应用各处的行为放在可重用的模块中，可以有效减少冗余代码，并让我们的类只关注自身的主要功能。\n\n\nAOP 概述\n面向切面编程（aspect-oriented\nprogramming），是一种将横切关注点与业务逻辑分离的编程方式。每个横切关注点都集中在一个地方，而不是分散在多处代码中。这样使我们的服务模块更加简洁，因为它们只包含了主要关注点的代码，而次要的功能或者说辅助的功能被转移到切面中了。\n\n\n\n上图表示划分为三个服务模块的应用，每个模块提供相应的服务，而且这些模块都需要类似的辅助功能，例如日志、安全、事务等等。我们并不想在各个模块中写重复的日志、安全、事务的代码，那么就可以使用选用切面这个方案，来解决这个问题。\n\nAOP 术语\n\n\n * advice - 通知\n   \n    * > 切面的具体行为，即要切入执行的代码\n      \n      \n      \n   \n   \n * pointcut - 切点\n   \n    * > 通知被应用的具体位置\n      \n      \n      \n   \n   \n * join point - 连接点\n   \n    * > 程序运行时，能够应用通知的所有点\n      \n      \n      \n   \n   \n * aspect - 切面\n   \n    * > 什么时候在什么地方做什么事情，是切点和通知的结合\n      \n      \n      \n   \n   \n * target - 目标对象\n   \n    * > 被切入功能的目标对象\n      \n      \n      \n   \n   \n * introduction - 引入\n   \n    * > 将新的方法或属性引入到现有的类中\n      \n      \n      \n   \n   \n * weaving - 织入\n   \n    * > 把切面应用到目标对象并创建新的代理对象的过程\n      \n      \n      \n   \n   \n\n代理模式\n代理模式是使用代理对象完成用户请求，屏蔽用户对真实对象访问的一种设计模式。现实生活中，代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。\n\nAOP 就是使用代理模式实现的，其中的代理类就相当于AOP中的切面。\n\n\n\n静态代理\n之所以称为静态代理，是因为在程序运行前，代理类就已经存在了。\n\n举个例子\n\n一般艺人都需要助理，来帮他跑腿，演出前谈价格，演出后收钱，只有表演的时候艺人才亲自出马。\n\n 1. 定义一个艺人接口\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * 艺人接口\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public interface Artist {\n        /**\n         * 表演\n         */\n        void perform();\n    }\n    \n    \n    \n 2. 定义艺人实现类刘德华\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * 艺人刘德华\n     *\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class LiuDehua implements Artist {\n    \n        private LiuDehua() {\n        }\n    \n        public static LiuDehua getInstance() {\n            return new LiuDehua();\n        }\n    \n        public void perform() {\n            System.out.println(\"刘德华出场演唱笨小孩...\");\n        }\n    }\n    \n    \n    \n 3. 编写代理类\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * 艺人助理（代理类）\n     *\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class ArtistProxy implements Artist {\n    \n        private LiuDehua liuDehua;\n    \n        private ArtistProxy() {\n        }\n    \n        public ArtistProxy(LiuDehua liuDehua) {\n            this.liuDehua = liuDehua;\n        }\n    \n    \n        public void perform() {\n            System.out.println(\"助理出面谈价格，签合同...\");\n            liuDehua.perform();\n            System.out.println(\"助理出面收钱...\");\n        }\n    }\n    \n    \n    \n 4. 运行main方法，将艺人实例传入代理类的构造方法，然后调用代理类的perform()\n    \n    package org.nocoder.proxy.staticproxy;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class StaticProxyDemo {\n    \n        public static void main(String[] args) {\n            LiuDehua liuDehua = LiuDehua.getInstance();\n            ArtistProxy proxy = new ArtistProxy(liuDehua);\n            proxy.perform();\n        }\n    }\n    \n    \n    \n 5. 运行结果\n    \n    助理出面谈价格，签合同...\n    刘德华出场演唱笨小孩...\n    助理出面收钱...\n    \n    Process finished with exit code 0\n    \n    \n    \n\n静态代理的缺点\n\n假设主题接口中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则真实主题和代理类都要修改，不利于系统维护；\n\n动态代理\n动态代理是在程序运行时，利用Java反射机制动态的生成代理类的代理模式。\n\nJdk动态代理\n * JDK的动态代理依靠接口实现\n * 如果类并没有实现接口，则不能使用Jdk的动态代理\n\n 1. 定义图书服务接口\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    /**\n     * 图书服务接口\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public interface BookService {\n        /**\n         * 新增图书接口\n         */\n        void addBook();\n    }\n    \n    \n    \n 2. 编写图书服务实现类\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    /**\n     * 图书服务实现类\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookServiceImpl implements BookService {\n        @Override\n        public void addBook() {\n            System.out.println(\"新增图书\");\n        }\n    }\n    \n    \n    \n 3. 编写InvocationHandler实现类\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    import java.lang.reflect.InvocationHandler;\n    import java.lang.reflect.Method;\n    \n    /**\n     * JDK 动态代理\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookServiceInvocationHandler implements InvocationHandler {\n    \n        private Object target;\n    \n    \n        public BookServiceInvocationHandler(Object target){\n            this.target = target;\n        }\n    \n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"事务开始\");\n            Object result = method.invoke(target, args);\n            System.out.println(\"事务结束\");\n            return result;\n        }\n    }\t\n    \n    \n    \n 4. 运行测试程序\n    \n    package org.nocoder.proxy.jdkproxy;\n    \n    import java.lang.reflect.Proxy;\n    \n    /**\n     * JDK动态代理演示\n     *\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class JdkProxyDemo {\n        public static void main(String[] args) {\n            BookServiceInvocationHandler invocationHandler = new BookServiceInvocationHandler(new BookServiceImpl());\n    \n            // JDK 动态代理只支持接口\n            BookService bookServiceProxy = (BookService) Proxy.newProxyInstance(\n                    BookServiceImpl.class.getClassLoader(),\n                    BookServiceImpl.class.getInterfaces(),\n                    invocationHandler);\n    \n            bookServiceProxy.addBook();\n        }\n    }\n    \n    \n    \n 5. 运行结果\n    \n    事务开始\n    新增图书\n    事务结束\n    \n    Process finished with exit code 0\n    \n    \n    \n\nCGLIB动态代理\nJDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这时就要使用cglib动态代理了。使用cglib需要依赖cglib\n的jar，使用maven为例\n\n<dependency>\n  <groupId>cglib</groupId>\n  <artifactId>cglib-nodep</artifactId>\n  <version>3.2.4</version>\n</dependency>\n\n\n 1. 定义图书服务类\n    \n    package org.nocoder.proxy.cglibproxy;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookService {\n        public void addBook() {\n            System.out.println(\"新增图书\");\n        }\n    }\n    \n    \n    \n 2. 编写MethodInterceptor实现类\n    \n    package org.nocoder.proxy.cglibproxy;\n    \n    import net.sf.cglib.proxy.MethodInterceptor;\n    import net.sf.cglib.proxy.MethodProxy;\n    import java.lang.reflect.Method;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class BookServiceMethodInterceptor implements MethodInterceptor {\n    \n        @Override\n        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n            System.out.println(\"事务开始\");\n            methodProxy.invokeSuper(o, objects);\n            System.out.println(\"事务结束\");\n            return null;\n        }\n    }\n    \n    \n    \n 3. 运行测试程序\n    \n    package org.nocoder.proxy.cglibproxy;\n    \n    import net.sf.cglib.proxy.Enhancer;\n    \n    /**\n     * @author jason\n     * @date 2019/2/14.\n     */\n    public class CglibProxyDemo {\n        public static void main(String[] args) {\n            BookServiceMethodInterceptor cglibInterceptor = new BookServiceMethodInterceptor();\n            //cglib 强化剂\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(BookService.class);\n            // 创建代理对象\n            enhancer.setCallback(cglibInterceptor);\n            BookService bookServiceProxy = (BookService)enhancer.create();\n            bookServiceProxy.addBook();\n        }\n    }\n    \n    \n    \n 4. 运行结果\n    \n    事务开始\n    新增图书\n    事务结束\n    \n    Process finished with exit code 0\n    \n    \n    \n\nSpring AOP\nSpring 提供了4中 aop\n的支持，基于代理的经典SpringAOP，纯POJO切面，@Aspect注解驱动的切面，注入式AspectJ切面。前三种都是SpringAOP实现的变体，SpringAOP构建在动态代理基础之上，因此，Spring对AOP的支持局限于方法拦截。第四种实际是使用AspectJ的解决方案。提供了SpringAOP所不能支持的许多类型的切点。我们可以借助Spring的依赖注入把bean装配进AspectJ切面中。Spring借鉴了AspectJ的切面，以提供注解驱动的AOP。本质上，它依然是Spring基于代理的AOP。\n\n使用@Aspect创建切面类\nAudience类使用@Aspect\n注解进行了标注。该注解表明Audience不仅仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为。Audience有四个方法，定义了一个观众在观看演出时可能会做的事情。在演出之前，观众要就坐（takeSeats()）并将手机调至静音状态（silenceCellPhones()）。如果演出很精彩的话，观众应该会鼓掌喝彩（applause()）。不过，如果演出没有达到观众预期的话，观众会要求退款（demandRefund()）。\n\n\n\n\n\nAdvice的5种注解\n注解通知@After通知方法会在目标方法返回或抛异常后调用@AfterReturning通知方法会在目标方法返回后调用@AfterThrowing\n通知方法会在目标方法抛异常后调用@Around通知方法会将目标方法封装起来@Before通知方法会在目标方法调用之前执行使用@Pointcut声明切点表达式\n@Pointcut 声明使用频繁的切点表达式后，在通知注解中引用即可\n\n\n\n总结\n * 面向切面编程是面向对象编程的一个强大的补充\n * 通过切面可以把分散在应用各处的行为放入可重用的模块中\n * 通过注解显示的声明在什么地方应用该行为\n * 有效减少冗余代码，让我们的类关注自身的主要功能\n * 动态代理模式和静态代理模式\n * 通过使用@Aspect注解和简单的配置，可以很简单的在Spring中装配advice和pointcut\n\n参考文献\n * Spring 实战（第4版）\n   \n   \n   \n   \n * Head First 设计模式\n   \n   \n   \n   \n * https://zh.wikipedia.org/wiki/面向侧面的程序设计\n   [https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E4%BE%A7%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1]\n   \n   \n * https://zh.wikipedia.org/wiki/横切关注点\n   [https://zh.wikipedia.org/wiki/%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9]\n   \n   \n * https://juejin.im/post/5b06bf2df265da0de2574ee1\n   \n   \n * http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html#3460821\n   \n   \n * http://blog.didispace.com/springbootaoplog/","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.2f4e0193d1fbcc4a0d5c4c4981af66fe.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-08 17:26:09","created_by":"1","updated_at":"2021-11-13 06:53:35","updated_by":"1","published_at":"2019-02-13 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6164fc580af28a00012bf12b","uuid":"e1ce459c-9198-4322-8cc7-b2c7fdd489a8","title":"装饰器模式之真假美猴王","slug":"zhuang-shi-qi-mo-shi-zhi-zhen-jia-mei-hou-wang","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 本文以西游记中的“真假美猴王”为例，一起温习一下装饰器模式的使用场景及具体实现过程。\\n\\n真假美猴王的故事就不讲了，我们的目的是要把一个猴子类包装成孙悟空和六耳猕猴，但是不能改变猴子类本身的结构。\\n\\n简单描述一下装饰过程：\\n\\n- 首先定义一个猴子接口类，猴子具有`introduce()`方法，用于让猴子嗞哩哇啦的说话介绍自己；\\n- 定义一个普通的猴子类，实现猴子接口类，重载`introduce()`方法，介绍一下自己，例如：“我是个会说话的猴子！”；\\n- 定义一个抽象类，实现猴子接口，作为抽象装饰器类，因为要装饰猴子，所以需要有一个接收猴子类的构造方法；\\n- 定义具体的装饰器类，继承抽象装饰器类，实现具体的装饰方法，这里我们需要定义两个具体的装饰器类，一个是孙悟空装饰器，一个是六耳猕猴装饰器，在各自的类里增加展示自己技能的描述方法，例如“我会七十二变”等；\\n\\n过程大概就上面这么几步，接着咱们就开始coding！\\n\\n1、首先是定义一个猴子接口，泛代表各种猴类。`IMonkey.java`\\n\\n```java\\npublic interface IMonkey{\\n    /**\\n     * 猴子自我介绍\\n    /*\\n    void introduce();\\n}\\n```\\n\\n2、定义猴子实现类，表示一个普通的猴子。`Monkey.java`\\n\\n```java\\npublic class Monkey implements IMonkey{\\n    @Override\\n    public void introduce(){\\n        System.out.print(\\\"我是一个会说话的猴子！\\\");\\n    }\\n}\\n```\\n\\n3、定义抽象装饰器类。`AbstractMonkeyDecorator.java`\\n\\n```java\\npublic abstract class AbstractMonkeyDecorator implements IMonkey{\\n    protected IMonkey monkey;\\n    public AbstractMonkeyDecorator(IMonkey monkey){\\n        this.monkey = monkey;\\n    }\\n\\n    @Override\\n    public void introduce(){\\n        monkey.introduce();\\n    }\\n}\\n```\\n\\n4、定义具体的装饰类，用于将普通的猴子包装成孙悟空或六耳猕猴。\\n\\n- 先来一个孙悟空的装饰类`SunWuKongDecorator.java`\\n\\n```java\\npublic class SunWuKongDecorator extends AbstractMonkeyDecorator{\\n    public SunWuKongDecorator(IMonkey monkey){\\n        super(monkey);\\n    }\\n\\n    @Override\\n    public void introduce(){\\n        // 调用monkey自身的方法\\n        monkey.introduce();\\n        // 调用装饰方法\\n        decorate(monkey);\\n    }\\n\\n    private void decorate(IMonkey monkey){\\n        System.out.print(\\\"我是美猴王，我会七十二变！\\\");\\n        System.out.print(\\\"我师傅是大唐高僧！\\\");\\n    }\\n}\\n```\\n\\n- 再来一个六耳猕猴的装饰类`SixEarsMonkeyDecorator.java`\\n\\n```java\\npublic class SixEarsMonkeyDecorator extends AbstractMonkeyDecorator{\\n    public SixEarsMonkeyDecorator(IMonkey monkey){\\n        super(monkey);\\n    }\\n\\n    @Override\\n    public void introduce(){\\n        // 调用monkey自身的方法\\n        monkey.introduce();\\n        // 调用装饰方法\\n        decorate(monkey);\\n    }\\n\\n    // 具体的装饰方法实现逻辑\\n    private void decorate(IMonkey monkey){\\n        System.out.print(\\\"我才是美猴王，我会七十二变！\\\");\\n        System.out.print(\\\"大唐高僧是我师傅！\\\");\\n    }\\n}\\n```\\n\\n5、测试程序\\n\\n```java\\npublic static void main(String[] args){\\n    // 首先看看一个普通的猴子的自我介绍\\n    System.out.print(\\\"使用装饰器前的猴子：\\\");\\n    Monkey monkey = new Monkey();\\n    monkey.introduce();\\n\\n    System.out.println();\\n\\n    // 使用孙悟空装饰器装饰猴子\\n    System.out.print(\\\"使用孙悟空装饰器装饰后的猴子：\\\");\\n    SunWuKongDecorator swkDecorator = new SunWuKongDecorator(new Monkey());\\n    swkDecorator.introduce();\\n\\n    System.out.println();\\n\\n    // 使用六耳猕猴装饰器装饰猴子\\n    System.out.print(\\\"使用六耳猕猴装饰器装饰后的猴子：\\\");\\n    SixEarsMonkeyDecorator semDecorator = new SixEarsMonkeyDecorator(new Monkey());\\n    semDecorator.introduce();\\n}\\n\\n```\\n\\n6、输出结果\\n\\n```java\\n使用装饰器前的猴子：我是一个会说话的猴子！\\n使用孙悟空装饰器装饰后的猴子：我是一个会说话的猴子！我是美猴王，我会七十二变！我师傅是大唐高僧！\\n使用六耳猕猴装饰器装饰后的猴子：我是一个会说话的猴子！我才是美猴王，我会七十二变！大唐高僧是我师傅！\\n```\\n\\n总结：上面的例子中，我们并没有对Monkey类本身进行改造，而是采用装饰器包装的方式为Monkey增加了新的功能，这种方式可以动态的为实体类增加功能，比继承更灵活，且装饰类和被装饰类互不影响，可以各自扩展。\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>本文以西游记中的“真假美猴王”为例，一起温习一下装饰器模式的使用场景及具体实现过程。</p>\n</blockquote>\n<p>真假美猴王的故事就不讲了，我们的目的是要把一个猴子类包装成孙悟空和六耳猕猴，但是不能改变猴子类本身的结构。</p>\n<p>简单描述一下装饰过程：</p>\n<ul>\n<li>首先定义一个猴子接口类，猴子具有<code>introduce()</code>方法，用于让猴子嗞哩哇啦的说话介绍自己；</li>\n<li>定义一个普通的猴子类，实现猴子接口类，重载<code>introduce()</code>方法，介绍一下自己，例如：“我是个会说话的猴子！”；</li>\n<li>定义一个抽象类，实现猴子接口，作为抽象装饰器类，因为要装饰猴子，所以需要有一个接收猴子类的构造方法；</li>\n<li>定义具体的装饰器类，继承抽象装饰器类，实现具体的装饰方法，这里我们需要定义两个具体的装饰器类，一个是孙悟空装饰器，一个是六耳猕猴装饰器，在各自的类里增加展示自己技能的描述方法，例如“我会七十二变”等；</li>\n</ul>\n<p>过程大概就上面这么几步，接着咱们就开始coding！</p>\n<p>1、首先是定义一个猴子接口，泛代表各种猴类。<code>IMonkey.java</code></p>\n<pre><code class=\"language-java\">public interface IMonkey{\n    /**\n     * 猴子自我介绍\n    /*\n    void introduce();\n}\n</code></pre>\n<p>2、定义猴子实现类，表示一个普通的猴子。<code>Monkey.java</code></p>\n<pre><code class=\"language-java\">public class Monkey implements IMonkey{\n    @Override\n    public void introduce(){\n        System.out.print(&quot;我是一个会说话的猴子！&quot;);\n    }\n}\n</code></pre>\n<p>3、定义抽象装饰器类。<code>AbstractMonkeyDecorator.java</code></p>\n<pre><code class=\"language-java\">public abstract class AbstractMonkeyDecorator implements IMonkey{\n    protected IMonkey monkey;\n    public AbstractMonkeyDecorator(IMonkey monkey){\n        this.monkey = monkey;\n    }\n\n    @Override\n    public void introduce(){\n        monkey.introduce();\n    }\n}\n</code></pre>\n<p>4、定义具体的装饰类，用于将普通的猴子包装成孙悟空或六耳猕猴。</p>\n<ul>\n<li>先来一个孙悟空的装饰类<code>SunWuKongDecorator.java</code></li>\n</ul>\n<pre><code class=\"language-java\">public class SunWuKongDecorator extends AbstractMonkeyDecorator{\n    public SunWuKongDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    private void decorate(IMonkey monkey){\n        System.out.print(&quot;我是美猴王，我会七十二变！&quot;);\n        System.out.print(&quot;我师傅是大唐高僧！&quot;);\n    }\n}\n</code></pre>\n<ul>\n<li>再来一个六耳猕猴的装饰类<code>SixEarsMonkeyDecorator.java</code></li>\n</ul>\n<pre><code class=\"language-java\">public class SixEarsMonkeyDecorator extends AbstractMonkeyDecorator{\n    public SixEarsMonkeyDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    // 具体的装饰方法实现逻辑\n    private void decorate(IMonkey monkey){\n        System.out.print(&quot;我才是美猴王，我会七十二变！&quot;);\n        System.out.print(&quot;大唐高僧是我师傅！&quot;);\n    }\n}\n</code></pre>\n<p>5、测试程序</p>\n<pre><code class=\"language-java\">public static void main(String[] args){\n    // 首先看看一个普通的猴子的自我介绍\n    System.out.print(&quot;使用装饰器前的猴子：&quot;);\n    Monkey monkey = new Monkey();\n    monkey.introduce();\n\n    System.out.println();\n\n    // 使用孙悟空装饰器装饰猴子\n    System.out.print(&quot;使用孙悟空装饰器装饰后的猴子：&quot;);\n    SunWuKongDecorator swkDecorator = new SunWuKongDecorator(new Monkey());\n    swkDecorator.introduce();\n\n    System.out.println();\n\n    // 使用六耳猕猴装饰器装饰猴子\n    System.out.print(&quot;使用六耳猕猴装饰器装饰后的猴子：&quot;);\n    SixEarsMonkeyDecorator semDecorator = new SixEarsMonkeyDecorator(new Monkey());\n    semDecorator.introduce();\n}\n\n</code></pre>\n<p>6、输出结果</p>\n<pre><code class=\"language-java\">使用装饰器前的猴子：我是一个会说话的猴子！\n使用孙悟空装饰器装饰后的猴子：我是一个会说话的猴子！我是美猴王，我会七十二变！我师傅是大唐高僧！\n使用六耳猕猴装饰器装饰后的猴子：我是一个会说话的猴子！我才是美猴王，我会七十二变！大唐高僧是我师傅！\n</code></pre>\n<p>总结：上面的例子中，我们并没有对Monkey类本身进行改造，而是采用装饰器包装的方式为Monkey增加了新的功能，这种方式可以动态的为实体类增加功能，比继承更灵活，且装饰类和被装饰类互不影响，可以各自扩展。</p>\n<!--kg-card-end: markdown-->","comment_id":"6164fc580af28a00012bf12b","plaintext":"> 本文以西游记中的“真假美猴王”为例，一起温习一下装饰器模式的使用场景及具体实现过程。\n\n\n真假美猴王的故事就不讲了，我们的目的是要把一个猴子类包装成孙悟空和六耳猕猴，但是不能改变猴子类本身的结构。\n\n简单描述一下装饰过程：\n\n * 首先定义一个猴子接口类，猴子具有introduce()方法，用于让猴子嗞哩哇啦的说话介绍自己；\n * 定义一个普通的猴子类，实现猴子接口类，重载introduce()方法，介绍一下自己，例如：“我是个会说话的猴子！”；\n * 定义一个抽象类，实现猴子接口，作为抽象装饰器类，因为要装饰猴子，所以需要有一个接收猴子类的构造方法；\n * 定义具体的装饰器类，继承抽象装饰器类，实现具体的装饰方法，这里我们需要定义两个具体的装饰器类，一个是孙悟空装饰器，一个是六耳猕猴装饰器，在各自的类里增加展示自己技能的描述方法，例如“我会七十二变”等；\n\n过程大概就上面这么几步，接着咱们就开始coding！\n\n1、首先是定义一个猴子接口，泛代表各种猴类。IMonkey.java\n\npublic interface IMonkey{\n    /**\n     * 猴子自我介绍\n    /*\n    void introduce();\n}\n\n\n2、定义猴子实现类，表示一个普通的猴子。Monkey.java\n\npublic class Monkey implements IMonkey{\n    @Override\n    public void introduce(){\n        System.out.print(\"我是一个会说话的猴子！\");\n    }\n}\n\n\n3、定义抽象装饰器类。AbstractMonkeyDecorator.java\n\npublic abstract class AbstractMonkeyDecorator implements IMonkey{\n    protected IMonkey monkey;\n    public AbstractMonkeyDecorator(IMonkey monkey){\n        this.monkey = monkey;\n    }\n\n    @Override\n    public void introduce(){\n        monkey.introduce();\n    }\n}\n\n\n4、定义具体的装饰类，用于将普通的猴子包装成孙悟空或六耳猕猴。\n\n * 先来一个孙悟空的装饰类SunWuKongDecorator.java\n\npublic class SunWuKongDecorator extends AbstractMonkeyDecorator{\n    public SunWuKongDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    private void decorate(IMonkey monkey){\n        System.out.print(\"我是美猴王，我会七十二变！\");\n        System.out.print(\"我师傅是大唐高僧！\");\n    }\n}\n\n\n * 再来一个六耳猕猴的装饰类SixEarsMonkeyDecorator.java\n\npublic class SixEarsMonkeyDecorator extends AbstractMonkeyDecorator{\n    public SixEarsMonkeyDecorator(IMonkey monkey){\n        super(monkey);\n    }\n\n    @Override\n    public void introduce(){\n        // 调用monkey自身的方法\n        monkey.introduce();\n        // 调用装饰方法\n        decorate(monkey);\n    }\n\n    // 具体的装饰方法实现逻辑\n    private void decorate(IMonkey monkey){\n        System.out.print(\"我才是美猴王，我会七十二变！\");\n        System.out.print(\"大唐高僧是我师傅！\");\n    }\n}\n\n\n5、测试程序\n\npublic static void main(String[] args){\n    // 首先看看一个普通的猴子的自我介绍\n    System.out.print(\"使用装饰器前的猴子：\");\n    Monkey monkey = new Monkey();\n    monkey.introduce();\n\n    System.out.println();\n\n    // 使用孙悟空装饰器装饰猴子\n    System.out.print(\"使用孙悟空装饰器装饰后的猴子：\");\n    SunWuKongDecorator swkDecorator = new SunWuKongDecorator(new Monkey());\n    swkDecorator.introduce();\n\n    System.out.println();\n\n    // 使用六耳猕猴装饰器装饰猴子\n    System.out.print(\"使用六耳猕猴装饰器装饰后的猴子：\");\n    SixEarsMonkeyDecorator semDecorator = new SixEarsMonkeyDecorator(new Monkey());\n    semDecorator.introduce();\n}\n\n\n\n6、输出结果\n\n使用装饰器前的猴子：我是一个会说话的猴子！\n使用孙悟空装饰器装饰后的猴子：我是一个会说话的猴子！我是美猴王，我会七十二变！我师傅是大唐高僧！\n使用六耳猕猴装饰器装饰后的猴子：我是一个会说话的猴子！我才是美猴王，我会七十二变！大唐高僧是我师傅！\n\n\n总结：上面的例子中，我们并没有对Monkey类本身进行改造，而是采用装饰器包装的方式为Monkey增加了新的功能，这种方式可以动态的为实体类增加功能，比继承更灵活，且装饰类和被装饰类互不影响，可以各自扩展。","feature_image":"__GHOST_URL__/content/images/2021/10/sunwukong_sixears.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 03:09:12","created_by":"1","updated_at":"2021-10-12 10:31:04","updated_by":"1","published_at":"2018-05-18 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"616562600af28a00012bf137","uuid":"b757d74b-650d-41f8-af2b-377dc81c5183","title":"情绪控制","slug":"qing-xu-kong-zhi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"\\n**引言**\\n这些关于情绪控制的文字，是我对自己冲动行为的一次反省。要做一个宽宏大度的职场人，自我修炼吧。\\n\\n**情绪失控**\\n    终于，今天又没有忍住，由于接受不了一个同事说话的语气，说了一句讽刺的狠话，然后黑着脸摔门离开。过了一会儿他主动过来谈和，我也对我的行为表示了抱歉。可是顿时我感觉自己真的很狭隘，很没有素质，没有控制好自己的情绪，非常可笑。事情已经发生了，只能自己反省不要再这么冲动，这种不成熟的行为很丢脸，一点小事情闹得同事关系不融洽，非常不值。\\n\\n**办公室里没有朋友和敌人，只有同事和合作伙伴**\\n    我个人很不喜欢把自己摆的高高在上、架子很大的人，不想去接近。事与愿违，偏偏会有和这类人一起合作工作的时候，不过，也算是在磨炼自己的冲动脾气吧。就工作来说，过于感性的处理事情是不恰当的，我吃了很多次这种亏。\\n    记得前几年有个关系还算不错的程序员同事跟我开了一个比较过的玩笑，被我恶狠狠的骂了一顿，后来关系近乎决裂，不相往来，当时感觉很解气，后来想想自己确实有点过分了。\\n    在公司，我做不到让所有人都喜欢我，也做不到喜欢所有人。我一个爱“管闲事”的人，属于路见不平一声吼，该出手时就出手的莽夫。看不惯的事情，就想去纠正，不符合规范的作风，我就想提出来。我也不知道这样好不好，因为我也不是打小报告，光明正大的做事情，只想让一切顺利的正常进行。\\n    当然，不可能一切都那么顺利，比如与人沟通，解决不了言语冲突的时候，在没有想到其它好的办法处理时，产生的负面情绪让沟通变得非常不顺畅，甚至气愤离席。\\n\\n**冷静下来**\\n    高中的时候，一位老师说我是勇于认错却屡教不改的人，当然我是不买账的，我自认为我知错就改。现在回想起来，老师说的没错，这是我很大的一个弱点。发生过后我会立即认识到错误，但是前一秒明明还在惹事生非。**冷静下来**，遇事情要三思而后行，稳妥处理。\\n    今天还学了个词叫“钝感”，我认为这也是可以做好情绪控制的一些方法。“钝感”dùn gǎn心理学名词，与“敏感”意思相对，词性相同，两者互为反义词。钝感是人的动作活动反应慢度的标尺，是用来描述人活动速率的。钝感系数越高则对外部反应越迟钝，同时其敏感度也会越低，人的思维只有钝感系数与敏感系数相平衡才更容易保持较为理性的思维，否则反之。\\n钝感虽然有时给人以迟钝，木讷的负面印象，但钝感力却是我们赢得美好生活的手段和智慧。——渡边淳一\\n钝感力的五项铁律：\\n\\n1. 迅速忘却不快之事。\\n2. 认定目标，即使失败仍要继续挑战。\\n3. 坦然面对流言蜚语。\\n4. 对嫉妒讽刺常怀感谢之心。\\n5. 面对表扬，不得寸进尺，不得意忘形。\\n\\n**总结**\\n冷静处事，三思后行，荣辱不惊。\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>引言</strong><br>\n这些关于情绪控制的文字，是我对自己冲动行为的一次反省。要做一个宽宏大度的职场人，自我修炼吧。</p>\n<p><strong>情绪失控</strong><br>\n终于，今天又没有忍住，由于接受不了一个同事说话的语气，说了一句讽刺的狠话，然后黑着脸摔门离开。过了一会儿他主动过来谈和，我也对我的行为表示了抱歉。可是顿时我感觉自己真的很狭隘，很没有素质，没有控制好自己的情绪，非常可笑。事情已经发生了，只能自己反省不要再这么冲动，这种不成熟的行为很丢脸，一点小事情闹得同事关系不融洽，非常不值。</p>\n<p><strong>办公室里没有朋友和敌人，只有同事和合作伙伴</strong><br>\n我个人很不喜欢把自己摆的高高在上、架子很大的人，不想去接近。事与愿违，偏偏会有和这类人一起合作工作的时候，不过，也算是在磨炼自己的冲动脾气吧。就工作来说，过于感性的处理事情是不恰当的，我吃了很多次这种亏。<br>\n记得前几年有个关系还算不错的程序员同事跟我开了一个比较过的玩笑，被我恶狠狠的骂了一顿，后来关系近乎决裂，不相往来，当时感觉很解气，后来想想自己确实有点过分了。<br>\n在公司，我做不到让所有人都喜欢我，也做不到喜欢所有人。我一个爱“管闲事”的人，属于路见不平一声吼，该出手时就出手的莽夫。看不惯的事情，就想去纠正，不符合规范的作风，我就想提出来。我也不知道这样好不好，因为我也不是打小报告，光明正大的做事情，只想让一切顺利的正常进行。<br>\n当然，不可能一切都那么顺利，比如与人沟通，解决不了言语冲突的时候，在没有想到其它好的办法处理时，产生的负面情绪让沟通变得非常不顺畅，甚至气愤离席。</p>\n<p><strong>冷静下来</strong><br>\n高中的时候，一位老师说我是勇于认错却屡教不改的人，当然我是不买账的，我自认为我知错就改。现在回想起来，老师说的没错，这是我很大的一个弱点。发生过后我会立即认识到错误，但是前一秒明明还在惹事生非。<strong>冷静下来</strong>，遇事情要三思而后行，稳妥处理。<br>\n今天还学了个词叫“钝感”，我认为这也是可以做好情绪控制的一些方法。“钝感”dùn gǎn心理学名词，与“敏感”意思相对，词性相同，两者互为反义词。钝感是人的动作活动反应慢度的标尺，是用来描述人活动速率的。钝感系数越高则对外部反应越迟钝，同时其敏感度也会越低，人的思维只有钝感系数与敏感系数相平衡才更容易保持较为理性的思维，否则反之。<br>\n钝感虽然有时给人以迟钝，木讷的负面印象，但钝感力却是我们赢得美好生活的手段和智慧。——渡边淳一<br>\n钝感力的五项铁律：</p>\n<ol>\n<li>迅速忘却不快之事。</li>\n<li>认定目标，即使失败仍要继续挑战。</li>\n<li>坦然面对流言蜚语。</li>\n<li>对嫉妒讽刺常怀感谢之心。</li>\n<li>面对表扬，不得寸进尺，不得意忘形。</li>\n</ol>\n<p><strong>总结</strong><br>\n冷静处事，三思后行，荣辱不惊。</p>\n<!--kg-card-end: markdown-->","comment_id":"616562600af28a00012bf137","plaintext":"引言\n这些关于情绪控制的文字，是我对自己冲动行为的一次反省。要做一个宽宏大度的职场人，自我修炼吧。\n\n情绪失控\n终于，今天又没有忍住，由于接受不了一个同事说话的语气，说了一句讽刺的狠话，然后黑着脸摔门离开。过了一会儿他主动过来谈和，我也对我的行为表示了抱歉。可是顿时我感觉自己真的很狭隘，很没有素质，没有控制好自己的情绪，非常可笑。事情已经发生了，只能自己反省不要再这么冲动，这种不成熟的行为很丢脸，一点小事情闹得同事关系不融洽，非常不值。\n\n办公室里没有朋友和敌人，只有同事和合作伙伴\n我个人很不喜欢把自己摆的高高在上、架子很大的人，不想去接近。事与愿违，偏偏会有和这类人一起合作工作的时候，不过，也算是在磨炼自己的冲动脾气吧。就工作来说，过于感性的处理事情是不恰当的，我吃了很多次这种亏。\n记得前几年有个关系还算不错的程序员同事跟我开了一个比较过的玩笑，被我恶狠狠的骂了一顿，后来关系近乎决裂，不相往来，当时感觉很解气，后来想想自己确实有点过分了。\n在公司，我做不到让所有人都喜欢我，也做不到喜欢所有人。我一个爱“管闲事”的人，属于路见不平一声吼，该出手时就出手的莽夫。看不惯的事情，就想去纠正，不符合规范的作风，我就想提出来。我也不知道这样好不好，因为我也不是打小报告，光明正大的做事情，只想让一切顺利的正常进行。\n当然，不可能一切都那么顺利，比如与人沟通，解决不了言语冲突的时候，在没有想到其它好的办法处理时，产生的负面情绪让沟通变得非常不顺畅，甚至气愤离席。\n\n冷静下来\n高中的时候，一位老师说我是勇于认错却屡教不改的人，当然我是不买账的，我自认为我知错就改。现在回想起来，老师说的没错，这是我很大的一个弱点。发生过后我会立即认识到错误，但是前一秒明明还在惹事生非。\n冷静下来，遇事情要三思而后行，稳妥处理。\n今天还学了个词叫“钝感”，我认为这也是可以做好情绪控制的一些方法。“钝感”dùn\ngǎn心理学名词，与“敏感”意思相对，词性相同，两者互为反义词。钝感是人的动作活动反应慢度的标尺，是用来描述人活动速率的。钝感系数越高则对外部反应越迟钝，同时其敏感度也会越低，人的思维只有钝感系数与敏感系数相平衡才更容易保持较为理性的思维，否则反之。\n钝感虽然有时给人以迟钝，木讷的负面印象，但钝感力却是我们赢得美好生活的手段和智慧。——渡边淳一\n钝感力的五项铁律：\n\n 1. 迅速忘却不快之事。\n 2. 认定目标，即使失败仍要继续挑战。\n 3. 坦然面对流言蜚语。\n 4. 对嫉妒讽刺常怀感谢之心。\n 5. 面对表扬，不得寸进尺，不得意忘形。\n\n总结\n冷静处事，三思后行，荣辱不惊。","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.64f92ad78c2aeee31b47d459b2506988.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:24:32","created_by":"1","updated_at":"2021-10-12 10:29:59","updated_by":"1","published_at":"2018-02-07 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"616564710af28a00012bf14a","uuid":"f67a9d08-db7d-4750-ad0c-c77bc380d128","title":"Spring项目数据库密码加密","slug":"springxiang-mu-shu-ju-ku-mi-ma-jia-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 很多的软件项目都会把数据库的连接信息明文写在properties配置文件里，只要打开了配置文件，就能直接看到数据库的用户名密码等信息，一些项目会要求不能出现明文密码，接下来，简单三步，实现配置文件里的用户名和密码加密。\\n\\n### 一、加密解密工具类\\n\\n我以Base64为例，写个简单的加密和解密工具\\n\\n```java\\npackage org.nocoder.utils;\\n\\nimport org.apache.commons.codec.binary.Base64;\\nimport org.apache.commons.lang3.StringUtils;\\n\\n/**\\n * EncryptUtil\\n * Created by jason on 2017/7/18.\\n */\\npublic class EncryptUtil {\\n\\n    /**\\n     * 加密\\n     * @param value\\n     * @return encode string value\\n     */\\n    public static String encode(String value){\\n        if(StringUtils.isNotBlank(value)){\\n            Base64 base64 = new Base64();\\n            return new String(base64.encode(value.getBytes()));\\n        }\\n        return null;\\n    }\\n\\n    /**\\n     * 解密\\n     * @param value\\n     * @return decode string value\\n     */\\n    public static String decode(String value){\\n        if(StringUtils.isNotBlank(value)){\\n            Base64 base64 = new Base64();\\n            return new String(base64.decode(value.getBytes()));\\n        }\\n        return null;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(EncryptUtil.encode(\\\"test\\\"));\\n        System.out.println(EncryptUtil.decode(\\\"dGVzdA==\\\"));\\n    }\\n}\\n\\n```\\n\\n### 二、通过继承spring配置类并重写处理方法实现解密\\n\\n```java\\npackage org.nocoder.security;\\n\\nimport org.apache.commons.lang3.StringUtils;\\nimport org.nocoder.utils.EncryptUtil;\\nimport org.springframework.beans.BeansException;\\nimport org.springframework.beans.factory.BeanInitializationException;\\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\\n\\nimport java.util.Properties;\\n\\n/**\\n * 通过继承spring配置类并重写处理方法实现密文解密\\n * Created by jason on 2017/7/18.\\n */\\npublic class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer{\\n    @Override\\n    protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) throws BeansException {\\n        try {\\n            String username = props.getProperty(\\\"username\\\");\\n            if(StringUtils.isNotBlank(username)){\\n                props.setProperty(\\\"username\\\", EncryptUtil.decode(username));\\n            }\\n\\n            String password = props.getProperty(\\\"password\\\");\\n            if(StringUtils.isNotBlank(password)){\\n                props.setProperty(\\\"password\\\",EncryptUtil.decode(password));\\n            }\\n            super.processProperties(beanFactory, props);\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n            throw new BeanInitializationException(e.getMessage());\\n        }\\n    }\\n}\\n\\n```\\n\\n### 三、修改配置文件\\n\\n1、使用加密工具类对用户名和密码进行加密，修改properties配置文件`config.properties`\\n\\n```java\\ndriver=org.postgresql.Driver\\nurl=jdbc:postgresql://127.0.0.1:5432/freda_db\\nusername=加密后的用户名\\npassword=加密后的密码\\n#定义初始连接数\\ninitialSize=0\\n#定义最大连接数\\nmaxActive=50\\n#定义最大空闲\\nmaxIdle=50\\n#定义最小空闲\\nminIdle=1\\n#定义最长等待时间\\nmaxWait=60000\\n```\\n\\n2、修改`applicationContext.xml`，引入配置文件\\n\\n```java\\n<!-- 引入配置文件，这里的class就是之前写的那个Spring配置类的路径 -->\\n\\t<bean id=\\\"encryptPropertyConfigurer\\\" class=\\\"org.nocoder.security.EncryptPropertyPlaceholderConfigurer\\\">\\n\\t\\t<property name=\\\"locations\\\">\\n\\t\\t\\t<list>\\n\\t\\t\\t\\t<value>classpath:config.properties</value>\\n\\t\\t\\t</list>\\n\\t\\t</property>\\n\\t</bean>\\n```\\n\\nOK了，就这三步，重启服务试试看！\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>很多的软件项目都会把数据库的连接信息明文写在properties配置文件里，只要打开了配置文件，就能直接看到数据库的用户名密码等信息，一些项目会要求不能出现明文密码，接下来，简单三步，实现配置文件里的用户名和密码加密。</p>\n</blockquote>\n<h3 id=\"%E4%B8%80%E3%80%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB\">一、加密解密工具类</h3>\n<p>我以Base64为例，写个简单的加密和解密工具</p>\n<pre><code class=\"language-java\">package org.nocoder.utils;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * EncryptUtil\n * Created by jason on 2017/7/18.\n */\npublic class EncryptUtil {\n\n    /**\n     * 加密\n     * @param value\n     * @return encode string value\n     */\n    public static String encode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.encode(value.getBytes()));\n        }\n        return null;\n    }\n\n    /**\n     * 解密\n     * @param value\n     * @return decode string value\n     */\n    public static String decode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.decode(value.getBytes()));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(EncryptUtil.encode(&quot;test&quot;));\n        System.out.println(EncryptUtil.decode(&quot;dGVzdA==&quot;));\n    }\n}\n\n</code></pre>\n<h3 id=\"%E4%BA%8C%E3%80%81%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BFspring%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%B9%B6%E9%87%8D%E5%86%99%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E8%A7%A3%E5%AF%86\">二、通过继承spring配置类并重写处理方法实现解密</h3>\n<pre><code class=\"language-java\">package org.nocoder.security;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.nocoder.utils.EncryptUtil;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanInitializationException;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\n\nimport java.util.Properties;\n\n/**\n * 通过继承spring配置类并重写处理方法实现密文解密\n * Created by jason on 2017/7/18.\n */\npublic class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer{\n    @Override\n    protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) throws BeansException {\n        try {\n            String username = props.getProperty(&quot;username&quot;);\n            if(StringUtils.isNotBlank(username)){\n                props.setProperty(&quot;username&quot;, EncryptUtil.decode(username));\n            }\n\n            String password = props.getProperty(&quot;password&quot;);\n            if(StringUtils.isNotBlank(password)){\n                props.setProperty(&quot;password&quot;,EncryptUtil.decode(password));\n            }\n            super.processProperties(beanFactory, props);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new BeanInitializationException(e.getMessage());\n        }\n    }\n}\n\n</code></pre>\n<h3 id=\"%E4%B8%89%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">三、修改配置文件</h3>\n<p>1、使用加密工具类对用户名和密码进行加密，修改properties配置文件<code>config.properties</code></p>\n<pre><code class=\"language-java\">driver=org.postgresql.Driver\nurl=jdbc:postgresql://127.0.0.1:5432/freda_db\nusername=加密后的用户名\npassword=加密后的密码\n#定义初始连接数\ninitialSize=0\n#定义最大连接数\nmaxActive=50\n#定义最大空闲\nmaxIdle=50\n#定义最小空闲\nminIdle=1\n#定义最长等待时间\nmaxWait=60000\n</code></pre>\n<p>2、修改<code>applicationContext.xml</code>，引入配置文件</p>\n<pre><code class=\"language-java\">&lt;!-- 引入配置文件，这里的class就是之前写的那个Spring配置类的路径 --&gt;\n\t&lt;bean id=&quot;encryptPropertyConfigurer&quot; class=&quot;org.nocoder.security.EncryptPropertyPlaceholderConfigurer&quot;&gt;\n\t\t&lt;property name=&quot;locations&quot;&gt;\n\t\t\t&lt;list&gt;\n\t\t\t\t&lt;value&gt;classpath:config.properties&lt;/value&gt;\n\t\t\t&lt;/list&gt;\n\t\t&lt;/property&gt;\n\t&lt;/bean&gt;\n</code></pre>\n<p>OK了，就这三步，重启服务试试看！</p>\n<!--kg-card-end: markdown-->","comment_id":"616564710af28a00012bf14a","plaintext":"> 很多的软件项目都会把数据库的连接信息明文写在properties配置文件里，只要打开了配置文件，就能直接看到数据库的用户名密码等信息，一些项目会要求不能出现明文密码，接下来，简单三步，实现配置文件里的用户名和密码加密。\n\n\n一、加密解密工具类\n我以Base64为例，写个简单的加密和解密工具\n\npackage org.nocoder.utils;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * EncryptUtil\n * Created by jason on 2017/7/18.\n */\npublic class EncryptUtil {\n\n    /**\n     * 加密\n     * @param value\n     * @return encode string value\n     */\n    public static String encode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.encode(value.getBytes()));\n        }\n        return null;\n    }\n\n    /**\n     * 解密\n     * @param value\n     * @return decode string value\n     */\n    public static String decode(String value){\n        if(StringUtils.isNotBlank(value)){\n            Base64 base64 = new Base64();\n            return new String(base64.decode(value.getBytes()));\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(EncryptUtil.encode(\"test\"));\n        System.out.println(EncryptUtil.decode(\"dGVzdA==\"));\n    }\n}\n\n\n\n二、通过继承spring配置类并重写处理方法实现解密\npackage org.nocoder.security;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.nocoder.utils.EncryptUtil;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanInitializationException;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\n\nimport java.util.Properties;\n\n/**\n * 通过继承spring配置类并重写处理方法实现密文解密\n * Created by jason on 2017/7/18.\n */\npublic class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer{\n    @Override\n    protected void processProperties(ConfigurableListableBeanFactory beanFactory, Properties props) throws BeansException {\n        try {\n            String username = props.getProperty(\"username\");\n            if(StringUtils.isNotBlank(username)){\n                props.setProperty(\"username\", EncryptUtil.decode(username));\n            }\n\n            String password = props.getProperty(\"password\");\n            if(StringUtils.isNotBlank(password)){\n                props.setProperty(\"password\",EncryptUtil.decode(password));\n            }\n            super.processProperties(beanFactory, props);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new BeanInitializationException(e.getMessage());\n        }\n    }\n}\n\n\n\n三、修改配置文件\n1、使用加密工具类对用户名和密码进行加密，修改properties配置文件config.properties\n\ndriver=org.postgresql.Driver\nurl=jdbc:postgresql://127.0.0.1:5432/freda_db\nusername=加密后的用户名\npassword=加密后的密码\n#定义初始连接数\ninitialSize=0\n#定义最大连接数\nmaxActive=50\n#定义最大空闲\nmaxIdle=50\n#定义最小空闲\nminIdle=1\n#定义最长等待时间\nmaxWait=60000\n\n\n2、修改applicationContext.xml，引入配置文件\n\n<!-- 引入配置文件，这里的class就是之前写的那个Spring配置类的路径 -->\n\t<bean id=\"encryptPropertyConfigurer\" class=\"org.nocoder.security.EncryptPropertyPlaceholderConfigurer\">\n\t\t<property name=\"locations\">\n\t\t\t<list>\n\t\t\t\t<value>classpath:config.properties</value>\n\t\t\t</list>\n\t\t</property>\n\t</bean>\n\n\nOK了，就这三步，重启服务试试看！","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.8a0485263f149cf31c40f5bfa567ce18.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:33:21","created_by":"1","updated_at":"2021-10-12 10:35:34","updated_by":"1","published_at":"2017-07-17 16:03:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6165652f0af28a00012bf157","uuid":"4221d037-4eb3-49ed-ad44-62c196adfbd2","title":"使用枚举替换常量类","slug":"shi-yong-mei-ju-ti-huan-chang-liang-lei","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 项目中必然会用到常量，我接触过的一些老旧项目，基本都是用常量类或接口类来定义常量。Java1.5以后，JDK中引入了枚举类，清晰又简单。\\n\\n先说说为啥要替换吧。\\n首先，枚举常量更简单\\n第二，枚举有内置方法\\n第三，枚举可以自定义方法\\n\\n看看代码，感受一下。\\n\\n```java\\nClass Season{\\n\\tpublic final static int Spring = 0;\\n\\tpublic final static int Summer = 1;\\n\\tpublic final static int Autumn = 2;\\n\\tpublic final static int Winter = 3;\\n\\t\\n\\tpublic static int getComfortableSeason(){\\n\\t\\tpublic static int getComfortableSeason(){\\n\\t\\t\\treturn Spring;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\n下面这个是用枚举来定义常量：\\n\\n```java\\nenum Season{\\n\\tSpring, Summer, Autumn, Winter;\\n\\t\\n\\tpublic static Season getComfortableSeason() {\\n\\t\\treturn Spring;\\n\\t}\\n}\\n```\\n\\n> `Java语言规范` 提倡枚举项全部大写，字母之间用下划线分隔。\\n\\n```java\\npackage org.nocoder.enumeration;\\n\\n/**\\n * 文档状态\\n * Created by jason on 2017/7/14.\\n */\\npublic enum ArchiveStatus {\\n    ALL(0), DRAFT(1), PUBLISHED(2);\\n\\n    private int value;\\n\\n    public int getValue() {\\n        return value;\\n    }\\n\\n    public void setValue(int value) {\\n        this.value = value;\\n    }\\n\\n    ArchiveStatus(int value){\\n        this.value = value;\\n    }\\n}\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>项目中必然会用到常量，我接触过的一些老旧项目，基本都是用常量类或接口类来定义常量。Java1.5以后，JDK中引入了枚举类，清晰又简单。</p>\n</blockquote>\n<p>先说说为啥要替换吧。<br>\n首先，枚举常量更简单<br>\n第二，枚举有内置方法<br>\n第三，枚举可以自定义方法</p>\n<p>看看代码，感受一下。</p>\n<pre><code class=\"language-java\">Class Season{\n\tpublic final static int Spring = 0;\n\tpublic final static int Summer = 1;\n\tpublic final static int Autumn = 2;\n\tpublic final static int Winter = 3;\n\t\n\tpublic static int getComfortableSeason(){\n\t\tpublic static int getComfortableSeason(){\n\t\t\treturn Spring;\n\t\t}\n\t}\n}\n</code></pre>\n<p>下面这个是用枚举来定义常量：</p>\n<pre><code class=\"language-java\">enum Season{\n\tSpring, Summer, Autumn, Winter;\n\t\n\tpublic static Season getComfortableSeason() {\n\t\treturn Spring;\n\t}\n}\n</code></pre>\n<blockquote>\n<p><code>Java语言规范</code> 提倡枚举项全部大写，字母之间用下划线分隔。</p>\n</blockquote>\n<pre><code class=\"language-java\">package org.nocoder.enumeration;\n\n/**\n * 文档状态\n * Created by jason on 2017/7/14.\n */\npublic enum ArchiveStatus {\n    ALL(0), DRAFT(1), PUBLISHED(2);\n\n    private int value;\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    ArchiveStatus(int value){\n        this.value = value;\n    }\n}\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"6165652f0af28a00012bf157","plaintext":"> 项目中必然会用到常量，我接触过的一些老旧项目，基本都是用常量类或接口类来定义常量。Java1.5以后，JDK中引入了枚举类，清晰又简单。\n\n\n先说说为啥要替换吧。\n首先，枚举常量更简单\n第二，枚举有内置方法\n第三，枚举可以自定义方法\n\n看看代码，感受一下。\n\nClass Season{\n\tpublic final static int Spring = 0;\n\tpublic final static int Summer = 1;\n\tpublic final static int Autumn = 2;\n\tpublic final static int Winter = 3;\n\t\n\tpublic static int getComfortableSeason(){\n\t\tpublic static int getComfortableSeason(){\n\t\t\treturn Spring;\n\t\t}\n\t}\n}\n\n\n下面这个是用枚举来定义常量：\n\nenum Season{\n\tSpring, Summer, Autumn, Winter;\n\t\n\tpublic static Season getComfortableSeason() {\n\t\treturn Spring;\n\t}\n}\n\n\n> Java语言规范 提倡枚举项全部大写，字母之间用下划线分隔。\n\n\npackage org.nocoder.enumeration;\n\n/**\n * 文档状态\n * Created by jason on 2017/7/14.\n */\npublic enum ArchiveStatus {\n    ALL(0), DRAFT(1), PUBLISHED(2);\n\n    private int value;\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    ArchiveStatus(int value){\n        this.value = value;\n    }\n}","feature_image":"__GHOST_URL__/content/images/2021/10/5ee9bd921c28d940.jpg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:36:31","created_by":"1","updated_at":"2021-10-12 10:39:12","updated_by":"1","published_at":"2017-07-14 10:36:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"616566140af28a00012bf164","uuid":"920a28e9-deee-4474-b8b5-cec4a8d0d535","title":"十进制和二进制计数法","slug":"decimal-and-binary-notation","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"**10进制计数法**\\n\\n- 平时我们使用的就是10进制计数法，使用的数字有10种，即 `0、1、2、3、4、5、6、7、8、9`\\n\\n- 数位有一定的意义，从右往左分别表示个位、十位、百位、千位...\\n\\n- 引用书中的例子，来分解\\n\\n  ```\\n  2503\\n  ```\\n\\n  这个数\\n\\n  - 2 表示的是 1000 的个数\\n  - 5 表示的是 100 的个数\\n  - 0 表示的是 10 的个数\\n  - 3 表示的是 1 的个数\\n  - 2503 这个数字就是2个1000、5个100、0个10、3个1 累加的结果\\n  - 1000 是 `10*10*10` 即10的3次方，100 是 `10*10` 即10 的2次方\\n  - 2503 又可以表示为 `2*10的3次方 + 5*10的2次方 + 0*10的1次方 + 3*10的0次方`\\n\\n**2进制计数法**\\n\\n- 计算机在处理数据时使用的是2进制计数法，使用的数字有2中，即 `0、1`\\n- 数位的意义是，从右往左分别表示1位、2位、4位、8位、16位....\\n\\n#### 10进制和2进制数的转换\\n\\n[![0到99的10进制和2进制计数](https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png)](https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99的10进制和2进制计数.png)\\n\\n#### 2 进制转换成 10 进制\\n\\n> 直接举例子，把2进制 `1010110` 转换成10进制\\n\\n由于2进制从右往左分别表示1位，2位，4位，8位，16位...\\n\\n| 1    | 0    | 1    | 0    | 1    | 1    | 0    |\\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- |\\n| 64   | 32   | 16   | 8    | 4    | 2    | 1    |\\n\\n然后把所有的`1`下面的对应的值加起来，即`64+16+4+2=86`\\n\\n#### 10 进制转换成 2 进制\\n\\n**余数短除法**\\n\\n> 活用这个方法可以将所有十进制数字转换成任何进制表达。除数为2是因为我们最终想得到的以2为基数的数（即二进制数值） 。如果最终想得到其他数系的数字，用目标数系的基数代替这个方法里二进制的基数2 就可以了。例如，要得到基数为9的数，就用9来代替2作为除数 。最终的结果就是目标数系的数字表达。\\n\\n**整个计算过程只需要将数字一直除以2**\\n\\n1. 进行除法运算，纪录余数0或1\\n2. 继续用商除以2，一直到商为0\\n3. 写出2进制数字，从最后一个余数开始顺序读，读到最开始的余数\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>10进制计数法</strong></p>\n<ul>\n<li>\n<p>平时我们使用的就是10进制计数法，使用的数字有10种，即 <code>0、1、2、3、4、5、6、7、8、9</code></p>\n</li>\n<li>\n<p>数位有一定的意义，从右往左分别表示个位、十位、百位、千位...</p>\n</li>\n<li>\n<p>引用书中的例子，来分解</p>\n<pre><code>2503\n</code></pre>\n<p>这个数</p>\n<ul>\n<li>2 表示的是 1000 的个数</li>\n<li>5 表示的是 100 的个数</li>\n<li>0 表示的是 10 的个数</li>\n<li>3 表示的是 1 的个数</li>\n<li>2503 这个数字就是2个1000、5个100、0个10、3个1 累加的结果</li>\n<li>1000 是 <code>10*10*10</code> 即10的3次方，100 是 <code>10*10</code> 即10 的2次方</li>\n<li>2503 又可以表示为 <code>2*10的3次方 + 5*10的2次方 + 0*10的1次方 + 3*10的0次方</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>2进制计数法</strong></p>\n<ul>\n<li>计算机在处理数据时使用的是2进制计数法，使用的数字有2中，即 <code>0、1</code></li>\n<li>数位的意义是，从右往左分别表示1位、2位、4位、8位、16位....</li>\n</ul>\n<h4 id=\"10%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BD%AC%E6%8D%A2\">10进制和2进制数的转换</h4>\n<p><a href=\"https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png\"><img src=\"https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png\" alt=\"0到99的10进制和2进制计数\" loading=\"lazy\"></a></p>\n<h4 id=\"2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90-10-%E8%BF%9B%E5%88%B6\">2 进制转换成 10 进制</h4>\n<blockquote>\n<p>直接举例子，把2进制 <code>1010110</code> 转换成10进制</p>\n</blockquote>\n<p>由于2进制从右往左分别表示1位，2位，4位，8位，16位...</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>0</th>\n<th>1</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>64</td>\n<td>32</td>\n<td>16</td>\n<td>8</td>\n<td>4</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>然后把所有的<code>1</code>下面的对应的值加起来，即<code>64+16+4+2=86</code></p>\n<h4 id=\"10-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90-2-%E8%BF%9B%E5%88%B6\">10 进制转换成 2 进制</h4>\n<p><strong>余数短除法</strong></p>\n<blockquote>\n<p>活用这个方法可以将所有十进制数字转换成任何进制表达。除数为2是因为我们最终想得到的以2为基数的数（即二进制数值） 。如果最终想得到其他数系的数字，用目标数系的基数代替这个方法里二进制的基数2 就可以了。例如，要得到基数为9的数，就用9来代替2作为除数 。最终的结果就是目标数系的数字表达。</p>\n</blockquote>\n<p><strong>整个计算过程只需要将数字一直除以2</strong></p>\n<ol>\n<li>进行除法运算，纪录余数0或1</li>\n<li>继续用商除以2，一直到商为0</li>\n<li>写出2进制数字，从最后一个余数开始顺序读，读到最开始的余数</li>\n</ol>\n<!--kg-card-end: markdown-->","comment_id":"616566140af28a00012bf164","plaintext":"10进制计数法\n\n * 平时我们使用的就是10进制计数法，使用的数字有10种，即 0、1、2、3、4、5、6、7、8、9\n   \n   \n * 数位有一定的意义，从右往左分别表示个位、十位、百位、千位...\n   \n   \n * 引用书中的例子，来分解\n   \n   2503\n   \n   \n   这个数\n   \n    * 2 表示的是 1000 的个数\n    * 5 表示的是 100 的个数\n    * 0 表示的是 10 的个数\n    * 3 表示的是 1 的个数\n    * 2503 这个数字就是2个1000、5个100、0个10、3个1 累加的结果\n    * 1000 是 10*10*10 即10的3次方，100 是 10*10 即10 的2次方\n    * 2503 又可以表示为 2*10的3次方 + 5*10的2次方 + 0*10的1次方 + 3*10的0次方\n   \n   \n\n2进制计数法\n\n * 计算机在处理数据时使用的是2进制计数法，使用的数字有2中，即 0、1\n * 数位的意义是，从右往左分别表示1位、2位、4位、8位、16位....\n\n10进制和2进制数的转换\n \n[https://raw.githubusercontent.com/yangjinlong86/arts/master/2019/images/0-99%E7%9A%8410%E8%BF%9B%E5%88%B6%E5%92%8C2%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0.png]\n\n2 进制转换成 10 进制\n> 直接举例子，把2进制 1010110 转换成10进制\n\n\n由于2进制从右往左分别表示1位，2位，4位，8位，16位...\n\n10101106432168421然后把所有的1下面的对应的值加起来，即64+16+4+2=86\n\n10 进制转换成 2 进制\n余数短除法\n\n> 活用这个方法可以将所有十进制数字转换成任何进制表达。除数为2是因为我们最终想得到的以2为基数的数（即二进制数值）\n。如果最终想得到其他数系的数字，用目标数系的基数代替这个方法里二进制的基数2 就可以了。例如，要得到基数为9的数，就用9来代替2作为除数\n。最终的结果就是目标数系的数字表达。\n\n\n整个计算过程只需要将数字一直除以2\n\n 1. 进行除法运算，纪录余数0或1\n 2. 继续用商除以2，一直到商为0\n 3. 写出2进制数字，从最后一个余数开始顺序读，读到最开始的余数","feature_image":"__GHOST_URL__/content/images/2021/10/R-C.951e9c79b0f4d6d2f2e1d002ceabbd51.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:40:20","created_by":"1","updated_at":"2021-11-19 16:16:02","updated_by":"1","published_at":"2019-12-21 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6165670a0af28a00012bf171","uuid":"113e1461-5115-432c-b3cb-42b72854fa16","title":"不能改变，那就接受","slug":"bu-neng-gai-bian-na-jiu-jie-shou","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> 这篇文章是写给爱抱怨的人的。同时，也是写给自己的。\\n> 停止抱怨吧兄弟，如果可以，你就尝试去改变这个糟糕的现状。\\n\\n办公室里，大街上，火锅店里，电话里...\\n\\n任何地方你都能听到各种抱怨的声音，诸如此类：\\n\\n>“这个傻叉写的什么烂代码，格式化一下都不会嘛”\\n>“出尔反尔啊，本来你不是这么说的啊，这个傻叉，卧槽”\\n>“一会儿让我这么干，一会儿让我那么干，真是搞笑，哎”\\n>“这加班加的，还让不让人活了，真TMD不想干了”\\n>...\\n\\n当然，我也说过此类的话，而且不止一次。\\n\\n那，咱们来说道说道，“抱怨怎么了，有什么不对吗？”\\n\\n或许你认为抱怨是发泄愤怒情绪的一种方式，爆几句粗口，然后转过身，眼不见心不烦，不了了之，但是当你再次遇到相同的情况，可能情绪会更加糟糕，并且可能予以更激进的抱怨。\\n\\n结果呢，问题并没有解决。\\n\\n**什么是抱怨**\\n\\n> 抱怨：表达哀伤、痛苦或者不满。\\n\\n抱怨是人**说**出来的。“抱怨”和“陈述事实”有区别，它们表达的情绪不一样。抱怨的时候会散发负能量，唉声叹气，爆粗口等，如果你身边有这样的人，他可能也会影响到你的情绪或者处事的方式。\\n\\n>抱怨使我们关注问题本身，以至于我们不会去考虑解决问题、改善境遇的方法。\\n\\n不管是对自己、还是对别人抱怨，都产生不了积极的影响，只会让事情变得更糟糕。\\n\\n最近团队新来了2个初级程序员，工作年限都是2年，能力相仿，但是面对公司封装的框架，他们几乎可以说要从零开始学习。我把他们安排在不同的小组，a在A组，b在B组，由于工位紧张，暂时给他们安排的工位离团队比较远。\\na的负责人对他要求很高，认为a工作了两年应当具备一定的技术能力，在a遇到问题、耽误进度的时候，面对着巨大交付压力的A组长，对他发了脾气，“哎，还要我怎么说，不如让我直接做了算了”，“你连这个都不会，那你说怎么办”...a的工作效率越来越低。\\nb的负责人很有耐心的解答着新员工的问题，时而给予表扬，b逐渐能负责更多的模块，也经常跑过来沟通需求，融入团队的速度很快。\\n\\n我不否认他们有性格上的差异，但是仍然能反应一个事实，那就是，负能量会让人更加消极，正能量促使人进步的更快。如果A组长多一些耐心指导，换以表扬鼓励的方式对待a，那么a的表现肯定比现在要出色得多。\\n\\n如果你发现了让你不满的事情，就尝试改善它吧，如果你没有办法改变，那就接受现状。\\n\\n优化一下让你愤怒的烂代码，或者找author谈谈重构，或者提交一个BUG。\\n难吃的饭可以不吃，也可以请老板换一碗，或者我下次不光顾了。\\n赞美一下你的同事、你的家人，他们会更加努力，展现出更好的自己。\\n\\n最后，奉劝一下自己，要少说点脏话。\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>这篇文章是写给爱抱怨的人的。同时，也是写给自己的。<br>\n停止抱怨吧兄弟，如果可以，你就尝试去改变这个糟糕的现状。</p>\n</blockquote>\n<p>办公室里，大街上，火锅店里，电话里...</p>\n<p>任何地方你都能听到各种抱怨的声音，诸如此类：</p>\n<blockquote>\n<p>“这个傻叉写的什么烂代码，格式化一下都不会嘛”<br>\n“出尔反尔啊，本来你不是这么说的啊，这个傻叉，卧槽”<br>\n“一会儿让我这么干，一会儿让我那么干，真是搞笑，哎”<br>\n“这加班加的，还让不让人活了，真TMD不想干了”<br>\n...</p>\n</blockquote>\n<p>当然，我也说过此类的话，而且不止一次。</p>\n<p>那，咱们来说道说道，“抱怨怎么了，有什么不对吗？”</p>\n<p>或许你认为抱怨是发泄愤怒情绪的一种方式，爆几句粗口，然后转过身，眼不见心不烦，不了了之，但是当你再次遇到相同的情况，可能情绪会更加糟糕，并且可能予以更激进的抱怨。</p>\n<p>结果呢，问题并没有解决。</p>\n<p><strong>什么是抱怨</strong></p>\n<blockquote>\n<p>抱怨：表达哀伤、痛苦或者不满。</p>\n</blockquote>\n<p>抱怨是人<strong>说</strong>出来的。“抱怨”和“陈述事实”有区别，它们表达的情绪不一样。抱怨的时候会散发负能量，唉声叹气，爆粗口等，如果你身边有这样的人，他可能也会影响到你的情绪或者处事的方式。</p>\n<blockquote>\n<p>抱怨使我们关注问题本身，以至于我们不会去考虑解决问题、改善境遇的方法。</p>\n</blockquote>\n<p>不管是对自己、还是对别人抱怨，都产生不了积极的影响，只会让事情变得更糟糕。</p>\n<p>最近团队新来了2个初级程序员，工作年限都是2年，能力相仿，但是面对公司封装的框架，他们几乎可以说要从零开始学习。我把他们安排在不同的小组，a在A组，b在B组，由于工位紧张，暂时给他们安排的工位离团队比较远。<br>\na的负责人对他要求很高，认为a工作了两年应当具备一定的技术能力，在a遇到问题、耽误进度的时候，面对着巨大交付压力的A组长，对他发了脾气，“哎，还要我怎么说，不如让我直接做了算了”，“你连这个都不会，那你说怎么办”...a的工作效率越来越低。<br>\nb的负责人很有耐心的解答着新员工的问题，时而给予表扬，b逐渐能负责更多的模块，也经常跑过来沟通需求，融入团队的速度很快。</p>\n<p>我不否认他们有性格上的差异，但是仍然能反应一个事实，那就是，负能量会让人更加消极，正能量促使人进步的更快。如果A组长多一些耐心指导，换以表扬鼓励的方式对待a，那么a的表现肯定比现在要出色得多。</p>\n<p>如果你发现了让你不满的事情，就尝试改善它吧，如果你没有办法改变，那就接受现状。</p>\n<p>优化一下让你愤怒的烂代码，或者找author谈谈重构，或者提交一个BUG。<br>\n难吃的饭可以不吃，也可以请老板换一碗，或者我下次不光顾了。<br>\n赞美一下你的同事、你的家人，他们会更加努力，展现出更好的自己。</p>\n<p>最后，奉劝一下自己，要少说点脏话。</p>\n<!--kg-card-end: markdown-->","comment_id":"6165670a0af28a00012bf171","plaintext":"> 这篇文章是写给爱抱怨的人的。同时，也是写给自己的。\n停止抱怨吧兄弟，如果可以，你就尝试去改变这个糟糕的现状。\n\n\n办公室里，大街上，火锅店里，电话里...\n\n任何地方你都能听到各种抱怨的声音，诸如此类：\n\n> “这个傻叉写的什么烂代码，格式化一下都不会嘛”\n“出尔反尔啊，本来你不是这么说的啊，这个傻叉，卧槽”\n“一会儿让我这么干，一会儿让我那么干，真是搞笑，哎”\n“这加班加的，还让不让人活了，真TMD不想干了”\n...\n\n\n当然，我也说过此类的话，而且不止一次。\n\n那，咱们来说道说道，“抱怨怎么了，有什么不对吗？”\n\n或许你认为抱怨是发泄愤怒情绪的一种方式，爆几句粗口，然后转过身，眼不见心不烦，不了了之，但是当你再次遇到相同的情况，可能情绪会更加糟糕，并且可能予以更激进的抱怨。\n\n结果呢，问题并没有解决。\n\n什么是抱怨\n\n> 抱怨：表达哀伤、痛苦或者不满。\n\n\n抱怨是人说\n出来的。“抱怨”和“陈述事实”有区别，它们表达的情绪不一样。抱怨的时候会散发负能量，唉声叹气，爆粗口等，如果你身边有这样的人，他可能也会影响到你的情绪或者处事的方式。\n\n> 抱怨使我们关注问题本身，以至于我们不会去考虑解决问题、改善境遇的方法。\n\n\n不管是对自己、还是对别人抱怨，都产生不了积极的影响，只会让事情变得更糟糕。\n\n最近团队新来了2个初级程序员，工作年限都是2年，能力相仿，但是面对公司封装的框架，他们几乎可以说要从零开始学习。我把他们安排在不同的小组，a在A组，b在B组，由于工位紧张，暂时给他们安排的工位离团队比较远。\na的负责人对他要求很高，认为a工作了两年应当具备一定的技术能力，在a遇到问题、耽误进度的时候，面对着巨大交付压力的A组长，对他发了脾气，“哎，还要我怎么说，不如让我直接做了算了”，“你连这个都不会，那你说怎么办”...a的工作效率越来越低。\nb的负责人很有耐心的解答着新员工的问题，时而给予表扬，b逐渐能负责更多的模块，也经常跑过来沟通需求，融入团队的速度很快。\n\n我不否认他们有性格上的差异，但是仍然能反应一个事实，那就是，负能量会让人更加消极，正能量促使人进步的更快。如果A组长多一些耐心指导，换以表扬鼓励的方式对待a，那么a的表现肯定比现在要出色得多。\n\n如果你发现了让你不满的事情，就尝试改善它吧，如果你没有办法改变，那就接受现状。\n\n优化一下让你愤怒的烂代码，或者找author谈谈重构，或者提交一个BUG。\n难吃的饭可以不吃，也可以请老板换一碗，或者我下次不光顾了。\n赞美一下你的同事、你的家人，他们会更加努力，展现出更好的自己。\n\n最后，奉劝一下自己，要少说点脏话。","feature_image":"__GHOST_URL__/content/images/2021/10/AN6AliNTzfGfGZ_IIENQHaE8.jpeg","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-10-12 10:44:26","created_by":"1","updated_at":"2021-10-12 10:45:46","updated_by":"1","published_at":"2017-12-06 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"618eba1c0af28a00012bf1bb","uuid":"ff9ef093-64ce-4ec8-9bdf-998962573c9b","title":"CRUD Application With React and Spring Boot","slug":"crud-application-with-react-and-spring-boot","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"> You can clone the project from [github](https://github.com/nocdr/react-springboot-crud).\\n\\n1. generate springboot project from [start.spring.io](https://start.spring.io/).\\n    ![start-spring-io](__GHOST_URL__/content/images/2021/11/start-spring-io.png)\\n2. add dependencies to pom.xml file.\\n    ```xml\\n    <dependencies>\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter</artifactId>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-test</artifactId>\\n            <scope>test</scope>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-web</artifactId>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>org.springframework.boot</groupId>\\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\\n        </dependency>\\n\\n        <dependency>\\n            <groupId>com.h2database</groupId>\\n            <artifactId>h2</artifactId>\\n            <version>1.4.200</version>\\n            <scope>runtime</scope>\\n        </dependency>\\n    </dependencies>\\n    ```\\n3. create the Model, Repository, Controller.\\n4. add some `clients` using postman.\\n    ![postman-create-client](__GHOST_URL__/content/images/2021/11/postman-create-client.png)\\n5. create `react` app in spring boot application base directory, named `frontend`\\n    \\n   ```shell\\n    npx create-react-app frontend\\n    ```\\n   \\n    install bootstrap, react router and reactstrap in the frontend directory.\\n\\n    ```shell\\n    npm install --save bootstrap@5.1 react-cookie@4.1.1 react-router-dom@5.3.0 reactstrap@8.10.0\\n    ```\\n6. run `ReactSpringbootCrudApplication.java` to start the springboot project.\\n7. run `npm start` to start the frontend app.\\n8. visit `http://localhost:3000`, then we can see the demo.\\n\\n   ![clients](__GHOST_URL__/content/images/2021/11/clients.png)\\n\\n   ![client-list-edit-delete](__GHOST_URL__/content/images/2021/11/client-list-edit-delete.png)\\n   \\n> You can clone the project from [github](https://github.com/nocdr/react-springboot-crud).\\n\\nThe end.\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><blockquote>\n<p>You can clone the project from <a href=\"https://github.com/nocdr/react-springboot-crud\">github</a>.</p>\n</blockquote>\n<ol>\n<li>\n<p>generate springboot project from <a href=\"https://start.spring.io/\">start.spring.io</a>.<br>\n<img src=\"__GHOST_URL__/content/images/2021/11/start-spring-io.png\" alt=\"start-spring-io\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>add dependencies to pom.xml file.</p>\n<pre><code class=\"language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n        &lt;artifactId&gt;h2&lt;/artifactId&gt;\n        &lt;version&gt;1.4.200&lt;/version&gt;\n        &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n</li>\n<li>\n<p>create the Model, Repository, Controller.</p>\n</li>\n<li>\n<p>add some <code>clients</code> using postman.<br>\n<img src=\"__GHOST_URL__/content/images/2021/11/postman-create-client.png\" alt=\"postman-create-client\" loading=\"lazy\"></p>\n</li>\n<li>\n<p>create <code>react</code> app in spring boot application base directory, named <code>frontend</code></p>\n<pre><code class=\"language-shell\"> npx create-react-app frontend\n</code></pre>\n<p>install bootstrap, react router and reactstrap in the frontend directory.</p>\n<pre><code class=\"language-shell\">npm install --save bootstrap@5.1 react-cookie@4.1.1 react-router-dom@5.3.0 reactstrap@8.10.0\n</code></pre>\n</li>\n<li>\n<p>run <code>ReactSpringbootCrudApplication.java</code> to start the springboot project.</p>\n</li>\n<li>\n<p>run <code>npm start</code> to start the frontend app.</p>\n</li>\n<li>\n<p>visit <code>http://localhost:3000</code>, then we can see the demo.</p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/clients.png\" alt=\"clients\" loading=\"lazy\"></p>\n<p><img src=\"__GHOST_URL__/content/images/2021/11/client-list-edit-delete.png\" alt=\"client-list-edit-delete\" loading=\"lazy\"></p>\n</li>\n</ol>\n<blockquote>\n<p>You can clone the project from <a href=\"https://github.com/nocdr/react-springboot-crud\">github</a>.</p>\n</blockquote>\n<p>The end.</p>\n<!--kg-card-end: markdown-->","comment_id":"618eba1c0af28a00012bf1bb","plaintext":"> You can clone the project from github\n[https://github.com/nocdr/react-springboot-crud].\n\n\n 1. generate springboot project from start.spring.io [https://start.spring.io/].\n    \n    \n    \n 2. add dependencies to pom.xml file.\n    \n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n    \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n    \n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n    \n        <dependency>\n            <groupId>com.h2database</groupId>\n            <artifactId>h2</artifactId>\n            <version>1.4.200</version>\n            <scope>runtime</scope>\n        </dependency>\n    </dependencies>\n    \n    \n    \n 3. create the Model, Repository, Controller.\n    \n    \n 4. add some clients using postman.\n    \n    \n    \n 5. create react app in spring boot application base directory, named frontend\n    \n     npx create-react-app frontend\n    \n    \n    install bootstrap, react router and reactstrap in the frontend directory.\n    \n    npm install --save bootstrap@5.1 react-cookie@4.1.1 react-router-dom@5.3.0 reactstrap@8.10.0\n    \n    \n    \n 6. run ReactSpringbootCrudApplication.java to start the springboot project.\n    \n    \n 7. run npm start to start the frontend app.\n    \n    \n 8. visit http://localhost:3000, then we can see the demo.\n    \n    \n    \n    \n    \n    \n\n> You can clone the project from github\n[https://github.com/nocdr/react-springboot-crud].\n\n\nThe end.","feature_image":"__GHOST_URL__/content/images/2021/11/spring-react.png","featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-12 19:01:48","created_by":"1","updated_at":"2021-11-19 02:26:09","updated_by":"1","published_at":"2021-11-12 19:09:47","published_by":"1","custom_excerpt":"Implement a CRUD application with react and spring-boot.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6196fc3a0af28a00012bf1fc","uuid":"f3d7f923-43d2-4e77-a9f0-ffde43c306ab","title":"十二要素（The Twelve Factors）","slug":"shi-er-yao-su-the-twelve-factors","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"strong\"],[\"a\",[\"href\",\"https://www.12factor.net/\"]]],\"sections\":[[1,\"blockquote\",[[0,[],0,\"十二要素（The Twelve Factors）是由 Heroku 团队提出的云应用设计理念，是构建 SaaS 应用的一套方法论，特别关注应用程序随时间的推移而有机增长的动态性，开发者之间的有效代码协作，以及避免软件腐蚀。\"]]],[1,\"p\",[[0,[],0,\"十二个要素分别为：\"]]],[3,\"ol\",[[[0,[0],1,\"基准代码\"],[0,[],0,\"：同一套基准代码可以重用到多次部署中，共享的是代码，不同的仅是配置；\"]],[[0,[0],1,\"依赖\"],[0,[],0,\"：显式声明第三方依赖；\"]],[[0,[0],1,\"配置\"],[0,[],0,\"：将配置存储到环境变量；\"]],[[0,[0],1,\"后端服务\"],[0,[],0,\"：将后端服务作为松耦合的资源；\"]],[[0,[0],1,\"构建、发布、运行\"],[0,[],0,\"：严格区分应用的非运行时状态和运行时状态；\"]],[[0,[0],1,\"进程\"],[0,[],0,\"：将应用作为无状态的进程运行；\"]],[[0,[0],1,\"端口绑定\"],[0,[],0,\"：通过端口绑定对外发布服务，使用内嵌式web服务器或Spring Boot；\"]],[[0,[0],1,\"并发\"],[0,[],0,\"：能够通过水平伸缩应用程序进程来实现并发；\"]],[[0,[0],1,\"快速启动和优雅关闭\"],[0,[],0,\"：快速启动是为了在需要的时候，快速提供服务；优雅关闭是为了保证应用逻辑的完整性，将该完成的任务处理完再释放资源；\"]],[[0,[0],1,\"开发与生产环境等价\"],[0,[],0,\"：尽可能保证开发于生产环境的相似性；\"]],[[0,[0],1,\"日志\"],[0,[],0,\"：使用事件流处理日志，使用Flume、Filebeat等日志收集工具，将日志发送至Elasticsearch，用于排错和分析；\"]],[[0,[0],1,\"管理进程\"],[0,[],0,\"：把后台管理任务作为一次性的进程运行；\"]]]],[1,\"p\",[[0,[],0,\"详细信息建议到官网学习：\"],[0,[1],1,\"https://www.12factor.net/\"]]]],\"ghostVersion\":\"4.0\"}","html":"<blockquote>十二要素（The Twelve Factors）是由 Heroku 团队提出的云应用设计理念，是构建 SaaS 应用的一套方法论，特别关注应用程序随时间的推移而有机增长的动态性，开发者之间的有效代码协作，以及避免软件腐蚀。</blockquote><p>十二个要素分别为：</p><ol><li><strong>基准代码</strong>：同一套基准代码可以重用到多次部署中，共享的是代码，不同的仅是配置；</li><li><strong>依赖</strong>：显式声明第三方依赖；</li><li><strong>配置</strong>：将配置存储到环境变量；</li><li><strong>后端服务</strong>：将后端服务作为松耦合的资源；</li><li><strong>构建、发布、运行</strong>：严格区分应用的非运行时状态和运行时状态；</li><li><strong>进程</strong>：将应用作为无状态的进程运行；</li><li><strong>端口绑定</strong>：通过端口绑定对外发布服务，使用内嵌式web服务器或Spring Boot；</li><li><strong>并发</strong>：能够通过水平伸缩应用程序进程来实现并发；</li><li><strong>快速启动和优雅关闭</strong>：快速启动是为了在需要的时候，快速提供服务；优雅关闭是为了保证应用逻辑的完整性，将该完成的任务处理完再释放资源；</li><li><strong>开发与生产环境等价</strong>：尽可能保证开发于生产环境的相似性；</li><li><strong>日志</strong>：使用事件流处理日志，使用Flume、Filebeat等日志收集工具，将日志发送至Elasticsearch，用于排错和分析；</li><li><strong>管理进程</strong>：把后台管理任务作为一次性的进程运行；</li></ol><p>详细信息建议到官网学习：<a href=\"https://www.12factor.net/\">https://www.12factor.net/</a></p>","comment_id":"6196fc3a0af28a00012bf1fc","plaintext":"> 十二要素（The Twelve Factors）是由 Heroku 团队提出的云应用设计理念，是构建 SaaS\n应用的一套方法论，特别关注应用程序随时间的推移而有机增长的动态性，开发者之间的有效代码协作，以及避免软件腐蚀。\n十二个要素分别为：\n\n 1.  基准代码：同一套基准代码可以重用到多次部署中，共享的是代码，不同的仅是配置；\n 2.  依赖：显式声明第三方依赖；\n 3.  配置：将配置存储到环境变量；\n 4.  后端服务：将后端服务作为松耦合的资源；\n 5.  构建、发布、运行：严格区分应用的非运行时状态和运行时状态；\n 6.  进程：将应用作为无状态的进程运行；\n 7.  端口绑定：通过端口绑定对外发布服务，使用内嵌式web服务器或Spring Boot；\n 8.  并发：能够通过水平伸缩应用程序进程来实现并发；\n 9.  快速启动和优雅关闭：快速启动是为了在需要的时候，快速提供服务；优雅关闭是为了保证应用逻辑的完整性，将该完成的任务处理完再释放资源；\n 10. 开发与生产环境等价：尽可能保证开发于生产环境的相似性；\n 11. 日志：使用事件流处理日志，使用Flume、Filebeat等日志收集工具，将日志发送至Elasticsearch，用于排错和分析；\n 12. 管理进程：把后台管理任务作为一次性的进程运行；\n\n详细信息建议到官网学习：https://www.12factor.net/","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-19 01:22:02","created_by":"1","updated_at":"2021-11-19 01:27:09","updated_by":"1","published_at":"2021-08-04 16:44:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"6196ffd50af28a00012bf215","uuid":"0f8c0128-77ce-4e3c-9585-ed8a86ee52c6","title":"Python 另一个经典递归：二分法查找","slug":"python-ling-yi-ge-jing-dian-di-gui-er-fen-fa-cha-zhao","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"先来玩个数字游戏，我从1～100中选一个整数，你来猜中这个数字。\\n\\n如果你运气好的话可能十几次就猜中了，也可能是耐心的提问了我100次后。\\n\\n但其实你只需要提问7次就可以找到答案。\\n\\n举个例子，假设我选的数字是`86`。\\n- 问：这个数是否大于50？\\n答：是\\n- 问：大于75？\\n答：是\\n- 问：大于88？\\n答：否\\n- 问：大于82？\\n答：是\\n- 问：大于86？\\n答：否\\n- 问：大于84？\\n答：是\\n- 问：大于85？\\n答：是\\n\\n最终答案锁定，大于85并且不大于86，即`86`。\\n\\n>连续将满足条件的值等分，直到找到正确答案，这就是二分法。\\n>这个算法的本身就是递归的定义，也可以用递归来实现\\n\\n- 如果上下限相同，那么就是数字所在的位置，返回；\\n- 否则找到两者的中间点，也就是上下限的平均值，查找数字在中间点的左侧还是右侧，然后继续查找数字所在的那半部分\\n\\n下面实现一个二分法查找，返回查找目标数字所在序列的位置，下标。\\n```python\\n#!/usr/bin/python\\n'''\\n二分法查找\\nsequence 查找的序列，范围\\nnumber   查找目标\\nlower    下限\\nupper    上限    \\n'''\\ndef search(sequence, number, lower, upper):\\n\\tif lower == upper:\\n\\t\\tassert number == sequence[upper]\\n\\t\\treturn upper\\n\\telse:\\n\\t\\tmiddle = (lower + upper) // 2 #找到两者的中间点\\n\\t\\tif number > sequence[middle]: \\n\\t\\t\\t#如果在中间点的右侧，就在middle+1 ～ upper的范围内继续找\\n\\t\\t\\treturn search(sequence, number, middle+1, upper)\\n\\t\\telse:\\n\\t\\t\\t#如果在中间点的左侧，就在lower～middle的范围继续找\\n\\t\\t\\treturn search(sequence, number, lower, middle)\\t\\t\\t\\n#初始化一个1～100的列表\\nseq = []\\nfor x in xrange(1,101):\\n\\tseq.append(x)\\nprint search(seq, 86, 0, 100)\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>先来玩个数字游戏，我从1～100中选一个整数，你来猜中这个数字。</p>\n<p>如果你运气好的话可能十几次就猜中了，也可能是耐心的提问了我100次后。</p>\n<p>但其实你只需要提问7次就可以找到答案。</p>\n<p>举个例子，假设我选的数字是<code>86</code>。</p>\n<ul>\n<li>问：这个数是否大于50？<br>\n答：是</li>\n<li>问：大于75？<br>\n答：是</li>\n<li>问：大于88？<br>\n答：否</li>\n<li>问：大于82？<br>\n答：是</li>\n<li>问：大于86？<br>\n答：否</li>\n<li>问：大于84？<br>\n答：是</li>\n<li>问：大于85？<br>\n答：是</li>\n</ul>\n<p>最终答案锁定，大于85并且不大于86，即<code>86</code>。</p>\n<blockquote>\n<p>连续将满足条件的值等分，直到找到正确答案，这就是二分法。<br>\n这个算法的本身就是递归的定义，也可以用递归来实现</p>\n</blockquote>\n<ul>\n<li>如果上下限相同，那么就是数字所在的位置，返回；</li>\n<li>否则找到两者的中间点，也就是上下限的平均值，查找数字在中间点的左侧还是右侧，然后继续查找数字所在的那半部分</li>\n</ul>\n<p>下面实现一个二分法查找，返回查找目标数字所在序列的位置，下标。</p>\n<pre><code class=\"language-python\">#!/usr/bin/python\n'''\n二分法查找\nsequence 查找的序列，范围\nnumber   查找目标\nlower    下限\nupper    上限    \n'''\ndef search(sequence, number, lower, upper):\n\tif lower == upper:\n\t\tassert number == sequence[upper]\n\t\treturn upper\n\telse:\n\t\tmiddle = (lower + upper) // 2 #找到两者的中间点\n\t\tif number &gt; sequence[middle]: \n\t\t\t#如果在中间点的右侧，就在middle+1 ～ upper的范围内继续找\n\t\t\treturn search(sequence, number, middle+1, upper)\n\t\telse:\n\t\t\t#如果在中间点的左侧，就在lower～middle的范围继续找\n\t\t\treturn search(sequence, number, lower, middle)\t\t\t\n#初始化一个1～100的列表\nseq = []\nfor x in xrange(1,101):\n\tseq.append(x)\nprint search(seq, 86, 0, 100)\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"6196ffd50af28a00012bf215","plaintext":"先来玩个数字游戏，我从1～100中选一个整数，你来猜中这个数字。\n\n如果你运气好的话可能十几次就猜中了，也可能是耐心的提问了我100次后。\n\n但其实你只需要提问7次就可以找到答案。\n\n举个例子，假设我选的数字是86。\n\n * 问：这个数是否大于50？\n   答：是\n * 问：大于75？\n   答：是\n * 问：大于88？\n   答：否\n * 问：大于82？\n   答：是\n * 问：大于86？\n   答：否\n * 问：大于84？\n   答：是\n * 问：大于85？\n   答：是\n\n最终答案锁定，大于85并且不大于86，即86。\n\n> 连续将满足条件的值等分，直到找到正确答案，这就是二分法。\n这个算法的本身就是递归的定义，也可以用递归来实现\n\n\n * 如果上下限相同，那么就是数字所在的位置，返回；\n * 否则找到两者的中间点，也就是上下限的平均值，查找数字在中间点的左侧还是右侧，然后继续查找数字所在的那半部分\n\n下面实现一个二分法查找，返回查找目标数字所在序列的位置，下标。\n\n#!/usr/bin/python\n'''\n二分法查找\nsequence 查找的序列，范围\nnumber   查找目标\nlower    下限\nupper    上限    \n'''\ndef search(sequence, number, lower, upper):\n\tif lower == upper:\n\t\tassert number == sequence[upper]\n\t\treturn upper\n\telse:\n\t\tmiddle = (lower + upper) // 2 #找到两者的中间点\n\t\tif number > sequence[middle]: \n\t\t\t#如果在中间点的右侧，就在middle+1 ～ upper的范围内继续找\n\t\t\treturn search(sequence, number, middle+1, upper)\n\t\telse:\n\t\t\t#如果在中间点的左侧，就在lower～middle的范围继续找\n\t\t\treturn search(sequence, number, lower, middle)\t\t\t\n#初始化一个1～100的列表\nseq = []\nfor x in xrange(1,101):\n\tseq.append(x)\nprint search(seq, 86, 0, 100)","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-19 01:37:25","created_by":"1","updated_at":"2021-11-19 01:38:38","updated_by":"1","published_at":"2016-12-11 14:39:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619700590af28a00012bf222","uuid":"e4c43f3e-6976-4321-bbb8-adf0f6cd8f57","title":"Python 两个经典递归：阶乘和幂","slug":"python-liang-ge-jing-dian-di-gui-jie-cheng-he-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"**递归**简单说来就是调用自身的意思。\\n\\n来看一个幽默的定义：\\n\\n> **recursion** *\\\\ri-'k&r-zh&n\\\\\\\\* n : see recursion\\n（递归[名词]：见递归）\\n\\n## 一、计算n的阶乘\\n\\n>`n`的阶乘定义为 `n \\\\* (n-1) \\\\* (n-2) \\\\* ... \\\\* 1`。\\n\\n**使用循环实现**\\n\\n```python\\ndef factorial(n):\\n  result = n\\n  for i in range(1, n):\\n    result *= i #依次与1至n-1的数相乘\\n  return result\\n```\\n\\n> 首先，把数字`n`赋值给`result`，然后`result`依次与`1`～`n-1`的数相乘，最后返回结果。\\n\\n阶乘的数学定义：\\n- 1的阶乘是1；\\n- 大于1的数n的阶乘是n乘n-1的阶乘。\\n\\n**使用递归实现**\\n\\n```python\\ndef factorial(n):\\n  if n == 1:\\n    return 1\\n  else:\\n    return n * factorial(n-1)\\n```\\n## 二、计算幂\\n\\npython的内建函数 `pow(x, n)` 或者 `**` 运算符可以实现幂的计算。`pow(x, n)` 是 `x` 自乘 `n-1`次，例如`pow(2, 3)`是`2`乘以自身两次：`2 * 2 * 2 = 8`。\\n\\n**使用循环实现**\\n\\n```python\\ndef power(x, n):\\n  result = 1\\n  for i in range(n):\\n    result *= x\\n  return result\\n```\\n\\n**使用递归实现**\\n\\n- 对于任意数字`x`来说，`power(x, 0)`是`1`；\\n- 对于任何大于`0`的数来说，`power(x, n)`是`x`乘以`(x, n-1)`的结果。\\n\\n```python\\ndef power(x, n):\\n  if n == 0:\\n    return 1\\n  else:\\n    return x * power(x, n-1)\\n```\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p><strong>递归</strong>简单说来就是调用自身的意思。</p>\n<p>来看一个幽默的定义：</p>\n<blockquote>\n<p><strong>recursion</strong> <em>\\ri-'k&amp;r-zh&amp;n\\</em> n : see recursion<br>\n（递归[名词]：见递归）</p>\n</blockquote>\n<h2 id=\"%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97n%E7%9A%84%E9%98%B6%E4%B9%98\">一、计算n的阶乘</h2>\n<blockquote>\n<p><code>n</code>的阶乘定义为 <code>n \\* (n-1) \\* (n-2) \\* ... \\* 1</code>。</p>\n</blockquote>\n<p><strong>使用循环实现</strong></p>\n<pre><code class=\"language-python\">def factorial(n):\n  result = n\n  for i in range(1, n):\n    result *= i #依次与1至n-1的数相乘\n  return result\n</code></pre>\n<blockquote>\n<p>首先，把数字<code>n</code>赋值给<code>result</code>，然后<code>result</code>依次与<code>1</code>～<code>n-1</code>的数相乘，最后返回结果。</p>\n</blockquote>\n<p>阶乘的数学定义：</p>\n<ul>\n<li>1的阶乘是1；</li>\n<li>大于1的数n的阶乘是n乘n-1的阶乘。</li>\n</ul>\n<p><strong>使用递归实现</strong></p>\n<pre><code class=\"language-python\">def factorial(n):\n  if n == 1:\n    return 1\n  else:\n    return n * factorial(n-1)\n</code></pre>\n<h2 id=\"%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E5%B9%82\">二、计算幂</h2>\n<p>python的内建函数 <code>pow(x, n)</code> 或者 <code>**</code> 运算符可以实现幂的计算。<code>pow(x, n)</code> 是 <code>x</code> 自乘 <code>n-1</code>次，例如<code>pow(2, 3)</code>是<code>2</code>乘以自身两次：<code>2 * 2 * 2 = 8</code>。</p>\n<p><strong>使用循环实现</strong></p>\n<pre><code class=\"language-python\">def power(x, n):\n  result = 1\n  for i in range(n):\n    result *= x\n  return result\n</code></pre>\n<p><strong>使用递归实现</strong></p>\n<ul>\n<li>对于任意数字<code>x</code>来说，<code>power(x, 0)</code>是<code>1</code>；</li>\n<li>对于任何大于<code>0</code>的数来说，<code>power(x, n)</code>是<code>x</code>乘以<code>(x, n-1)</code>的结果。</li>\n</ul>\n<pre><code class=\"language-python\">def power(x, n):\n  if n == 0:\n    return 1\n  else:\n    return x * power(x, n-1)\n</code></pre>\n<!--kg-card-end: markdown-->","comment_id":"619700590af28a00012bf222","plaintext":"递归简单说来就是调用自身的意思。\n\n来看一个幽默的定义：\n\n> recursion \\ri-'k&r-zh&n\\ n : see recursion\n（递归[名词]：见递归）\n\n\n一、计算n的阶乘\n> n的阶乘定义为 n \\* (n-1) \\* (n-2) \\* ... \\* 1。\n\n\n使用循环实现\n\ndef factorial(n):\n  result = n\n  for i in range(1, n):\n    result *= i #依次与1至n-1的数相乘\n  return result\n\n\n> 首先，把数字n赋值给result，然后result依次与1～n-1的数相乘，最后返回结果。\n\n\n阶乘的数学定义：\n\n * 1的阶乘是1；\n * 大于1的数n的阶乘是n乘n-1的阶乘。\n\n使用递归实现\n\ndef factorial(n):\n  if n == 1:\n    return 1\n  else:\n    return n * factorial(n-1)\n\n\n二、计算幂\npython的内建函数 pow(x, n) 或者 ** 运算符可以实现幂的计算。pow(x, n) 是 x 自乘 n-1次，例如pow(2, 3)是2\n乘以自身两次：2 * 2 * 2 = 8。\n\n使用循环实现\n\ndef power(x, n):\n  result = 1\n  for i in range(n):\n    result *= x\n  return result\n\n\n使用递归实现\n\n * 对于任意数字x来说，power(x, 0)是1；\n * 对于任何大于0的数来说，power(x, n)是x乘以(x, n-1)的结果。\n\ndef power(x, n):\n  if n == 0:\n    return 1\n  else:\n    return x * power(x, n-1)","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-19 01:39:37","created_by":"1","updated_at":"2021-11-19 01:41:15","updated_by":"1","published_at":"2016-11-06 10:06:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619a6a1ceff3f40001c5e92f","uuid":"67213f41-875e-457c-a00c-999921c4856e","title":"几道Java面试题","slug":"ji-dao-java-mian-shi-ti","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"code\",{\"code\":\"// 非静态成员变量j的属性值会重复利用，不会累加\\n// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\\\"prototype\\\")\\n@Controller\\n@RequestMapping(\\\"/test\\\")\\npublic class IndexController{\\n\\tprivate static int i = 0;\\n\\tprivate int j = 0;\\n\\tpublic String test(){\\n\\t\\tSystem.out.println((i++) + \\\"|\\\" + (j++));\\n\\t\\treturn \\\"test\\\";\\n\\t}\\n}\\n\\n\",\"language\":\"java\"}]],\"markups\":[[\"code\"],[\"a\",[\"href\",\"https://segmentfault.com/a/1190000010107964\"]],[\"a\",[\"href\",\"https://my.oschina.net/chuibilong/blog/638950\"]],[\"a\",[\"href\",\"https://blog.csdn.net/kakaxi_77/article/details/46007239\"]],[\"a\",[\"href\",\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\"]],[\"a\",[\"href\",\"https://blog.csdn.net/xlgen157387/article/details/40071651\"]],[\"strong\"]],\"sections\":[[1,\"h3\",[[0,[],0,\"数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？\"]]],[3,\"ul\",[[[0,[],0,\"检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。\"]]]],[1,\"h3\",[[0,[],0,\"Struts2和SpringMVC的区别？\"]]],[3,\"ul\",[[[0,[],0,\"Struts2入口是\"],[0,[0],1,\"Filter\"],[0,[],0,\"，SpringMVC是\"],[0,[0],1,\"Servlet\"]],[[0,[],0,\"Spring MVC是基于方法的设计，而Struts2是基于类\"]],[[0,[],0,\"Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的\"]],[[0,[],0,\"Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式\"]]]],[1,\"h3\",[[0,[],0,\"Spring MVC的Controller是单例的吗，有什么影响吗？\"]]],[3,\"ul\",[[[0,[],0,\"Spring MVC的controller是单例的\"]],[[0,[],0,\"如果在controller中定义了非静态成员变量，会导致属性重复使用\"]]]],[10,0],[1,\"h3\",[[0,[],0,\"MyBatis如何防止sql注入？\"]]],[1,\"p\",[[0,[],0,\"Mybatis中的\"],[0,[0],1,\"#{}\"],[0,[],0,\"和\"],[0,[0],1,\"${}\"],[0,[],0,\"的区别\"]]],[3,\"ul\",[[[0,[0],1,\"#{}\"],[0,[],0,\"使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by \\\"111\\\", 如果传入的值是id，则解析成的sql为order by \\\"id\\\"\"]],[[0,[0],1,\"${}\"],[0,[],0,\"将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id\"]],[[0,[0],1,\"#{}\"],[0,[],0,\"方式能够很大程度防止sql注入\"]],[[0,[0],1,\"${}\"],[0,[],0,\"方式无法防止Sql注入\"]],[[0,[0],1,\"${}\"],[0,[],0,\"方式一般用于传入数据库对象，例如传入表名\"]],[[0,[],0,\"尽量使用\"],[0,[0],1,\"#{}\"],[0,[],0,\"代替\"],[0,[0],1,\"${}\"]],[[0,[],0,\"参考文献\"]],[[0,[1],1,\"https://segmentfault.com/a/1190000010107964\"]],[[0,[2],1,\"https://my.oschina.net/chuibilong/blog/638950\"]],[[0,[3],1,\"https://blog.csdn.net/kakaxi_77/article/details/46007239\"]]]],[1,\"h3\",[[0,[],0,\"Hibernate一级缓存、二级缓存？\"]]],[1,\"p\",[[0,[],0,\"一级缓存\"]]],[3,\"ul\",[[[0,[],0,\"第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session 对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。\"]],[[0,[],0,\"如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭 session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。\"]]]],[1,\"p\",[[0,[],0,\"二级缓存\"]]],[3,\"ul\",[[[0,[],0,\"第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。\"]],[[0,[],0,\"第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。\"]],[[0,[],0,\"任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给 Hibernate 提供一个缓存实现的解决方法。\"]]]],[1,\"p\",[[0,[],0,\"参考文献\"]]],[3,\"ul\",[[[0,[4],1,\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\"]],[[0,[5],1,\"https://blog.csdn.net/xlgen157387/article/details/40071651\"]]]],[1,\"h3\",[[0,[],0,\"使用过哪些socket框架？\"]]],[1,\"h2\",[[0,[],0,\"延伸\"]]],[1,\"h3\",[[0,[],0,\"Spring MVC 请求-响应流程\"]]],[3,\"ul\",[[[0,[],0,\"1.浏览器发送请求的url以及其他信息\"]],[[0,[],0,\"2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。\"]],[[0,[],0,\"3.确定合适的控制器后，将请求发送给选中的控制器\"]],[[0,[],0,\"4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet\"]],[[0,[],0,\"5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）\"]],[[0,[],0,\"6.DispatcherServlet匹配到对应的视图实现\"]],[[0,[],0,\"7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端\"]]]],[1,\"h3\",[[0,[],0,\"struts2 工作流程\"]]],[1,\"h3\",[[0,[],0,\"http协议无状态\"]]],[1,\"p\",[[0,[],0,\"对\"],[0,[6],1,\"无状态\"],[0,[],0,\"的理解\"]]],[3,\"ul\",[[[0,[],0,\"协议对于事务处理没有记忆能力\"]],[[0,[],0,\"对同一个url请求没有上下文关系\"]],[[0,[],0,\"每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况\"]],[[0,[],0,\"服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器\"]],[[0,[],0,\"人生若只如初见\"]]]],[1,\"p\",[[0,[6],1,\"状态\"],[0,[],0,\"的含义：客户端和服务器在某次会话中产生的数据。\"]]],[1,\"p\",[[0,[6],1,\"无状态\"],[0,[],0,\"就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。\"]]],[1,\"p\",[[0,[],0,\"在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。\"]]],[1,\"p\",[[0,[],0,\"知乎上有个哥们儿举的一个例子：\"]]],[1,\"blockquote\",[[0,[6],1,\"有状态：\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的啥？\"]]],[1,\"blockquote\",[[0,[],0,\"B：吃的大盘鸡。\"]]],[1,\"blockquote\",[[0,[],0,\"A：味道怎么样呀？\"]]],[1,\"blockquote\",[[0,[],0,\"B：还不错，挺好吃的。\"]]],[1,\"blockquote\",[[0,[6],1,\"无状态：\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的啥？\"]]],[1,\"blockquote\",[[0,[],0,\"B：吃的大盘鸡。\"]]],[1,\"blockquote\",[[0,[],0,\"A：味道怎么样呀？\"]]],[1,\"blockquote\",[[0,[],0,\"B：？？？啊？啥？啥味道怎么样？\"]]],[1,\"blockquote\",[[0,[],0,\"所以需要cookie这种东西：\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的啥？\"]]],[1,\"blockquote\",[[0,[],0,\"B：吃的大盘鸡。\"]]],[1,\"blockquote\",[[0,[],0,\"A：你今天中午吃的大盘鸡味道怎么样呀？\"]]],[1,\"blockquote\",[[0,[],0,\"B：还不错，挺好吃的。\"]]]],\"ghostVersion\":\"4.0\"}","html":"<h3 id=\"%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A0%81%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A0%81%E4%B8%80%E8%87%B4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8Cget%E8%AF%B7%E6%B1%82%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E4%B9%B1%E7%A0%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F\">数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？</h3><ul><li>检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。</li></ul><h3 id=\"struts2%E5%92%8Cspringmvc%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">Struts2和SpringMVC的区别？</h3><ul><li>Struts2入口是<code>Filter</code>，SpringMVC是<code>Servlet</code></li><li>Spring MVC是基于方法的设计，而Struts2是基于类</li><li>Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的</li><li>Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式</li></ul><h3 id=\"spring-mvc%E7%9A%84controller%E6%98%AF%E5%8D%95%E4%BE%8B%E7%9A%84%E5%90%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%E5%90%97%EF%BC%9F\">Spring MVC的Controller是单例的吗，有什么影响吗？</h3><ul><li>Spring MVC的controller是单例的</li><li>如果在controller中定义了非静态成员变量，会导致属性重复使用</li></ul><pre><code class=\"language-java\">// 非静态成员变量j的属性值会重复利用，不会累加\n// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\"prototype\")\n@Controller\n@RequestMapping(\"/test\")\npublic class IndexController{\n\tprivate static int i = 0;\n\tprivate int j = 0;\n\tpublic String test(){\n\t\tSystem.out.println((i++) + \"|\" + (j++));\n\t\treturn \"test\";\n\t}\n}\n\n</code></pre><h3 id=\"mybatis%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%EF%BC%9F\">MyBatis如何防止sql注入？</h3><p>Mybatis中的<code>#{}</code>和<code>${}</code>的区别</p><ul><li><code>#{}</code>使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by \"111\", 如果传入的值是id，则解析成的sql为order by \"id\"</li><li><code>${}</code>将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id,  如果传入的值是id，则解析成的sql为order by id</li><li><code>#{}</code>方式能够很大程度防止sql注入</li><li><code>${}</code>方式无法防止Sql注入</li><li><code>${}</code>方式一般用于传入数据库对象，例如传入表名</li><li>尽量使用<code>#{}</code>代替<code>${}</code></li><li>参考文献</li><li><a href=\"https://segmentfault.com/a/1190000010107964\">https://segmentfault.com/a/1190000010107964</a></li><li><a href=\"https://my.oschina.net/chuibilong/blog/638950\">https://my.oschina.net/chuibilong/blog/638950</a></li><li><a href=\"https://blog.csdn.net/kakaxi_77/article/details/46007239\">https://blog.csdn.net/kakaxi_77/article/details/46007239</a></li></ul><h3 id=\"hibernate%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F\">Hibernate一级缓存、二级缓存？</h3><p>一级缓存</p><ul><li>第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session 对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。</li><li>如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭 session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。</li></ul><p>二级缓存</p><ul><li>第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。</li><li>第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。</li><li>任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给 Hibernate 提供一个缓存实现的解决方法。</li></ul><p>参考文献</p><ul><li><a href=\"http://wiki.jikexueyuan.com/project/hibernate/caching.html\">http://wiki.jikexueyuan.com/project/hibernate/caching.html</a></li><li><a href=\"https://blog.csdn.net/xlgen157387/article/details/40071651\">https://blog.csdn.net/xlgen157387/article/details/40071651</a></li></ul><h3 id=\"%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9Bsocket%E6%A1%86%E6%9E%B6%EF%BC%9F\">使用过哪些socket框架？</h3><h2 id=\"%E5%BB%B6%E4%BC%B8\">延伸</h2><h3 id=\"spring-mvc-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B\">Spring MVC 请求-响应流程</h3><ul><li>1.浏览器发送请求的url以及其他信息</li><li>2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。</li><li>3.确定合适的控制器后，将请求发送给选中的控制器</li><li>4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet</li><li>5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）</li><li>6.DispatcherServlet匹配到对应的视图实现</li><li>7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端</li></ul><h3 id=\"struts2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\">struts2 工作流程</h3><h3 id=\"http%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81\">http协议无状态</h3><p>对<strong>无状态</strong>的理解</p><ul><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见</li></ul><p><strong>状态</strong>的含义：客户端和服务器在某次会话中产生的数据。</p><p><strong>无状态</strong>就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。</p><p>在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。</p><p>知乎上有个哥们儿举的一个例子：</p><blockquote><strong>有状态：</strong></blockquote><blockquote>A：你今天中午吃的啥？</blockquote><blockquote>B：吃的大盘鸡。</blockquote><blockquote>A：味道怎么样呀？</blockquote><blockquote>B：还不错，挺好吃的。</blockquote><blockquote><strong>无状态：</strong></blockquote><blockquote>A：你今天中午吃的啥？</blockquote><blockquote>B：吃的大盘鸡。</blockquote><blockquote>A：味道怎么样呀？</blockquote><blockquote>B：？？？啊？啥？啥味道怎么样？</blockquote><blockquote>所以需要cookie这种东西：</blockquote><blockquote>A：你今天中午吃的啥？</blockquote><blockquote>B：吃的大盘鸡。</blockquote><blockquote>A：你今天中午吃的大盘鸡味道怎么样呀？</blockquote><blockquote>B：还不错，挺好吃的。</blockquote>","comment_id":"619a6a1ceff3f40001c5e92f","plaintext":"数据库编码和服务端代码编码一致情况下，Get请求可能产生乱码的原因及解决办法？\n * 检查中间键tomcat、jetty对get请求的解码格式，默认是iso-8859-1的话，可能会产生乱码，解决办法修改中间键配置文件中URIEncoding解码格式。\n\nStruts2和SpringMVC的区别？\n * Struts2入口是Filter，SpringMVC是Servlet\n * Spring MVC是基于方法的设计，而Struts2是基于类\n * Spring MVC的方法之间基本上是独立的，独享request和response，而Struts2所有Action变量是共享的\n * Struts2有自己的interceptor机制，Spring MVC用的是独立的AOP方式\n\nSpring MVC的Controller是单例的吗，有什么影响吗？\n * Spring MVC的controller是单例的\n * 如果在controller中定义了非静态成员变量，会导致属性重复使用\n\n// 非静态成员变量j的属性值会重复利用，不会累加\n// 解决办法：不要定义非静态成员变量，或者使用多例 @Scope(\"prototype\")\n@Controller\n@RequestMapping(\"/test\")\npublic class IndexController{\n\tprivate static int i = 0;\n\tprivate int j = 0;\n\tpublic String test(){\n\t\tSystem.out.println((i++) + \"|\" + (j++));\n\t\treturn \"test\";\n\t}\n}\n\n\n\nMyBatis如何防止sql注入？\nMybatis中的#{}和${}的区别\n\n * #{}使用的是PreparedStatement，会有类型转换, 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by\n   #user_id#，如果传入的值是111,那么解析成sql时的值为order by \"111\", 如果传入的值是id，则解析成的sql为order by\n   \"id\"\n * ${}将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by\n   user_id,  如果传入的值是id，则解析成的sql为order by id\n * #{}方式能够很大程度防止sql注入\n * ${}方式无法防止Sql注入\n * ${}方式一般用于传入数据库对象，例如传入表名\n * 尽量使用#{}代替${}\n * 参考文献\n * https://segmentfault.com/a/1190000010107964\n * https://my.oschina.net/chuibilong/blog/638950\n * https://blog.csdn.net/kakaxi_77/article/details/46007239\n\nHibernate一级缓存、二级缓存？\n一级缓存\n\n * 第一级缓存是 Session 缓存并且是一种强制性的缓存，所有的要求都必须通过它。Session\n   对象在它自己的权利之下，在将它提交给数据库之前保存一个对象。\n * 如果你对一个对象发出多个更新，Hibernate 会尝试尽可能长地延迟更新来减少发出的 SQL 更新语句的数目。如果你关闭\n   session,所有缓存的对象丢失，或是存留，或是在数据库中被更新。\n\n二级缓存\n\n * 第二级缓存是一种可选择的缓存并且第一级缓存在任何想要在第二级缓存中找到一个对象前将总是被询问。\n * 第二级缓存可以在每一个类和每一个集合的基础上被安装，并且它主要负责跨会话缓存对象。\n * 任何第三方缓存可以和 Hibernate 一起使用。org.hibernate.cache.CacheProvider 接口被提供，它必须实现来给\n   Hibernate 提供一个缓存实现的解决方法。\n\n参考文献\n\n * http://wiki.jikexueyuan.com/project/hibernate/caching.html\n * https://blog.csdn.net/xlgen157387/article/details/40071651\n\n使用过哪些socket框架？\n延伸\nSpring MVC 请求-响应流程\n * 1.浏览器发送请求的url以及其他信息\n * 2.DispatcherServlet先会查询处理器映射（handler mapping），来确定发送给哪个控制器。\n * 3.确定合适的控制器后，将请求发送给选中的控制器\n * 4.控制器完成逻辑处理后，将模型数据打包，并标示出输出的视图名，将请求连同模型和视图名发送回DispatcherServlet\n * 5.DispatcherServlet使用视图解析器（view resolver）来将逻辑视图名匹配一个特定的视图实现（jsp或其它）\n * 6.DispatcherServlet匹配到对应的视图实现\n * 7.视图使用模型数据渲染输出，这个输出通过响应对象传递给客户端\n\nstruts2 工作流程\nhttp协议无状态\n对无状态的理解\n\n * 协议对于事务处理没有记忆能力\n * 对同一个url请求没有上下文关系\n * 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况\n * 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器\n * 人生若只如初见\n\n状态的含义：客户端和服务器在某次会话中产生的数据。\n\n无状态就意味着，这些数据不会被保留，但是通过增加cookie和session机制，现在的网络请求其实是有状态的。\n\n在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话。\n\n知乎上有个哥们儿举的一个例子：\n\n> 有状态：\n> A：你今天中午吃的啥？\n> B：吃的大盘鸡。\n> A：味道怎么样呀？\n> B：还不错，挺好吃的。\n> 无状态：\n> A：你今天中午吃的啥？\n> B：吃的大盘鸡。\n> A：味道怎么样呀？\n> B：？？？啊？啥？啥味道怎么样？\n> 所以需要cookie这种东西：\n> A：你今天中午吃的啥？\n> B：吃的大盘鸡。\n> A：你今天中午吃的大盘鸡味道怎么样呀？\n> B：还不错，挺好吃的。","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-21 15:47:40","created_by":"1","updated_at":"2021-11-21 15:49:58","updated_by":"1","published_at":"2018-04-10 16:00:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619a6ad5eff3f40001c5e945","uuid":"70570abd-b892-418b-aec2-0361ab07d29b","title":"Java 多线程","slug":"java-duo-xian-cheng","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[[\"soft-return\",\"\",{}]],\"cards\":[[\"code\",{\"code\":\"// 通过实现Runnable接口定义一个任务类\\npublic class TaskClass implements Runnable{\\n\\tpublic TaskClass(){\\n\\t\\n\\t}\\n\\t\\n\\tpublic void run(){\\n\\t\\t// do something...\\n\\t}\\n}\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"// 创建一个任务、一个线程以及启动线程的步骤\\npublic class Client{\\n\\tpublic void someMethod(){\\n\\t\\t//  创建一个TaskClass实例\\n\\t\\tTaskClass task = new TaskClass();\\n\\t\\t// 创建一个线程\\n\\t\\tThread thread = new Thread(task);\\n\\t\\t// 启动线程\\n\\t\\tthread.start();\\n\\t}\\n}\\n\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"package org.nocoder.thread;\\n\\n/**\\n * 创建三个任务以及三个运行这些任务的线程:\\n * 第一个任务打印字母a100次\\n * 第二个任务打印字母b100次\\n * 第三个任务打印1到100的整数\\n *\\n * @author jason\\n * @date 18/4/3.\\n */\\npublic class TaskThreadDemo {\\n    public static void main(String[] args){\\n        // 创建任务类\\n        Runnable printA = new PrintChar('a', 100);\\n        Runnable printB = new PrintChar('b', 100);\\n        Runnable print100 = new PrintNumber(100);\\n        // 创建线程\\n        Thread threadPrintA = new Thread(printA);\\n        Thread threadPrintB = new Thread(printB);\\n        Thread threadPrint100 = new Thread(print100);\\n        // 启动线程\\n        threadPrintA.start();\\n        threadPrintB.start();\\n        threadPrint100.start();\\n    }\\n\\n}\\n\\n/**\\n * 打印字符任务类\\n */\\nclass PrintChar implements Runnable {\\n    /**\\n     * 需要打印的字符\\n     */\\n    private char charToPrint;\\n\\n    /**\\n     * 需要打印的次数\\n     */\\n    private int times;\\n\\n    public PrintChar(char c, int t) {\\n        charToPrint = c;\\n        times = t;\\n    }\\n\\n    public void run() {\\n        for (int i = 0; i < times; i++) {\\n            System.out.print(charToPrint);\\n        }\\n    }\\n}\\n\\n/**\\n * 打印数字任务类\\n */\\nclass PrintNumber implements Runnable {\\n    /**\\n     * 需要打印的最大值\\n     */\\n    private int lastNum;\\n\\n    public PrintNumber(int n) {\\n        lastNum = n;\\n    }\\n\\n    public void run() {\\n        for (int i = 1; i <= lastNum; i++) {\\n            System.out.print(\\\" \\\" + i);\\n        }\\n    }\\n\\n\\n}\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"package org.nocoder.thread;\\n\\n/**\\n * @author jason\\n * @date 18/4/3.\\n */\\npublic class CustomeThread extends Thread {\\n    public CustomeThread(){\\n\\n    }\\n\\n    public void run(){\\n        System.out.println(Thread.currentThread().getName() + \\\": do something...\\\");\\n    }\\n}\\n\\nclass Client{\\n    public static void main(String[] args){\\n        Thread thread1 = new CustomeThread();\\n        thread1.setName(\\\"线程1\\\");\\n        thread1.start();\\n\\n        Thread thread2 = new CustomeThread();\\n        thread2.setName(\\\"线程2\\\");\\n        thread2.start();\\n    }\\n\\n}\\n\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"Thread.yield();\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"// 休眠 1ms\\ntry{\\n\\t...\\n\\tThread.sleep(1);\\n}catch(InterruptedException ex){\\n\\t// do someting...\\n}\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"package org.nocoder.thread;\\n\\n/**\\n * @author jason\\n * @date 18/4/6.\\n */\\npublic class YieldTest {\\n    public static void main(String[] args) {\\n        Thread t = new Thread(new Runnable() {\\n            public void run() {\\n                for (int i = 1; i <= 10; i++) {\\n                    System.out.print(i + \\\" \\\");\\n                }\\n                System.out.println();\\n            }\\n        });\\n        t.start();\\n        try {\\n        \\t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\\n            t.join();\\n        } catch (InterruptedException e) {\\n            e.printStackTrace();\\n        }\\n        for (int j = 11; j <= 20; j++) {\\n            System.out.print(j + \\\" \\\");\\n        }\\n        System.out.println();\\n    }\\n}\\n\\n\",\"language\":\"java\"}],[\"code\",{\"code\":\"1 2 3 4 5 6 7 8 9 10 \\n11 12 13 14 15 16 17 18 19 20 \\n\\n\"}],[\"code\",{\"code\":\"11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \\n18 19 20 \\n\"}]],\"markups\":[[\"strong\"],[\"code\"]],\"sections\":[[1,\"blockquote\",[[0,[],0,\"Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。\"]]],[1,\"h2\",[[0,[],0,\"线程的概念\"]]],[1,\"blockquote\",[[0,[0],1,\"线程\"],[0,[],0,\"是指一个任务从头到尾的执行流程。\"]]],[1,\"p\",[[0,[],0,\"一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。\"]]],[1,\"p\",[[0,[],0,\"多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。\"]]],[1,\"p\",[[0,[],0,\"在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。\"]]],[1,\"p\",[[0,[],0,\"在Java中，每个任务都是\"],[0,[1],1,\"Runnable\"],[0,[],0,\"接口的一个实例，也成为\"],[0,[1],1,\"可运行对象（runnable object）\"],[0,[],0,\"。\"]]],[1,\"h2\",[[0,[],0,\"创建任务和线程\"]]],[1,\"p\",[[0,[],0,\"一个任务类必须实现Runnable接口。任务必须从线程运行。\"],[1,[],0,0],[0,[],0,\"任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。\"]]],[10,0],[10,1],[1,\"h4\",[[0,[],0,\"编程练习\"]]],[1,\"blockquote\",[[0,[],0,\"创建三个任务以及三个运行这些任务的线程:\"]]],[1,\"blockquote\",[[0,[],0,\"第一个任务打印字母a100次\"]]],[1,\"blockquote\",[[0,[],0,\"第二个任务打印字母b100次\"]]],[1,\"blockquote\",[[0,[],0,\"第三个任务打印1到100的整数\"]]],[10,2],[1,\"blockquote\",[[0,[],0,\"任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。\"]]],[1,\"h2\",[[0,[],0,\"Thread类\"]]],[1,\"p\",[[0,[],0,\"Thread类包含为任务而创建的线程的构造方法，以及控制线程的方法。\"]]],[1,\"p\",[[0,[],0,\"Thread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。\"]]],[10,3],[1,\"p\",[[0,[],0,\"使用\"],[0,[1],1,\"yield()\"],[0,[],0,\"方法为其他线程临时让出CPU时间。\"]]],[10,4],[1,\"p\",[[0,[],0,\"使用\"],[0,[1],1,\"sleep(long mills)\"],[0,[],0,\"可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。\"]]],[10,5],[1,\"p\",[[0,[],0,\"sleep方法可能抛出一个\"],[0,[1],1,\"InterruptedException\"],[0,[],0,\"，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。\"]]],[1,\"p\",[[0,[],0,\"使用\"],[0,[1],1,\"join()\"],[0,[],0,\"方法使用一个线程等待另一个线程的结束。\"]]],[10,6],[1,\"p\",[[0,[],0,\"输出结果：\"]]],[10,7],[1,\"p\",[[0,[],0,\"如果不加join()方法的输出结果顺序不固定\"]]],[10,8]],\"ghostVersion\":\"4.0\"}","html":"<blockquote>Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。</blockquote><h2 id=\"%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\">线程的概念</h2><blockquote><strong>线程</strong>是指一个任务从头到尾的执行流程。</blockquote><p>一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。</p><p>多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。</p><p>在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。</p><p>在Java中，每个任务都是<code>Runnable</code>接口的一个实例，也成为<code>可运行对象（runnable object）</code>。</p><h2 id=\"%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E5%92%8C%E7%BA%BF%E7%A8%8B\">创建任务和线程</h2><p>一个任务类必须实现Runnable接口。任务必须从线程运行。<br>任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。</p><pre><code class=\"language-java\">// 通过实现Runnable接口定义一个任务类\npublic class TaskClass implements Runnable{\n\tpublic TaskClass(){\n\t\n\t}\n\t\n\tpublic void run(){\n\t\t// do something...\n\t}\n}\n</code></pre><pre><code class=\"language-java\">// 创建一个任务、一个线程以及启动线程的步骤\npublic class Client{\n\tpublic void someMethod(){\n\t\t//  创建一个TaskClass实例\n\t\tTaskClass task = new TaskClass();\n\t\t// 创建一个线程\n\t\tThread thread = new Thread(task);\n\t\t// 启动线程\n\t\tthread.start();\n\t}\n}\n\n</code></pre><h4 id=\"%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0\">编程练习</h4><blockquote>创建三个任务以及三个运行这些任务的线程:</blockquote><blockquote>第一个任务打印字母a100次</blockquote><blockquote>第二个任务打印字母b100次</blockquote><blockquote>第三个任务打印1到100的整数</blockquote><pre><code class=\"language-java\">package org.nocoder.thread;\n\n/**\n * 创建三个任务以及三个运行这些任务的线程:\n * 第一个任务打印字母a100次\n * 第二个任务打印字母b100次\n * 第三个任务打印1到100的整数\n *\n * @author jason\n * @date 18/4/3.\n */\npublic class TaskThreadDemo {\n    public static void main(String[] args){\n        // 创建任务类\n        Runnable printA = new PrintChar('a', 100);\n        Runnable printB = new PrintChar('b', 100);\n        Runnable print100 = new PrintNumber(100);\n        // 创建线程\n        Thread threadPrintA = new Thread(printA);\n        Thread threadPrintB = new Thread(printB);\n        Thread threadPrint100 = new Thread(print100);\n        // 启动线程\n        threadPrintA.start();\n        threadPrintB.start();\n        threadPrint100.start();\n    }\n\n}\n\n/**\n * 打印字符任务类\n */\nclass PrintChar implements Runnable {\n    /**\n     * 需要打印的字符\n     */\n    private char charToPrint;\n\n    /**\n     * 需要打印的次数\n     */\n    private int times;\n\n    public PrintChar(char c, int t) {\n        charToPrint = c;\n        times = t;\n    }\n\n    public void run() {\n        for (int i = 0; i &lt; times; i++) {\n            System.out.print(charToPrint);\n        }\n    }\n}\n\n/**\n * 打印数字任务类\n */\nclass PrintNumber implements Runnable {\n    /**\n     * 需要打印的最大值\n     */\n    private int lastNum;\n\n    public PrintNumber(int n) {\n        lastNum = n;\n    }\n\n    public void run() {\n        for (int i = 1; i &lt;= lastNum; i++) {\n            System.out.print(\" \" + i);\n        }\n    }\n\n\n}\n</code></pre><blockquote>任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。</blockquote><h2 id=\"thread%E7%B1%BB\">Thread类</h2><p>Thread类包含为任务而创建的线程的构造方法，以及控制线程的方法。</p><p>Thread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。</p><pre><code class=\"language-java\">package org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/3.\n */\npublic class CustomeThread extends Thread {\n    public CustomeThread(){\n\n    }\n\n    public void run(){\n        System.out.println(Thread.currentThread().getName() + \": do something...\");\n    }\n}\n\nclass Client{\n    public static void main(String[] args){\n        Thread thread1 = new CustomeThread();\n        thread1.setName(\"线程1\");\n        thread1.start();\n\n        Thread thread2 = new CustomeThread();\n        thread2.setName(\"线程2\");\n        thread2.start();\n    }\n\n}\n\n</code></pre><p>使用<code>yield()</code>方法为其他线程临时让出CPU时间。</p><pre><code class=\"language-java\">Thread.yield();\n</code></pre><p>使用<code>sleep(long mills)</code>可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。</p><pre><code class=\"language-java\">// 休眠 1ms\ntry{\n\t...\n\tThread.sleep(1);\n}catch(InterruptedException ex){\n\t// do someting...\n}\n</code></pre><p>sleep方法可能抛出一个<code>InterruptedException</code>，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。</p><p>使用<code>join()</code>方法使用一个线程等待另一个线程的结束。</p><pre><code class=\"language-java\">package org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/6.\n */\npublic class YieldTest {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 1; i &lt;= 10; i++) {\n                    System.out.print(i + \" \");\n                }\n                System.out.println();\n            }\n        });\n        t.start();\n        try {\n        \t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int j = 11; j &lt;= 20; j++) {\n            System.out.print(j + \" \");\n        }\n        System.out.println();\n    }\n}\n\n</code></pre><p>输出结果：</p><pre><code>1 2 3 4 5 6 7 8 9 10 \n11 12 13 14 15 16 17 18 19 20 \n\n</code></pre><p>如果不加join()方法的输出结果顺序不固定</p><pre><code>11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \n18 19 20 \n</code></pre>","comment_id":"619a6ad5eff3f40001c5e945","plaintext":"> Java的重要功能之一就是内部支持多线程-在一个程序中允许同时运行多个任务。\n线程的概念\n> 线程是指一个任务从头到尾的执行流程。\n一个Java程序中可以并发的启动多个线程，这些线程可以在多个处理器上同时运行。\n\n多线程可以使程序反应更快，交互性更强，执行效率更高，即使再单核处理器的系统上，多线程程序的运行速度也比单线程速度更快。\n\n在单处理器系统中，多个线程共享CPU时间，称为时间分享，操作系统负责调度及分配资源给它们。CPU分配给线程的时间称为时间片，一般是几十ms，获得时间片的线程会被CPU切换执行。\n\n在Java中，每个任务都是Runnable接口的一个实例，也成为可运行对象（runnable object）。\n\n创建任务和线程\n一个任务类必须实现Runnable接口。任务必须从线程运行。\n任务就是对象。为了创建任务，必须首先为任务定义一个实现Runnable接口的类。\n\n// 通过实现Runnable接口定义一个任务类\npublic class TaskClass implements Runnable{\n\tpublic TaskClass(){\n\t\n\t}\n\t\n\tpublic void run(){\n\t\t// do something...\n\t}\n}\n\n\n// 创建一个任务、一个线程以及启动线程的步骤\npublic class Client{\n\tpublic void someMethod(){\n\t\t//  创建一个TaskClass实例\n\t\tTaskClass task = new TaskClass();\n\t\t// 创建一个线程\n\t\tThread thread = new Thread(task);\n\t\t// 启动线程\n\t\tthread.start();\n\t}\n}\n\n\n\n编程练习\n> 创建三个任务以及三个运行这些任务的线程:\n> 第一个任务打印字母a100次\n> 第二个任务打印字母b100次\n> 第三个任务打印1到100的整数\npackage org.nocoder.thread;\n\n/**\n * 创建三个任务以及三个运行这些任务的线程:\n * 第一个任务打印字母a100次\n * 第二个任务打印字母b100次\n * 第三个任务打印1到100的整数\n *\n * @author jason\n * @date 18/4/3.\n */\npublic class TaskThreadDemo {\n    public static void main(String[] args){\n        // 创建任务类\n        Runnable printA = new PrintChar('a', 100);\n        Runnable printB = new PrintChar('b', 100);\n        Runnable print100 = new PrintNumber(100);\n        // 创建线程\n        Thread threadPrintA = new Thread(printA);\n        Thread threadPrintB = new Thread(printB);\n        Thread threadPrint100 = new Thread(print100);\n        // 启动线程\n        threadPrintA.start();\n        threadPrintB.start();\n        threadPrint100.start();\n    }\n\n}\n\n/**\n * 打印字符任务类\n */\nclass PrintChar implements Runnable {\n    /**\n     * 需要打印的字符\n     */\n    private char charToPrint;\n\n    /**\n     * 需要打印的次数\n     */\n    private int times;\n\n    public PrintChar(char c, int t) {\n        charToPrint = c;\n        times = t;\n    }\n\n    public void run() {\n        for (int i = 0; i < times; i++) {\n            System.out.print(charToPrint);\n        }\n    }\n}\n\n/**\n * 打印数字任务类\n */\nclass PrintNumber implements Runnable {\n    /**\n     * 需要打印的最大值\n     */\n    private int lastNum;\n\n    public PrintNumber(int n) {\n        lastNum = n;\n    }\n\n    public void run() {\n        for (int i = 1; i <= lastNum; i++) {\n            System.out.print(\" \" + i);\n        }\n    }\n\n\n}\n\n\n> 任务中的run()方法指名如何完成这个任务，Java虚拟机通过调用任务的run()方法执行任务，无需程序员特意调用，直接调用run()方法只是在同一个线程中执行该方法，而没有新线程被启动。\nThread类\nThread类包含为任务而创建的线程的构造方法，以及控制线程的方法。\n\nThread类实现了Runnable接口，所以可以定一个Thread的扩展类，实现Runnable的run()方法，然后客户端类创建这个类的一个对象，调用start()启动线程。\n\npackage org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/3.\n */\npublic class CustomeThread extends Thread {\n    public CustomeThread(){\n\n    }\n\n    public void run(){\n        System.out.println(Thread.currentThread().getName() + \": do something...\");\n    }\n}\n\nclass Client{\n    public static void main(String[] args){\n        Thread thread1 = new CustomeThread();\n        thread1.setName(\"线程1\");\n        thread1.start();\n\n        Thread thread2 = new CustomeThread();\n        thread2.setName(\"线程2\");\n        thread2.start();\n    }\n\n}\n\n\n\n使用yield()方法为其他线程临时让出CPU时间。\n\nThread.yield();\n\n\n使用sleep(long mills)可以将该线程设置为休眠以确保其他线程的执行，休眠时间为指定的毫秒数。\n\n// 休眠 1ms\ntry{\n\t...\n\tThread.sleep(1);\n}catch(InterruptedException ex){\n\t// do someting...\n}\n\n\nsleep方法可能抛出一个InterruptedException\n，这是一个必检异常。当一个休眠线程的interrupt()方法被调用时，就会发生这样的一个异常。\n\n使用join()方法使用一个线程等待另一个线程的结束。\n\npackage org.nocoder.thread;\n\n/**\n * @author jason\n * @date 18/4/6.\n */\npublic class YieldTest {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Runnable() {\n            public void run() {\n                for (int i = 1; i <= 10; i++) {\n                    System.out.print(i + \" \");\n                }\n                System.out.println();\n            }\n        });\n        t.start();\n        try {\n        \t  // 调用线程t的join()方法，其他线程要等待这个线程执行结束后才会执行\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        for (int j = 11; j <= 20; j++) {\n            System.out.print(j + \" \");\n        }\n        System.out.println();\n    }\n}\n\n\n\n输出结果：\n\n1 2 3 4 5 6 7 8 9 10 \n11 12 13 14 15 16 17 18 19 20 \n\n\n\n如果不加join()方法的输出结果顺序不固定\n\n11 12 13 14 15 16 17 1 2 3 4 5 6 7 8 9 10 \n18 19 20","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-21 15:50:45","created_by":"1","updated_at":"2021-11-21 15:56:24","updated_by":"1","published_at":"2019-07-03 02:57:00","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null},{"id":"619b491feff3f40001c5e961","uuid":"81c4dcb0-0acf-4b41-a8e6-787612ca9537","title":"Springboot 配置文件解密","slug":"springboot-pei-zhi-wen-jian-jie-mi","mobiledoc":"{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"写一个工具类 `EncryptUtil.java`，完成加密解密方法\\n\\n```java\\n// 加密\\npublic static String encode(String value){\\n    if(StringUtils.isNotBlank(value)){        \\n        Base64 base64 = new Base64();       \\n        return new String(base64.encode(value.getBytes()));   \\n    }    \\n    return null;\\n}\\n\\n// 解密\\npublic static String decode(String value){    \\n    if(StringUtils.isNotBlank(value)){       \\n        Base64 base64 = new Base64();        \\n        return new String(base64.decode(value.getBytes()));    \\n    }    \\n    return null;\\n}\\n```\\n\\n在配置文件`application.yml`里，使用加密后的值，加个特殊的前缀，例如`SEC@`\\n\\n```yml\\nspring:\\n  datasource:\\n    url: jdbc:mysql://192.168.0.111:3306/test\\n    username: SEC@cm9vdA==\\n    password: SEC@TXlzcWxAMTIz\\n    type: com.alibaba.druid.pool.DruidDataSource\\n    driver-class-name: com.mysql.cj.jdbc.Driver\\n```\\n\\n在`pom.xml`中添加`jasypt-spring-boot-starter`依赖\\n\\n```xml\\n<dependency>\\n    <groupId>com.github.ulisesbocchio</groupId>    \\n    <artifactId>jasypt-spring-boot-starter</artifactId>\\n    <version>2.1.0</version>\\n</dependency>\\n```\\n\\n写一个`Configuration`  bean，实现`jasypt`提供的`EncryptablePropertyResolver`接口，在`resolvePropertyValue(String value)`方法中将配置文件中前缀为`SEC@`的加了密的value截取出来，使用之前写好的解密方法进行解密。\\n\\n```java\\nimport com.swcares.attms.util.EncryptUtil;\\nimport com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.Configuration;\\n\\n@Configuration\\npublic class EncryptionPropertyConfig {\\n\\n    @Bean(name = \\\"encryptablePropertyResolver\\\")\\n    public EncryptablePropertyResolver encryptablePropertyResolver() {\\n        return new EncryptionPropertyResolver();    \\n    }    \\n    \\n    class EncryptionPropertyResolver implements EncryptablePropertyResolver {\\n        @Override        \\n        public String resolvePropertyValue(String value) {            \\n            if (value.startsWith(\\\"SEC@\\\")) {                \\n                String propertyValue = value.substring(4);               \\n                return EncryptUtil.decode(propertyValue);            \\n            }\\n            return value;        \\n        }       \\n    }\\n}\\n\\n```\\n\\n之前写过一个[Spring项目数据库密码加密](__GHOST_URL__/springxiang-mu-shu-ju-ku-mi-ma-jia-mi/)，是普通的Spring项目的实现，原理都一样，加个密再用，至少比明文密码安全一点。\\n\\nThe end.\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0],[1,\"p\",[]]],\"ghostVersion\":\"4.0\"}","html":"<!--kg-card-begin: markdown--><p>写一个工具类 <code>EncryptUtil.java</code>，完成加密解密方法</p>\n<pre><code class=\"language-java\">// 加密\npublic static String encode(String value){\n    if(StringUtils.isNotBlank(value)){        \n        Base64 base64 = new Base64();       \n        return new String(base64.encode(value.getBytes()));   \n    }    \n    return null;\n}\n\n// 解密\npublic static String decode(String value){    \n    if(StringUtils.isNotBlank(value)){       \n        Base64 base64 = new Base64();        \n        return new String(base64.decode(value.getBytes()));    \n    }    \n    return null;\n}\n</code></pre>\n<p>在配置文件<code>application.yml</code>里，使用加密后的值，加个特殊的前缀，例如<code>SEC@</code></p>\n<pre><code class=\"language-yml\">spring:\n  datasource:\n    url: jdbc:mysql://192.168.0.111:3306/test\n    username: SEC@cm9vdA==\n    password: SEC@TXlzcWxAMTIz\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n</code></pre>\n<p>在<code>pom.xml</code>中添加<code>jasypt-spring-boot-starter</code>依赖</p>\n<pre><code class=\"language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;    \n    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;2.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>写一个<code>Configuration</code>  bean，实现<code>jasypt</code>提供的<code>EncryptablePropertyResolver</code>接口，在<code>resolvePropertyValue(String value)</code>方法中将配置文件中前缀为<code>SEC@</code>的加了密的value截取出来，使用之前写好的解密方法进行解密。</p>\n<pre><code class=\"language-java\">import com.swcares.attms.util.EncryptUtil;\nimport com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class EncryptionPropertyConfig {\n\n    @Bean(name = &quot;encryptablePropertyResolver&quot;)\n    public EncryptablePropertyResolver encryptablePropertyResolver() {\n        return new EncryptionPropertyResolver();    \n    }    \n    \n    class EncryptionPropertyResolver implements EncryptablePropertyResolver {\n        @Override        \n        public String resolvePropertyValue(String value) {            \n            if (value.startsWith(&quot;SEC@&quot;)) {                \n                String propertyValue = value.substring(4);               \n                return EncryptUtil.decode(propertyValue);            \n            }\n            return value;        \n        }       \n    }\n}\n\n</code></pre>\n<p>之前写过一个<a href=\"__GHOST_URL__/springxiang-mu-shu-ju-ku-mi-ma-jia-mi/\">Spring项目数据库密码加密</a>，是普通的Spring项目的实现，原理都一样，加个密再用，至少比明文密码安全一点。</p>\n<p>The end.</p>\n<!--kg-card-end: markdown-->","comment_id":"619b491feff3f40001c5e961","plaintext":"写一个工具类 EncryptUtil.java，完成加密解密方法\n\n// 加密\npublic static String encode(String value){\n    if(StringUtils.isNotBlank(value)){        \n        Base64 base64 = new Base64();       \n        return new String(base64.encode(value.getBytes()));   \n    }    \n    return null;\n}\n\n// 解密\npublic static String decode(String value){    \n    if(StringUtils.isNotBlank(value)){       \n        Base64 base64 = new Base64();        \n        return new String(base64.decode(value.getBytes()));    \n    }    \n    return null;\n}\n\n\n在配置文件application.yml里，使用加密后的值，加个特殊的前缀，例如SEC@\n\nspring:\n  datasource:\n    url: jdbc:mysql://192.168.0.111:3306/test\n    username: SEC@cm9vdA==\n    password: SEC@TXlzcWxAMTIz\n    type: com.alibaba.druid.pool.DruidDataSource\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n\n在pom.xml中添加jasypt-spring-boot-starter依赖\n\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>    \n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>2.1.0</version>\n</dependency>\n\n\n写一个Configuration bean，实现jasypt提供的EncryptablePropertyResolver接口，在\nresolvePropertyValue(String value)方法中将配置文件中前缀为SEC@\n的加了密的value截取出来，使用之前写好的解密方法进行解密。\n\nimport com.swcares.attms.util.EncryptUtil;\nimport com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class EncryptionPropertyConfig {\n\n    @Bean(name = \"encryptablePropertyResolver\")\n    public EncryptablePropertyResolver encryptablePropertyResolver() {\n        return new EncryptionPropertyResolver();    \n    }    \n    \n    class EncryptionPropertyResolver implements EncryptablePropertyResolver {\n        @Override        \n        public String resolvePropertyValue(String value) {            \n            if (value.startsWith(\"SEC@\")) {                \n                String propertyValue = value.substring(4);               \n                return EncryptUtil.decode(propertyValue);            \n            }\n            return value;        \n        }       \n    }\n}\n\n\n\n之前写过一个Spring项目数据库密码加密\n[http://nocoder.org/springxiang-mu-shu-ju-ku-mi-ma-jia-mi/]\n，是普通的Spring项目的实现，原理都一样，加个密再用，至少比明文密码安全一点。\n\nThe end.","feature_image":null,"featured":0,"type":"post","status":"published","locale":null,"visibility":"public","email_recipient_filter":"none","author_id":"1","created_at":"2021-11-22 07:39:11","created_by":"1","updated_at":"2021-11-22 07:50:30","updated_by":"1","published_at":"2021-11-22 07:41:10","published_by":"1","custom_excerpt":null,"codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null}],"posts_meta":[],"users":[{"id":"1","name":"Jason Yang","slug":"jason","password":"$2a$10$Tpx1vvOP/.0fyUBpoV20pOIZfhwMLoDHCStstGvIfWMyDH0UAl8M6","email":"yangjinlong86@126.com","profile_image":"__GHOST_URL__/content/images/2021/10/----_20211009112710.jpg","cover_image":null,"bio":null,"website":"http://nocoder.org","location":null,"facebook":null,"twitter":"@yangjinlong86","accessibility":"{\"nightShift\":false,\"launchComplete\":true,\"whatsNew\":{\"lastSeenDate\":\"2021-10-05T13:12:23.000+00:00\"},\"navigation\":{\"expanded\":{\"posts\":true}}}","status":"active","locale":null,"visibility":"public","meta_title":null,"meta_description":null,"tour":null,"last_seen":"2021-11-22 07:36:07","created_at":"2021-10-08 16:37:13","created_by":"1","updated_at":"2021-11-22 07:36:07","updated_by":"1"}],"posts_authors":[{"id":"6160769067f6c50001275528","post_id":"6160769067f6c50001275527","author_id":"1","sort_order":0},{"id":"61607b040af28a00012bf0df","post_id":"61607b040af28a00012bf0de","author_id":"1","sort_order":0},{"id":"61607f310af28a00012bf106","post_id":"61607f310af28a00012bf105","author_id":"1","sort_order":0},{"id":"6164fc580af28a00012bf12c","post_id":"6164fc580af28a00012bf12b","author_id":"1","sort_order":0},{"id":"616562600af28a00012bf138","post_id":"616562600af28a00012bf137","author_id":"1","sort_order":0},{"id":"616564710af28a00012bf14b","post_id":"616564710af28a00012bf14a","author_id":"1","sort_order":0},{"id":"6165652f0af28a00012bf158","post_id":"6165652f0af28a00012bf157","author_id":"1","sort_order":0},{"id":"616566140af28a00012bf165","post_id":"616566140af28a00012bf164","author_id":"1","sort_order":0},{"id":"6165670a0af28a00012bf172","post_id":"6165670a0af28a00012bf171","author_id":"1","sort_order":0},{"id":"618eba1d0af28a00012bf1bc","post_id":"618eba1c0af28a00012bf1bb","author_id":"1","sort_order":0},{"id":"6196fc3a0af28a00012bf1fd","post_id":"6196fc3a0af28a00012bf1fc","author_id":"1","sort_order":0},{"id":"6196ffd50af28a00012bf216","post_id":"6196ffd50af28a00012bf215","author_id":"1","sort_order":0},{"id":"619700590af28a00012bf223","post_id":"619700590af28a00012bf222","author_id":"1","sort_order":0},{"id":"619a6a1ceff3f40001c5e930","post_id":"619a6a1ceff3f40001c5e92f","author_id":"1","sort_order":0},{"id":"619a6ad5eff3f40001c5e946","post_id":"619a6ad5eff3f40001c5e945","author_id":"1","sort_order":0},{"id":"619b491feff3f40001c5e962","post_id":"619b491feff3f40001c5e961","author_id":"1","sort_order":0}],"roles":[{"id":"616073b867f6c50001275352","name":"Administrator","description":"Administrators","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275353","name":"Editor","description":"Editors","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275354","name":"Author","description":"Authors","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275355","name":"Contributor","description":"Contributors","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275356","name":"Owner","description":"Blog Owner","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275357","name":"Admin Integration","description":"External Apps","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275358","name":"DB Backup Integration","description":"Internal DB Backup Client","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"616073b867f6c50001275359","name":"Scheduler Integration","description":"Internal Scheduler Client","created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"}],"roles_users":[{"id":"616073bc67f6c500012754c8","role_id":"616073b867f6c50001275356","user_id":"1"}],"settings":[{"id":"616073bd67f6c500012754c9","group":"core","key":"db_hash","value":"decdf869-cfc3-4b51-8669-4e68d62417a6","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073bd67f6c500012754ca","group":"core","key":"routes_hash","value":"3d180d52c663d173a6be791ef411ed01","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:22","updated_by":"1"},{"id":"616073bd67f6c500012754cb","group":"core","key":"next_update_check","value":"1638272362","type":"number","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-29 11:39:22","updated_by":"1"},{"id":"616073bd67f6c500012754cc","group":"core","key":"notifications","value":"[{\"dismissible\":true,\"location\":\"bottom\",\"status\":\"alert\",\"id\":\"e2bf0e30-4ee2-11ec-8da6-71d1c522a6db\",\"createdAtVersion\":\"4.22.3\",\"custom\":false,\"createdAt\":\"2021-11-26T18:01:31.000Z\",\"type\":\"info\",\"top\":false,\"message\":\"Ghost <a href=\\\"https://github.com/TryGhost/Ghost/releases\\\">4.24.0</a> has been released, <a href=\\\"https://ghost.org/update/?v=4.22.3\\\">click here</a> to upgrade.\",\"seen\":false,\"addedAt\":\"2021-11-27T11:39:22.706Z\"}]","type":"array","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-27 11:39:22","updated_by":"1"},{"id":"616073bd67f6c500012754cd","group":"core","key":"session_secret","value":"f5e741290cf5a5f285cfb7032ea99040083c8edaa03ad77114dcffe1bbf939bf","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073bd67f6c500012754ce","group":"core","key":"theme_session_secret","value":"a2283caa624546e5996fb4730b3d20231a43317861e47980ba4a8e14594abdbe","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754cf","group":"core","key":"ghost_public_key","value":"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAKIyVOwnRy/UC6Xoqsgw5nIIsOFfjMyYmRyrEO3GpbVHnThagSA+xjVqqsmJaq0p\n2NDoGTnyRX56vvYcL7tzIWzRFgXrkOIsBwOy5RONHoFDLSpuz53VASV7vp003uKsSy2VJhXj\nQY/2UfazuTPEI2w65PItPhhoFGW7ei6XgB7nAgMBAAE=\n-----END RSA PUBLIC KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d0","group":"core","key":"ghost_private_key","value":"-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCiMlTsJ0cv1Aul6KrIMOZyCLDhX4zMmJkcqxDtxqW1R504WoEgPsY1aqrJ\niWqtKdjQ6Bk58kV+er72HC+7cyFs0RYF65DiLAcDsuUTjR6BQy0qbs+d1QEle76dNN7irEst\nlSYV40GP9lH2s7kzxCNsOuTyLT4YaBRlu3oul4Ae5wIDAQABAoGATtUhu2nXyqJISwoLv6Ms\nzi31MoULXQGqIWnvn3HWZoZ5HsO2UOLR2XKPscatZ56YN+knIafkKPYlzF6kwHnTu1TX4eSk\nsZGjjaLw+JnQhPsuOvK6r2hiwDYLHafpDeiuE8fL3N28pRFSpzH/c8D8AgbZeI7lRu8uYDrM\nShCa/5kCQQDqdn8IaIgLnrOJtmom6BYKa1WLvXwWmf6XyedNg+mAW3rxR+U3DCt1iCCvgLO1\nOt/wPGtAX5P633wAcPeV1N4dAkEAsRh15q5dsTtWGJ8PzKRjv/HJb0kvAQ1FLunjIqNUx1Bv\nPEhu0T8iiUsxsDrNAAzPfU2P2fGO4QIXnrnNnHex0wJARKveOx06s4SQ+0XFQ434XqbfUGV4\nQbpq2hRVvdtj+adRk/fFx+C1nd/4Cs88U1liG5/mnd0gn3rze8GaknTddQJBAK8ww3GwjH8H\nc+Rndfm7pfH7/olYnGct+YKvXUKm0PdbWq8H+JiHHGM1P7JWePXTtm7+i4/OpslwiG084Won\n/oECQCYnPpKRdyBtL3Dd1AgUf2wgKYSkvu/CeYjqHIBX2/cnyBvwPa1l8tnC5e0B0BukVwj5\nRnOzyAEvfQvgF/TI2LY=\n-----END RSA PRIVATE KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d1","group":"core","key":"members_public_key","value":"-----BEGIN RSA PUBLIC KEY-----\nMIGJAoGBAJL8tw0Uv7XFLq8s+vr6l1bXCLlzuu0zI5zSxd4REhdbwpFb2hX+7KdXsXsUJce4\nlgVMBilwKQRPXR9ldN+jM8WAinpSkMWaJJ/T+TD1LANFoVbpQvFws+Ep/iubuN/w9oQ6FBb0\napUwIce4QCs3ZnjHmCEIYd+fH2hW3tUlYq5xAgMBAAE=\n-----END RSA PUBLIC KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d2","group":"core","key":"members_private_key","value":"-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCS/LcNFL+1xS6vLPr6+pdW1wi5c7rtMyOc0sXeERIXW8KRW9oV/uynV7F7\nFCXHuJYFTAYpcCkET10fZXTfozPFgIp6UpDFmiSf0/kw9SwDRaFW6ULxcLPhKf4rm7jf8PaE\nOhQW9GqVMCHHuEArN2Z4x5ghCGHfnx9oVt7VJWKucQIDAQABAoGATyGCIqay9taq5V/f1lIm\nO3gUmFJ3pc9MMtc98ulZxf1+Z+b9J65QFV8ei1YzaKw1B7D/+DsLuehIB+kE3IjuC2riZyV2\nfNrs7BFJlVYRWFP5lXZ4JOGVbw3rlrjxt5u9VW/fvI1O1t+C+g/Rqa7qcHU4U5+12IOGiGUZ\nKrNLUIkCQQDD6bMKowMiXw+QZ2fWRSA1wf8+B7BWBgZW9r9KaL+VJX8I09bPV/zwh4XzusGD\nYKJcLsuy3FhXNCaUUPPi2QiXAkEAwBGQEKvJkXzs7w5gzIsZEJWKUGugWJzQQAG+kNeAZpPJ\nf0k+pH1EvvGBCF13SCvc1hD+q5Rbk4+Dymh/1wGaNwJBAK0mJSlnfWOpZJYZ7joACkG43Z+z\nJ/Q/iubdWZ+oCHsHEsl4gMfsWg8zl/4btuAoThbu/PVtrV4VJ2u6SHLboq0CQEvoZQSBsDck\npUtRZmZQbwaD41cnQgbjatZxGgyKbv+bVt5MZ0qBC6NfNPzGW7cVRsD/lHbhOlQWOyLKrAOg\naX8CQEtGLdXkf30PY/SspMBuMu4oos9x5MJ0x4I6x6Nj2eiRLk8gBv0Lkk731sx4lHI3MHLx\npC/8oK8uqvFh2o5djes=\n-----END RSA PRIVATE KEY-----\n","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d3","group":"core","key":"members_email_auth_secret","value":"4db94a26d45df2ab838e3b3d30e44bc75028f741ba295845fd5df49893e0f78838aeb31ca6ba42950dff89314c8b760868a216bf202b310b5d3a3c668944da1f","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d6","group":"site","key":"title","value":"Nocoder","type":"string","flags":"PUBLIC","created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-12 19:22:47","updated_by":"1"},{"id":"616073be67f6c500012754d7","group":"site","key":"description","value":"Standing on the shoulders of giants","type":"string","flags":"PUBLIC","created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-12 19:23:31","updated_by":"1"},{"id":"616073be67f6c500012754d8","group":"site","key":"logo","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:37:18","updated_by":"1"},{"id":"616073be67f6c500012754d9","group":"site","key":"cover_image","value":"__GHOST_URL__/content/images/2021/10/binlog-1.jpg","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-09 01:18:23","updated_by":"1"},{"id":"616073be67f6c500012754da","group":"site","key":"icon","value":"__GHOST_URL__/content/images/2021/10/20-terminal-1.png","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-09 01:18:23","updated_by":"1"},{"id":"616073be67f6c500012754db","group":"site","key":"accent_color","value":"#4292ea","type":"string","flags":"PUBLIC","created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-09 01:18:23","updated_by":"1"},{"id":"616073be67f6c500012754dc","group":"site","key":"lang","value":"cn","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-19 16:19:32","updated_by":"1"},{"id":"616073be67f6c500012754dd","group":"site","key":"timezone","value":"Asia/Hong_Kong","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-10-08 16:52:26","updated_by":"1"},{"id":"616073be67f6c500012754de","group":"site","key":"codeinjection_head","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-13 05:19:08","updated_by":"1"},{"id":"616073be67f6c500012754df","group":"site","key":"codeinjection_foot","value":"<script type=\"text/javascript\">document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1257391581'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1257391581%26show%3Dpic' type='text/javascript'%3E%3C/script%3E\"));</script>","type":"string","flags":null,"created_at":"2021-10-08 16:37:18","created_by":"1","updated_at":"2021-11-19 06:38:41","updated_by":"1"},{"id":"616073be67f6c500012754e0","group":"site","key":"facebook","value":"profile.php?id=100023141842030","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-12 19:22:47","updated_by":"1"},{"id":"616073be67f6c500012754e1","group":"site","key":"twitter","value":"@yangjinlong86","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-12 19:22:47","updated_by":"1"},{"id":"616073be67f6c500012754e2","group":"site","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"http://nocoder.org\"},{\"label\":\"Author\",\"url\":\"/author/jason/\"},{\"label\":\"Github\",\"url\":\"https://github.com/nocdr\"}]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-21 17:36:19","updated_by":"1"},{"id":"616073be67f6c500012754e3","group":"site","key":"secondary_navigation","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-19 16:21:05","updated_by":"1"},{"id":"616073be67f6c500012754e4","group":"site","key":"meta_title","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e5","group":"site","key":"meta_description","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e6","group":"site","key":"og_image","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e7","group":"site","key":"og_title","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e8","group":"site","key":"og_description","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754e9","group":"site","key":"twitter_image","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ea","group":"site","key":"twitter_title","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754eb","group":"site","key":"twitter_description","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ec","group":"theme","key":"active_theme","value":"ruby","type":"string","flags":"RO","created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-19 15:58:56","updated_by":"1"},{"id":"616073be67f6c500012754ed","group":"private","key":"is_private","value":"false","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ee","group":"private","key":"password","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754ef","group":"private","key":"public_hash","value":"b6353c851c0e2e42064f98d9d09e5f","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f0","group":"members","key":"default_content_visibility","value":"public","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f1","group":"members","key":"members_signup_access","value":"none","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-09 01:20:22","updated_by":"1"},{"id":"616073be67f6c500012754f2","group":"members","key":"members_from_address","value":"noreply","type":"string","flags":"RO","created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f3","group":"members","key":"members_support_address","value":"noreply","type":"string","flags":"PUBLIC,RO","created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f4","group":"members","key":"members_reply_address","value":"newsletter","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f5","group":"members","key":"members_free_signup_redirect","value":"/","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f6","group":"members","key":"members_paid_signup_redirect","value":"/","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754f7","group":"members","key":"stripe_product_name","value":"Ghost Subscription","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754fa","group":"members","key":"stripe_plans","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754fd","group":"members","key":"stripe_connect_livemode","value":null,"type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c500012754fe","group":"members","key":"stripe_connect_display_name","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275500","group":"members","key":"members_free_price_name","value":"Free","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275501","group":"members","key":"members_free_price_description","value":"Free preview","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275502","group":"members","key":"members_monthly_price_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275503","group":"members","key":"members_yearly_price_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275504","group":"portal","key":"portal_name","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275505","group":"portal","key":"portal_button","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275506","group":"portal","key":"portal_plans","value":"[\"free\"]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275507","group":"portal","key":"portal_products","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275508","group":"portal","key":"portal_button_style","value":"icon-and-text","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275509","group":"portal","key":"portal_button_icon","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550a","group":"portal","key":"portal_button_signup_text","value":"Subscribe","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550b","group":"email","key":"mailgun_domain","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550c","group":"email","key":"mailgun_api_key","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550d","group":"email","key":"mailgun_base_url","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127550e","group":"email","key":"email_track_opens","value":"false","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-21 17:33:13","updated_by":"1"},{"id":"616073be67f6c50001275510","group":"amp","key":"amp","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275511","group":"amp","key":"amp_gtag_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275512","group":"firstpromoter","key":"firstpromoter","value":"false","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275513","group":"firstpromoter","key":"firstpromoter_id","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275514","group":"labs","key":"labs","value":"{}","type":"object","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275515","group":"slack","key":"slack_url","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-21 17:36:19","updated_by":"1"},{"id":"616073be67f6c50001275516","group":"slack","key":"slack_username","value":"Ghost","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-11-21 17:36:19","updated_by":"1"},{"id":"616073be67f6c50001275517","group":"unsplash","key":"unsplash","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275518","group":"views","key":"shared_views","value":"[]","type":"array","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275519","group":"newsletter","key":"newsletter_show_badge","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551a","group":"newsletter","key":"newsletter_header_image","value":null,"type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551b","group":"newsletter","key":"newsletter_show_header_icon","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551c","group":"newsletter","key":"newsletter_show_header_title","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551d","group":"newsletter","key":"newsletter_title_alignment","value":"center","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551e","group":"newsletter","key":"newsletter_title_font_category","value":"sans_serif","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c5000127551f","group":"newsletter","key":"newsletter_show_feature_image","value":"true","type":"boolean","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275520","group":"newsletter","key":"newsletter_body_font_category","value":"sans_serif","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275521","group":"newsletter","key":"newsletter_footer_content","value":"","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275524","group":"editor","key":"editor_default_email_recipients","value":"visibility","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"616073be67f6c50001275525","group":"editor","key":"editor_default_email_recipients_filter","value":"all","type":"string","flags":null,"created_at":"2021-10-08 16:37:19","created_by":"1","updated_at":"2021-10-08 16:37:19","updated_by":"1"},{"id":"6197067beff3f40001c5e8db","group":"editor","key":"editor_is_launch_complete","value":"true","type":"boolean","flags":null,"created_at":"2021-11-19 02:05:47","created_by":"1","updated_at":"2021-11-19 02:05:47","updated_by":"1"}],"tags":[{"id":"616073b867f6c50001275351","name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-08 16:37:12","created_by":"1","updated_at":"2021-10-08 16:37:12","updated_by":"1"},{"id":"617c03e30af28a00012bf19b","name":"ARTS","slug":"arts","description":null,"feature_image":"__GHOST_URL__/content/images/2021/10/unnamed-1.png","parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":"#99bfdb","created_at":"2021-10-29 14:23:31","created_by":"1","updated_at":"2021-10-29 14:35:07","updated_by":"1"},{"id":"617c06ed0af28a00012bf1aa","name":"Spring","slug":"spring","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-29 14:36:29","created_by":"1","updated_at":"2021-10-29 14:36:29","updated_by":"1"},{"id":"617c07160af28a00012bf1ae","name":"Java","slug":"java","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-29 14:37:10","created_by":"1","updated_at":"2021-10-29 14:37:10","updated_by":"1"},{"id":"617c075a0af28a00012bf1b4","name":"Algorithm","slug":"algorithm","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-10-29 14:38:18","created_by":"1","updated_at":"2021-11-19 16:07:00","updated_by":"1"},{"id":"6196fd5f0af28a00012bf20d","name":"Architecture","slug":"architecture","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":"#8ebeec","created_at":"2021-11-19 01:26:55","created_by":"1","updated_at":"2021-11-19 16:06:09","updated_by":"1"},{"id":"6197001e0af28a00012bf21e","name":"Python","slug":"python","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 01:38:38","created_by":"1","updated_at":"2021-11-19 01:38:38","updated_by":"1"},{"id":"61970b74eff3f40001c5e8f5","name":"ReactJS","slug":"reactjs","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 02:27:00","created_by":"1","updated_at":"2021-11-19 02:27:00","updated_by":"1"},{"id":"61970b74eff3f40001c5e8f6","name":"SpringBoot","slug":"springboot","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 02:27:00","created_by":"1","updated_at":"2021-11-19 02:27:00","updated_by":"1"},{"id":"6197ca78eff3f40001c5e911","name":"Management","slug":"management","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 16:02:00","created_by":"1","updated_at":"2021-11-19 16:02:00","updated_by":"1"},{"id":"6197cb33eff3f40001c5e917","name":"Design Pattern","slug":"design-pattern","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 16:05:07","created_by":"1","updated_at":"2021-11-19 16:05:07","updated_by":"1"},{"id":"6197cc38eff3f40001c5e923","name":"Log","slug":"log","description":null,"feature_image":null,"parent_id":null,"visibility":"public","og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null,"codeinjection_head":null,"codeinjection_foot":null,"canonical_url":null,"accent_color":null,"created_at":"2021-11-19 16:09:28","created_by":"1","updated_at":"2021-11-19 16:09:28","updated_by":"1"}],"posts_tags":[{"id":"617c06ed0af28a00012bf1ab","post_id":"616564710af28a00012bf14a","tag_id":"617c06ed0af28a00012bf1aa","sort_order":0},{"id":"617c07290af28a00012bf1b0","post_id":"61607f310af28a00012bf105","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"617c073c0af28a00012bf1b2","post_id":"616564710af28a00012bf14a","tag_id":"617c07160af28a00012bf1ae","sort_order":1},{"id":"617c075a0af28a00012bf1b5","post_id":"61607b040af28a00012bf0de","tag_id":"617c075a0af28a00012bf1b4","sort_order":0},{"id":"6196fd5f0af28a00012bf20e","post_id":"6196fc3a0af28a00012bf1fc","tag_id":"6196fd5f0af28a00012bf20d","sort_order":0},{"id":"6197001e0af28a00012bf21f","post_id":"6196ffd50af28a00012bf215","tag_id":"6197001e0af28a00012bf21e","sort_order":0},{"id":"619700bb0af28a00012bf234","post_id":"619700590af28a00012bf222","tag_id":"6197001e0af28a00012bf21e","sort_order":0},{"id":"61970b74eff3f40001c5e8f7","post_id":"618eba1c0af28a00012bf1bb","tag_id":"61970b74eff3f40001c5e8f5","sort_order":0},{"id":"61970b74eff3f40001c5e8f9","post_id":"618eba1c0af28a00012bf1bb","tag_id":"61970b74eff3f40001c5e8f6","sort_order":1},{"id":"6197ca78eff3f40001c5e912","post_id":"616562600af28a00012bf137","tag_id":"6197ca78eff3f40001c5e911","sort_order":0},{"id":"6197cae3eff3f40001c5e915","post_id":"6165670a0af28a00012bf171","tag_id":"6197ca78eff3f40001c5e911","sort_order":0},{"id":"6197cb33eff3f40001c5e918","post_id":"6164fc580af28a00012bf12b","tag_id":"6197cb33eff3f40001c5e917","sort_order":0},{"id":"6197cbe7eff3f40001c5e920","post_id":"61607f310af28a00012bf105","tag_id":"617c06ed0af28a00012bf1aa","sort_order":1},{"id":"6197cbe7eff3f40001c5e921","post_id":"61607f310af28a00012bf105","tag_id":"6197cb33eff3f40001c5e917","sort_order":2},{"id":"6197cc38eff3f40001c5e924","post_id":"6160769067f6c50001275527","tag_id":"6197cc38eff3f40001c5e923","sort_order":0},{"id":"6197cc50eff3f40001c5e927","post_id":"6165652f0af28a00012bf157","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"6197cd5aeff3f40001c5e929","post_id":"616566140af28a00012bf164","tag_id":"617c075a0af28a00012bf1b4","sort_order":0},{"id":"619a6aa0eff3f40001c5e940","post_id":"619a6a1ceff3f40001c5e92f","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"619a6aa0eff3f40001c5e941","post_id":"619a6a1ceff3f40001c5e92f","tag_id":"617c06ed0af28a00012bf1aa","sort_order":1},{"id":"619a6c28eff3f40001c5e94e","post_id":"619a6ad5eff3f40001c5e945","tag_id":"617c07160af28a00012bf1ae","sort_order":0},{"id":"619b4996eff3f40001c5e973","post_id":"619b491feff3f40001c5e961","tag_id":"61970b74eff3f40001c5e8f6","sort_order":0}],"custom_theme_settings":[{"id":"6197067deff3f40001c5e8dc","theme":"casper","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"6197067deff3f40001c5e8dd","theme":"casper","key":"body_font","type":"select","value":"Elegant serif"},{"id":"6197067deff3f40001c5e8de","theme":"casper","key":"publication_cover_style","type":"select","value":"Medium"},{"id":"6197067deff3f40001c5e8df","theme":"casper","key":"feed_layout","type":"select","value":"Dynamic grid"},{"id":"6197067deff3f40001c5e8e0","theme":"casper","key":"color_scheme","type":"select","value":"Light"},{"id":"6197067deff3f40001c5e8e1","theme":"casper","key":"header_button_background","type":"color","value":"#ffffff"},{"id":"6197067deff3f40001c5e8e2","theme":"casper","key":"header_button_text_color","type":"select","value":"Dark"},{"id":"6197067deff3f40001c5e8e3","theme":"casper","key":"post_image_width","type":"select","value":"Wide"},{"id":"6197067deff3f40001c5e8e4","theme":"casper","key":"email_signup_for_logged_out_visitors","type":"select","value":"Footer"},{"id":"6197067deff3f40001c5e8e5","theme":"casper","key":"email_signup_text","type":"text","value":"Sign up for more like this."},{"id":"6197067deff3f40001c5e8e6","theme":"casper","key":"show_recent_posts","type":"boolean","value":"true"},{"id":"619709b8eff3f40001c5e8e8","theme":"journal","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"619709b8eff3f40001c5e8e9","theme":"journal","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61970a5aeff3f40001c5e8eb","theme":"dawn","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"61970a5aeff3f40001c5e8ec","theme":"dawn","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61970a5aeff3f40001c5e8ed","theme":"dawn","key":"content_api_key_for_search","type":"text","value":null},{"id":"61970a5aeff3f40001c5e8ee","theme":"dawn","key":"show_featured_posts","type":"boolean","value":"true"},{"id":"61970a5aeff3f40001c5e8ef","theme":"dawn","key":"featured_title","type":"text","value":"Featured articles"},{"id":"61970a5aeff3f40001c5e8f0","theme":"dawn","key":"show_share_links","type":"boolean","value":"true"},{"id":"61970a5aeff3f40001c5e8f1","theme":"dawn","key":"show_author","type":"boolean","value":"true"},{"id":"61970a5aeff3f40001c5e8f2","theme":"dawn","key":"show_related_posts","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e8fe","theme":"alto","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"61973a8aeff3f40001c5e8ff","theme":"alto","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"61973a8aeff3f40001c5e900","theme":"alto","key":"show_featured_posts","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e901","theme":"alto","key":"show_share_links","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e902","theme":"alto","key":"show_author","type":"boolean","value":"true"},{"id":"61973a8aeff3f40001c5e903","theme":"alto","key":"show_related_posts","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90a","theme":"ruby","key":"title_font","type":"select","value":"Modern sans-serif"},{"id":"6197c9c0eff3f40001c5e90b","theme":"ruby","key":"body_font","type":"select","value":"Modern sans-serif"},{"id":"6197c9c0eff3f40001c5e90c","theme":"ruby","key":"show_sidebar_on_homepage","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90d","theme":"ruby","key":"show_related_posts","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90e","theme":"ruby","key":"show_sidebar_on_post","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e90f","theme":"ruby","key":"show_share_links","type":"boolean","value":"true"},{"id":"6197c9c0eff3f40001c5e910","theme":"ruby","key":"show_author","type":"boolean","value":"true"}]}}